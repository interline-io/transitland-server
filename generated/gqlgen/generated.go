// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gqlgen

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/interline-io/transitland-lib/tl/tt"
	"github.com/interline-io/transitland-server/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Agency() AgencyResolver
	Calendar() CalendarResolver
	CensusGeography() CensusGeographyResolver
	CensusValue() CensusValueResolver
	Feed() FeedResolver
	FeedState() FeedStateResolver
	FeedVersion() FeedVersionResolver
	FeedVersionGtfsImport() FeedVersionGtfsImportResolver
	Level() LevelResolver
	Mutation() MutationResolver
	Operator() OperatorResolver
	Pathway() PathwayResolver
	Place() PlaceResolver
	Query() QueryResolver
	Route() RouteResolver
	RouteHeadway() RouteHeadwayResolver
	RouteStop() RouteStopResolver
	RouteStopPattern() RouteStopPatternResolver
	Stop() StopResolver
	StopExternalReference() StopExternalReferenceResolver
	StopTime() StopTimeResolver
	Trip() TripResolver
}

type DirectiveRoot struct {
	HasRole func(ctx context.Context, obj interface{}, next graphql.Resolver, role model.Role) (res interface{}, err error)
}

type ComplexityRoot struct {
	Agency struct {
		AgencyEmail       func(childComplexity int) int
		AgencyFareURL     func(childComplexity int) int
		AgencyID          func(childComplexity int) int
		AgencyLang        func(childComplexity int) int
		AgencyName        func(childComplexity int) int
		AgencyPhone       func(childComplexity int) int
		AgencyTimezone    func(childComplexity int) int
		AgencyURL         func(childComplexity int) int
		Alerts            func(childComplexity int, active *bool, limit *int) int
		CensusGeographies func(childComplexity int, layer string, radius *float64, limit *int) int
		FeedOnestopID     func(childComplexity int) int
		FeedVersion       func(childComplexity int) int
		FeedVersionSHA1   func(childComplexity int) int
		Geometry          func(childComplexity int) int
		ID                func(childComplexity int) int
		OnestopID         func(childComplexity int) int
		Operator          func(childComplexity int) int
		Places            func(childComplexity int, limit *int, where *model.AgencyPlaceFilter) int
		Routes            func(childComplexity int, limit *int, where *model.RouteFilter) int
		SearchRank        func(childComplexity int) int
	}

	AgencyPlace struct {
		Adm0Name func(childComplexity int) int
		Adm1Name func(childComplexity int) int
		CityName func(childComplexity int) int
		Rank     func(childComplexity int) int
	}

	Alert struct {
		ActivePeriod       func(childComplexity int) int
		Cause              func(childComplexity int) int
		DescriptionText    func(childComplexity int) int
		Effect             func(childComplexity int) int
		HeaderText         func(childComplexity int) int
		SeverityLevel      func(childComplexity int) int
		TtsDescriptionText func(childComplexity int) int
		TtsHeaderText      func(childComplexity int) int
		URL                func(childComplexity int) int
	}

	Calendar struct {
		AddedDates   func(childComplexity int, limit *int) int
		EndDate      func(childComplexity int) int
		Friday       func(childComplexity int) int
		ID           func(childComplexity int) int
		Monday       func(childComplexity int) int
		RemovedDates func(childComplexity int, limit *int) int
		Saturday     func(childComplexity int) int
		ServiceID    func(childComplexity int) int
		StartDate    func(childComplexity int) int
		Sunday       func(childComplexity int) int
		Thursday     func(childComplexity int) int
		Tuesday      func(childComplexity int) int
		Wednesday    func(childComplexity int) int
	}

	CensusGeography struct {
		Aland     func(childComplexity int) int
		Awater    func(childComplexity int) int
		Geoid     func(childComplexity int) int
		Geometry  func(childComplexity int) int
		ID        func(childComplexity int) int
		LayerName func(childComplexity int) int
		Name      func(childComplexity int) int
		Values    func(childComplexity int, tableNames []string, limit *int) int
	}

	CensusTable struct {
		ID         func(childComplexity int) int
		TableGroup func(childComplexity int) int
		TableName  func(childComplexity int) int
		TableTitle func(childComplexity int) int
	}

	CensusValue struct {
		Table  func(childComplexity int) int
		Values func(childComplexity int) int
	}

	Directions struct {
		DataSource  func(childComplexity int) int
		Destination func(childComplexity int) int
		Distance    func(childComplexity int) int
		Duration    func(childComplexity int) int
		EndTime     func(childComplexity int) int
		Exception   func(childComplexity int) int
		Itineraries func(childComplexity int) int
		Origin      func(childComplexity int) int
		StartTime   func(childComplexity int) int
		Success     func(childComplexity int) int
	}

	Distance struct {
		Distance func(childComplexity int) int
		Units    func(childComplexity int) int
	}

	Duration struct {
		Duration func(childComplexity int) int
		Units    func(childComplexity int) int
	}

	Feed struct {
		AssociatedOperators func(childComplexity int) int
		Authorization       func(childComplexity int) int
		FeedFetches         func(childComplexity int, limit *int, where *model.FeedFetchFilter) int
		FeedState           func(childComplexity int) int
		FeedVersions        func(childComplexity int, limit *int, where *model.FeedVersionFilter) int
		File                func(childComplexity int) int
		ID                  func(childComplexity int) int
		Languages           func(childComplexity int) int
		License             func(childComplexity int) int
		Name                func(childComplexity int) int
		OnestopID           func(childComplexity int) int
		SearchRank          func(childComplexity int) int
		Spec                func(childComplexity int) int
		Tags                func(childComplexity int) int
		Urls                func(childComplexity int) int
	}

	FeedAuthorization struct {
		InfoURL   func(childComplexity int) int
		ParamName func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	FeedFetch struct {
		FetchError   func(childComplexity int) int
		FetchedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		ResponseCode func(childComplexity int) int
		ResponseSha1 func(childComplexity int) int
		ResponseSize func(childComplexity int) int
		Success      func(childComplexity int) int
		URL          func(childComplexity int) int
		URLType      func(childComplexity int) int
	}

	FeedInfo struct {
		DefaultLang       func(childComplexity int) int
		FeedContactEmail  func(childComplexity int) int
		FeedContactURL    func(childComplexity int) int
		FeedEndDate       func(childComplexity int) int
		FeedLang          func(childComplexity int) int
		FeedPublisherName func(childComplexity int) int
		FeedPublisherURL  func(childComplexity int) int
		FeedStartDate     func(childComplexity int) int
		FeedVersion       func(childComplexity int) int
		ID                func(childComplexity int) int
	}

	FeedLicense struct {
		AttributionInstructions func(childComplexity int) int
		AttributionText         func(childComplexity int) int
		CommercialUseAllowed    func(childComplexity int) int
		CreateDerivedProduct    func(childComplexity int) int
		RedistributionAllowed   func(childComplexity int) int
		ShareAlikeOptional      func(childComplexity int) int
		SpdxIdentifier          func(childComplexity int) int
		URL                     func(childComplexity int) int
		UseWithoutAttribution   func(childComplexity int) int
	}

	FeedState struct {
		FeedVersion func(childComplexity int) int
		ID          func(childComplexity int) int
	}

	FeedUrls struct {
		GbfsAutoDiscovery        func(childComplexity int) int
		MdsProvider              func(childComplexity int) int
		RealtimeAlerts           func(childComplexity int) int
		RealtimeTripUpdates      func(childComplexity int) int
		RealtimeVehiclePositions func(childComplexity int) int
		StaticCurrent            func(childComplexity int) int
		StaticHistoric           func(childComplexity int) int
		StaticPlanned            func(childComplexity int) int
	}

	FeedVersion struct {
		Agencies              func(childComplexity int, limit *int, where *model.AgencyFilter) int
		CreatedBy             func(childComplexity int) int
		Description           func(childComplexity int) int
		EarliestCalendarDate  func(childComplexity int) int
		Feed                  func(childComplexity int) int
		FeedInfos             func(childComplexity int, limit *int) int
		FeedVersionGtfsImport func(childComplexity int) int
		FetchedAt             func(childComplexity int) int
		File                  func(childComplexity int) int
		Files                 func(childComplexity int, limit *int) int
		Geometry              func(childComplexity int) int
		ID                    func(childComplexity int) int
		LatestCalendarDate    func(childComplexity int) int
		Name                  func(childComplexity int) int
		Routes                func(childComplexity int, limit *int, where *model.RouteFilter) int
		SHA1                  func(childComplexity int) int
		ServiceLevels         func(childComplexity int, limit *int, where *model.FeedVersionServiceLevelFilter) int
		Stops                 func(childComplexity int, limit *int, where *model.StopFilter) int
		Trips                 func(childComplexity int, limit *int, where *model.TripFilter) int
		URL                   func(childComplexity int) int
		UpdatedBy             func(childComplexity int) int
	}

	FeedVersionDeleteResult struct {
		Success func(childComplexity int) int
	}

	FeedVersionFetchResult struct {
		FeedVersion  func(childComplexity int) int
		FetchError   func(childComplexity int) int
		FoundDirSHA1 func(childComplexity int) int
		FoundSHA1    func(childComplexity int) int
	}

	FeedVersionFileInfo struct {
		CSVLike func(childComplexity int) int
		Header  func(childComplexity int) int
		ID      func(childComplexity int) int
		Name    func(childComplexity int) int
		Rows    func(childComplexity int) int
		SHA1    func(childComplexity int) int
		Size    func(childComplexity int) int
	}

	FeedVersionGtfsImport struct {
		CreatedAt                 func(childComplexity int) int
		EntityCount               func(childComplexity int) int
		ExceptionLog              func(childComplexity int) int
		ID                        func(childComplexity int) int
		InProgress                func(childComplexity int) int
		InterpolatedStopTimeCount func(childComplexity int) int
		ScheduleRemoved           func(childComplexity int) int
		SkipEntityErrorCount      func(childComplexity int) int
		SkipEntityFilterCount     func(childComplexity int) int
		SkipEntityMarkedCount     func(childComplexity int) int
		SkipEntityReferenceCount  func(childComplexity int) int
		Success                   func(childComplexity int) int
		UpdatedAt                 func(childComplexity int) int
		WarningCount              func(childComplexity int) int
	}

	FeedVersionImportResult struct {
		Success func(childComplexity int) int
	}

	FeedVersionServiceLevel struct {
		EndDate   func(childComplexity int) int
		Friday    func(childComplexity int) int
		ID        func(childComplexity int) int
		Monday    func(childComplexity int) int
		Saturday  func(childComplexity int) int
		StartDate func(childComplexity int) int
		Sunday    func(childComplexity int) int
		Thursday  func(childComplexity int) int
		Tuesday   func(childComplexity int) int
		Wednesday func(childComplexity int) int
	}

	FeedVersionUnimportResult struct {
		Success func(childComplexity int) int
	}

	Frequency struct {
		EndTime     func(childComplexity int) int
		ExactTimes  func(childComplexity int) int
		HeadwaySecs func(childComplexity int) int
		ID          func(childComplexity int) int
		StartTime   func(childComplexity int) int
	}

	GbfsAlertTime struct {
		End   func(childComplexity int) int
		Start func(childComplexity int) int
	}

	GbfsBrandAsset struct {
		BrandImageURL     func(childComplexity int) int
		BrandImageURLDark func(childComplexity int) int
		BrandLastModified func(childComplexity int) int
		BrandTermsURL     func(childComplexity int) int
		Color             func(childComplexity int) int
	}

	GbfsFeed struct {
		Alerts             func(childComplexity int) int
		Calendars          func(childComplexity int) int
		RentalHours        func(childComplexity int) int
		StationInformation func(childComplexity int) int
		SystemInformation  func(childComplexity int) int
	}

	GbfsFreeBikeStatus struct {
		AvailableUntil     func(childComplexity int) int
		BikeID             func(childComplexity int) int
		CurrentFuelPercent func(childComplexity int) int
		CurrentRangeMeters func(childComplexity int) int
		Feed               func(childComplexity int) int
		HomeStation        func(childComplexity int) int
		IsDisabled         func(childComplexity int) int
		IsReserved         func(childComplexity int) int
		LastReported       func(childComplexity int) int
		Lat                func(childComplexity int) int
		Lon                func(childComplexity int) int
		PricingPlan        func(childComplexity int) int
		RentalUris         func(childComplexity int) int
		Station            func(childComplexity int) int
		VehicleEquipment   func(childComplexity int) int
		VehicleType        func(childComplexity int) int
	}

	GbfsGeofenceFeature struct {
		Geometry func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	GbfsGeofenceProperty struct {
		End   func(childComplexity int) int
		Name  func(childComplexity int) int
		Rules func(childComplexity int) int
		Start func(childComplexity int) int
	}

	GbfsGeofenceRule struct {
		MaximumSpeedKph    func(childComplexity int) int
		RideAllowed        func(childComplexity int) int
		RideThroughAllowed func(childComplexity int) int
		StationParking     func(childComplexity int) int
		VehicleType        func(childComplexity int) int
	}

	GbfsGeofenceZone struct {
		Features func(childComplexity int) int
		Type     func(childComplexity int) int
	}

	GbfsPlanPrice struct {
		End      func(childComplexity int) int
		Interval func(childComplexity int) int
		Rate     func(childComplexity int) int
		Start    func(childComplexity int) int
	}

	GbfsRentalApp struct {
		DiscoveryURI func(childComplexity int) int
		StoreURI     func(childComplexity int) int
	}

	GbfsRentalApps struct {
		Android func(childComplexity int) int
		Ios     func(childComplexity int) int
	}

	GbfsRentalUris struct {
		Android func(childComplexity int) int
		IOS     func(childComplexity int) int
		Web     func(childComplexity int) int
	}

	GbfsStationInformation struct {
		Address           func(childComplexity int) int
		Capacity          func(childComplexity int) int
		ContactPhone      func(childComplexity int) int
		CrossStreet       func(childComplexity int) int
		Feed              func(childComplexity int) int
		IsChargingStation func(childComplexity int) int
		IsValetStation    func(childComplexity int) int
		IsVirtualStation  func(childComplexity int) int
		Lat               func(childComplexity int) int
		Lon               func(childComplexity int) int
		Name              func(childComplexity int) int
		ParkingHoop       func(childComplexity int) int
		ParkingType       func(childComplexity int) int
		PostCode          func(childComplexity int) int
		Region            func(childComplexity int) int
		RentalMethods     func(childComplexity int) int
		ShortName         func(childComplexity int) int
		StationArea       func(childComplexity int) int
		StationID         func(childComplexity int) int
		Status            func(childComplexity int) int
	}

	GbfsStationStatus struct {
		IsInstalled           func(childComplexity int) int
		IsRenting             func(childComplexity int) int
		IsReturning           func(childComplexity int) int
		LastReported          func(childComplexity int) int
		NumBikesAvailable     func(childComplexity int) int
		NumBikesDisabled      func(childComplexity int) int
		NumDocksAvailable     func(childComplexity int) int
		NumDocksDisabled      func(childComplexity int) int
		StationID             func(childComplexity int) int
		VehicleDocksAvailable func(childComplexity int) int
		VehicleTypesAvailable func(childComplexity int) int
	}

	GbfsSystemAlert struct {
		AlertID     func(childComplexity int) int
		Description func(childComplexity int) int
		LastUpdated func(childComplexity int) int
		Summary     func(childComplexity int) int
		Times       func(childComplexity int) int
		Type        func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	GbfsSystemCalendar struct {
		EndDay     func(childComplexity int) int
		EndMonth   func(childComplexity int) int
		EndYear    func(childComplexity int) int
		StartDay   func(childComplexity int) int
		StartMonth func(childComplexity int) int
		StartYear  func(childComplexity int) int
	}

	GbfsSystemHour struct {
		Days      func(childComplexity int) int
		EndTime   func(childComplexity int) int
		StartTime func(childComplexity int) int
		UserTypes func(childComplexity int) int
	}

	GbfsSystemInformation struct {
		BrandAssets        func(childComplexity int) int
		Email              func(childComplexity int) int
		FeedContactEmail   func(childComplexity int) int
		Language           func(childComplexity int) int
		LicenseURL         func(childComplexity int) int
		Name               func(childComplexity int) int
		Operator           func(childComplexity int) int
		PhoneNumber        func(childComplexity int) int
		PrivacyLastUpdated func(childComplexity int) int
		PrivacyURL         func(childComplexity int) int
		PurchaseURL        func(childComplexity int) int
		RentalApps         func(childComplexity int) int
		ShortName          func(childComplexity int) int
		StartDate          func(childComplexity int) int
		SystemID           func(childComplexity int) int
		TermsLastUpdated   func(childComplexity int) int
		TermsURL           func(childComplexity int) int
		Timezone           func(childComplexity int) int
		URL                func(childComplexity int) int
	}

	GbfsSystemPricingPlan struct {
		Currency      func(childComplexity int) int
		Description   func(childComplexity int) int
		IsTaxable     func(childComplexity int) int
		Name          func(childComplexity int) int
		PerKmPricing  func(childComplexity int) int
		PerMinPricing func(childComplexity int) int
		PlanID        func(childComplexity int) int
		Price         func(childComplexity int) int
		SurgePricing  func(childComplexity int) int
		URL           func(childComplexity int) int
	}

	GbfsSystemRegion struct {
		Name     func(childComplexity int) int
		RegionID func(childComplexity int) int
	}

	GbfsSystemVersion struct {
		URL     func(childComplexity int) int
		Version func(childComplexity int) int
	}

	GbfsVehicleAssets struct {
		IconLastModified func(childComplexity int) int
		IconURL          func(childComplexity int) int
		IconURLDark      func(childComplexity int) int
	}

	GbfsVehicleDockAvailable struct {
		Count        func(childComplexity int) int
		VehicleTypes func(childComplexity int) int
	}

	GbfsVehicleType struct {
		CargoLoadCapacity   func(childComplexity int) int
		CargoVolumeCapacity func(childComplexity int) int
		Color               func(childComplexity int) int
		CountryCode         func(childComplexity int) int
		DefaultPricingPlan  func(childComplexity int) int
		DefaultReserveTime  func(childComplexity int) int
		EcoLabel            func(childComplexity int) int
		EcoSticker          func(childComplexity int) int
		FormFactor          func(childComplexity int) int
		GCO2Km              func(childComplexity int) int
		Make                func(childComplexity int) int
		MaxPermittedSpeed   func(childComplexity int) int
		MaxRangeMeters      func(childComplexity int) int
		Model               func(childComplexity int) int
		Name                func(childComplexity int) int
		PricingPlans        func(childComplexity int) int
		PropulsionType      func(childComplexity int) int
		RatedPower          func(childComplexity int) int
		RentalUris          func(childComplexity int) int
		ReturnConstraint    func(childComplexity int) int
		RiderCapacity       func(childComplexity int) int
		VehicleAccessories  func(childComplexity int) int
		VehicleAssets       func(childComplexity int) int
		VehicleImage        func(childComplexity int) int
		VehicleTypeID       func(childComplexity int) int
		WheelCount          func(childComplexity int) int
	}

	GbfsVehicleTypeAvailable struct {
		Count             func(childComplexity int) int
		NumBikesDisabled  func(childComplexity int) int
		NumDocksAvailable func(childComplexity int) int
		VehicleType       func(childComplexity int) int
	}

	Itinerary struct {
		Distance  func(childComplexity int) int
		Duration  func(childComplexity int) int
		EndTime   func(childComplexity int) int
		From      func(childComplexity int) int
		Legs      func(childComplexity int) int
		StartTime func(childComplexity int) int
		To        func(childComplexity int) int
	}

	Leg struct {
		Distance  func(childComplexity int) int
		Duration  func(childComplexity int) int
		EndTime   func(childComplexity int) int
		From      func(childComplexity int) int
		Geometry  func(childComplexity int) int
		StartTime func(childComplexity int) int
		Steps     func(childComplexity int) int
		To        func(childComplexity int) int
	}

	Level struct {
		Geometry   func(childComplexity int) int
		ID         func(childComplexity int) int
		LevelID    func(childComplexity int) int
		LevelIndex func(childComplexity int) int
		LevelName  func(childComplexity int) int
		Stops      func(childComplexity int) int
	}

	Mutation struct {
		FeedVersionDelete   func(childComplexity int, id int) int
		FeedVersionFetch    func(childComplexity int, file *graphql.Upload, url *string, feedOnestopID string) int
		FeedVersionImport   func(childComplexity int, sha1 string) int
		FeedVersionUnimport func(childComplexity int, id int) int
		FeedVersionUpdate   func(childComplexity int, id int, set model.FeedVersionSetInput) int
		ValidateGtfs        func(childComplexity int, file *graphql.Upload, url *string, realtimeUrls []string) int
	}

	Operator struct {
		Agencies   func(childComplexity int) int
		Feeds      func(childComplexity int, limit *int, where *model.FeedFilter) int
		File       func(childComplexity int) int
		Generated  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		OnestopID  func(childComplexity int) int
		SearchRank func(childComplexity int) int
		ShortName  func(childComplexity int) int
		Tags       func(childComplexity int) int
		Website    func(childComplexity int) int
	}

	Pathway struct {
		FromStop            func(childComplexity int) int
		ID                  func(childComplexity int) int
		IsBidirectional     func(childComplexity int) int
		Length              func(childComplexity int) int
		MaxSlope            func(childComplexity int) int
		MinWidth            func(childComplexity int) int
		PathwayID           func(childComplexity int) int
		PathwayMode         func(childComplexity int) int
		ReverseSignpostedAs func(childComplexity int) int
		SignpostedAs        func(childComplexity int) int
		StairCount          func(childComplexity int) int
		ToStop              func(childComplexity int) int
		TraversalTime       func(childComplexity int) int
	}

	Place struct {
		Adm0Name  func(childComplexity int) int
		Adm1Name  func(childComplexity int) int
		CityName  func(childComplexity int) int
		Count     func(childComplexity int) int
		Operators func(childComplexity int) int
	}

	Query struct {
		Agencies     func(childComplexity int, limit *int, after *int, ids []int, where *model.AgencyFilter) int
		Bikes        func(childComplexity int, limit *int, where *model.GbfsBikeRequest) int
		Directions   func(childComplexity int, where model.DirectionRequest) int
		Docks        func(childComplexity int, limit *int, where *model.GbfsDockRequest) int
		FeedVersions func(childComplexity int, limit *int, after *int, ids []int, where *model.FeedVersionFilter) int
		Feeds        func(childComplexity int, limit *int, after *int, ids []int, where *model.FeedFilter) int
		Operators    func(childComplexity int, limit *int, after *int, ids []int, where *model.OperatorFilter) int
		Places       func(childComplexity int, limit *int, after *int, level *model.PlaceAggregationLevel, where *model.PlaceFilter) int
		Routes       func(childComplexity int, limit *int, after *int, ids []int, where *model.RouteFilter) int
		Stops        func(childComplexity int, limit *int, after *int, ids []int, where *model.StopFilter) int
		Trips        func(childComplexity int, limit *int, after *int, ids []int, where *model.TripFilter) int
	}

	RTTimeRange struct {
		End   func(childComplexity int) int
		Start func(childComplexity int) int
	}

	RTTranslation struct {
		Language func(childComplexity int) int
		Text     func(childComplexity int) int
	}

	RTTripDescriptor struct {
		DirectionID          func(childComplexity int) int
		RouteID              func(childComplexity int) int
		ScheduleRelationship func(childComplexity int) int
		StartDate            func(childComplexity int) int
		StartTime            func(childComplexity int) int
		TripID               func(childComplexity int) int
	}

	RTVehicleDescriptor struct {
		ID           func(childComplexity int) int
		Label        func(childComplexity int) int
		LicensePlate func(childComplexity int) int
	}

	Route struct {
		Agency            func(childComplexity int) int
		Alerts            func(childComplexity int, active *bool, limit *int) int
		CensusGeographies func(childComplexity int, layer string, radius *float64, limit *int) int
		ContinuousDropOff func(childComplexity int) int
		ContinuousPickup  func(childComplexity int) int
		FeedOnestopID     func(childComplexity int) int
		FeedVersion       func(childComplexity int) int
		FeedVersionSHA1   func(childComplexity int) int
		Geometries        func(childComplexity int, limit *int) int
		Geometry          func(childComplexity int) int
		Headways          func(childComplexity int, limit *int) int
		ID                func(childComplexity int) int
		OnestopID         func(childComplexity int) int
		Patterns          func(childComplexity int) int
		RouteAttribute    func(childComplexity int) int
		RouteColor        func(childComplexity int) int
		RouteDesc         func(childComplexity int) int
		RouteID           func(childComplexity int) int
		RouteLongName     func(childComplexity int) int
		RouteShortName    func(childComplexity int) int
		RouteSortOrder    func(childComplexity int) int
		RouteStopBuffer   func(childComplexity int, radius *float64) int
		RouteStops        func(childComplexity int, limit *int) int
		RouteTextColor    func(childComplexity int) int
		RouteType         func(childComplexity int) int
		RouteURL          func(childComplexity int) int
		SearchRank        func(childComplexity int) int
		Stops             func(childComplexity int, limit *int, where *model.StopFilter) int
		Trips             func(childComplexity int, limit *int, where *model.TripFilter) int
	}

	RouteAttribute struct {
		Category    func(childComplexity int) int
		RunningWay  func(childComplexity int) int
		Subcategory func(childComplexity int) int
	}

	RouteGeometry struct {
		CombinedGeometry      func(childComplexity int) int
		FirstPointMaxDistance func(childComplexity int) int
		Generated             func(childComplexity int) int
		Geometry              func(childComplexity int) int
		Length                func(childComplexity int) int
		MaxSegmentLength      func(childComplexity int) int
	}

	RouteHeadway struct {
		Departures    func(childComplexity int) int
		DirectionID   func(childComplexity int) int
		DowCategory   func(childComplexity int) int
		HeadwaySecs   func(childComplexity int) int
		ServiceDate   func(childComplexity int) int
		Stop          func(childComplexity int) int
		StopTripCount func(childComplexity int) int
	}

	RouteStop struct {
		Agency   func(childComplexity int) int
		AgencyID func(childComplexity int) int
		ID       func(childComplexity int) int
		Route    func(childComplexity int) int
		RouteID  func(childComplexity int) int
		Stop     func(childComplexity int) int
		StopID   func(childComplexity int) int
	}

	RouteStopBuffer struct {
		StopBuffer     func(childComplexity int) int
		StopConvexhull func(childComplexity int) int
		StopPoints     func(childComplexity int) int
	}

	RouteStopPattern struct {
		Count         func(childComplexity int) int
		DirectionID   func(childComplexity int) int
		StopPatternID func(childComplexity int) int
		Trips         func(childComplexity int, limit *int) int
	}

	Shape struct {
		Generated func(childComplexity int) int
		Geometry  func(childComplexity int) int
		ID        func(childComplexity int) int
		ShapeID   func(childComplexity int) int
	}

	Step struct {
		Distance       func(childComplexity int) int
		Duration       func(childComplexity int) int
		EndTime        func(childComplexity int) int
		GeometryOffset func(childComplexity int) int
		Instruction    func(childComplexity int) int
		Mode           func(childComplexity int) int
		StartTime      func(childComplexity int) int
		To             func(childComplexity int) int
	}

	Stop struct {
		Alerts             func(childComplexity int, active *bool, limit *int) int
		Arrivals           func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		CensusGeographies  func(childComplexity int, layer string, radius *float64, limit *int) int
		Children           func(childComplexity int, limit *int) int
		Departures         func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		Directions         func(childComplexity int, to *model.WaypointInput, from *model.WaypointInput, mode *model.StepMode, departAt *time.Time) int
		ExternalReference  func(childComplexity int) int
		FeedOnestopID      func(childComplexity int) int
		FeedVersion        func(childComplexity int) int
		FeedVersionSHA1    func(childComplexity int) int
		Geometry           func(childComplexity int) int
		ID                 func(childComplexity int) int
		Level              func(childComplexity int) int
		LocationType       func(childComplexity int) int
		NearbyStops        func(childComplexity int, limit *int, radius *float64) int
		Observations       func(childComplexity int, limit *int, where *model.StopObservationFilter) int
		OnestopID          func(childComplexity int) int
		Parent             func(childComplexity int) int
		PathwaysFromStop   func(childComplexity int, limit *int) int
		PathwaysToStop     func(childComplexity int, limit *int) int
		PlatformCode       func(childComplexity int) int
		RouteStops         func(childComplexity int, limit *int) int
		SearchRank         func(childComplexity int) int
		StopCode           func(childComplexity int) int
		StopDesc           func(childComplexity int) int
		StopID             func(childComplexity int) int
		StopName           func(childComplexity int) int
		StopTimes          func(childComplexity int, limit *int, where *model.StopTimeFilter) int
		StopTimezone       func(childComplexity int) int
		StopURL            func(childComplexity int) int
		TtsStopName        func(childComplexity int) int
		WheelchairBoarding func(childComplexity int) int
		ZoneID             func(childComplexity int) int
	}

	StopExternalReference struct {
		ID                  func(childComplexity int) int
		Inactive            func(childComplexity int) int
		TargetActiveStop    func(childComplexity int) int
		TargetFeedOnestopID func(childComplexity int) int
		TargetStopID        func(childComplexity int) int
	}

	StopObservation struct {
		AgencyID               func(childComplexity int) int
		FromStopID             func(childComplexity int) int
		ObservedArrivalTime    func(childComplexity int) int
		ObservedDepartureTime  func(childComplexity int) int
		RouteID                func(childComplexity int) int
		ScheduleRelationship   func(childComplexity int) int
		ScheduledArrivalTime   func(childComplexity int) int
		ScheduledDepartureTime func(childComplexity int) int
		Source                 func(childComplexity int) int
		StopSequence           func(childComplexity int) int
		ToStopID               func(childComplexity int) int
		TripID                 func(childComplexity int) int
		TripStartDate          func(childComplexity int) int
		TripStartTime          func(childComplexity int) int
	}

	StopTime struct {
		Arrival           func(childComplexity int) int
		ArrivalTime       func(childComplexity int) int
		ContinuousDropOff func(childComplexity int) int
		ContinuousPickup  func(childComplexity int) int
		Departure         func(childComplexity int) int
		DepartureTime     func(childComplexity int) int
		DropOffType       func(childComplexity int) int
		Interpolated      func(childComplexity int) int
		PickupType        func(childComplexity int) int
		ServiceDate       func(childComplexity int) int
		ShapeDistTraveled func(childComplexity int) int
		Stop              func(childComplexity int) int
		StopHeadsign      func(childComplexity int) int
		StopSequence      func(childComplexity int) int
		Timepoint         func(childComplexity int) int
		Trip              func(childComplexity int) int
	}

	StopTimeEvent struct {
		Delay        func(childComplexity int) int
		Estimated    func(childComplexity int) int
		EstimatedUtc func(childComplexity int) int
		Scheduled    func(childComplexity int) int
		StopTimezone func(childComplexity int) int
		Uncertainty  func(childComplexity int) int
	}

	Trip struct {
		Alerts               func(childComplexity int, active *bool, limit *int) int
		BikesAllowed         func(childComplexity int) int
		BlockID              func(childComplexity int) int
		Calendar             func(childComplexity int) int
		DirectionID          func(childComplexity int) int
		FeedVersion          func(childComplexity int) int
		Frequencies          func(childComplexity int, limit *int) int
		ID                   func(childComplexity int) int
		Route                func(childComplexity int) int
		ScheduleRelationship func(childComplexity int) int
		Shape                func(childComplexity int) int
		StopPatternID        func(childComplexity int) int
		StopTimes            func(childComplexity int, limit *int, where *model.TripStopTimeFilter) int
		Timestamp            func(childComplexity int) int
		TripHeadsign         func(childComplexity int) int
		TripID               func(childComplexity int) int
		TripShortName        func(childComplexity int) int
		WheelchairAccessible func(childComplexity int) int
	}

	ValidationResult struct {
		Agencies             func(childComplexity int, limit *int) int
		EarliestCalendarDate func(childComplexity int) int
		Errors               func(childComplexity int) int
		FailureReason        func(childComplexity int) int
		FeedInfos            func(childComplexity int, limit *int) int
		Files                func(childComplexity int) int
		LatestCalendarDate   func(childComplexity int) int
		Routes               func(childComplexity int, limit *int) int
		ServiceLevels        func(childComplexity int, limit *int, routeID *string) int
		Sha1                 func(childComplexity int) int
		Stops                func(childComplexity int, limit *int) int
		Success              func(childComplexity int) int
		Warnings             func(childComplexity int) int
	}

	ValidationResultError struct {
		EntityID  func(childComplexity int) int
		ErrorType func(childComplexity int) int
		Field     func(childComplexity int) int
		Filename  func(childComplexity int) int
		Message   func(childComplexity int) int
		Value     func(childComplexity int) int
	}

	ValidationResultErrorGroup struct {
		Count     func(childComplexity int) int
		ErrorType func(childComplexity int) int
		Errors    func(childComplexity int) int
		Filename  func(childComplexity int) int
		Limit     func(childComplexity int) int
	}

	VehiclePosition struct {
		CongestionLevel     func(childComplexity int) int
		CurrentStatus       func(childComplexity int) int
		CurrentStopSequence func(childComplexity int) int
		Position            func(childComplexity int) int
		StopID              func(childComplexity int) int
		Timestamp           func(childComplexity int) int
		Vehicle             func(childComplexity int) int
	}

	Waypoint struct {
		Lat  func(childComplexity int) int
		Lon  func(childComplexity int) int
		Name func(childComplexity int) int
	}
}

type AgencyResolver interface {
	FeedVersion(ctx context.Context, obj *model.Agency) (*model.FeedVersion, error)

	Operator(ctx context.Context, obj *model.Agency) (*model.Operator, error)
	Places(ctx context.Context, obj *model.Agency, limit *int, where *model.AgencyPlaceFilter) ([]*model.AgencyPlace, error)
	Routes(ctx context.Context, obj *model.Agency, limit *int, where *model.RouteFilter) ([]*model.Route, error)
	CensusGeographies(ctx context.Context, obj *model.Agency, layer string, radius *float64, limit *int) ([]*model.CensusGeography, error)
	Alerts(ctx context.Context, obj *model.Agency, active *bool, limit *int) ([]*model.Alert, error)
}
type CalendarResolver interface {
	StartDate(ctx context.Context, obj *model.Calendar) (*tt.Date, error)
	EndDate(ctx context.Context, obj *model.Calendar) (*tt.Date, error)

	AddedDates(ctx context.Context, obj *model.Calendar, limit *int) ([]*tt.Date, error)
	RemovedDates(ctx context.Context, obj *model.Calendar, limit *int) ([]*tt.Date, error)
}
type CensusGeographyResolver interface {
	Values(ctx context.Context, obj *model.CensusGeography, tableNames []string, limit *int) ([]*model.CensusValue, error)
}
type CensusValueResolver interface {
	Table(ctx context.Context, obj *model.CensusValue) (*model.CensusTable, error)
	Values(ctx context.Context, obj *model.CensusValue) (interface{}, error)
}
type FeedResolver interface {
	Spec(ctx context.Context, obj *model.Feed) (*model.FeedSpecTypes, error)
	Languages(ctx context.Context, obj *model.Feed) ([]string, error)

	Authorization(ctx context.Context, obj *model.Feed) (*model.FeedAuthorization, error)
	Urls(ctx context.Context, obj *model.Feed) (*model.FeedUrls, error)
	License(ctx context.Context, obj *model.Feed) (*model.FeedLicense, error)

	AssociatedOperators(ctx context.Context, obj *model.Feed) ([]*model.Operator, error)
	FeedState(ctx context.Context, obj *model.Feed) (*model.FeedState, error)
	FeedFetches(ctx context.Context, obj *model.Feed, limit *int, where *model.FeedFetchFilter) ([]*model.FeedFetch, error)
	FeedVersions(ctx context.Context, obj *model.Feed, limit *int, where *model.FeedVersionFilter) ([]*model.FeedVersion, error)
}
type FeedStateResolver interface {
	FeedVersion(ctx context.Context, obj *model.FeedState) (*model.FeedVersion, error)
}
type FeedVersionResolver interface {
	Geometry(ctx context.Context, obj *model.FeedVersion) (*tt.Polygon, error)
	Feed(ctx context.Context, obj *model.FeedVersion) (*model.Feed, error)
	FeedVersionGtfsImport(ctx context.Context, obj *model.FeedVersion) (*model.FeedVersionGtfsImport, error)
	Files(ctx context.Context, obj *model.FeedVersion, limit *int) ([]*model.FeedVersionFileInfo, error)
	ServiceLevels(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.FeedVersionServiceLevelFilter) ([]*model.FeedVersionServiceLevel, error)
	Agencies(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.AgencyFilter) ([]*model.Agency, error)
	Routes(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.RouteFilter) ([]*model.Route, error)
	Stops(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.StopFilter) ([]*model.Stop, error)
	Trips(ctx context.Context, obj *model.FeedVersion, limit *int, where *model.TripFilter) ([]*model.Trip, error)
	FeedInfos(ctx context.Context, obj *model.FeedVersion, limit *int) ([]*model.FeedInfo, error)
}
type FeedVersionGtfsImportResolver interface {
	SkipEntityErrorCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (interface{}, error)
	EntityCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (interface{}, error)
	WarningCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (interface{}, error)

	SkipEntityReferenceCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (interface{}, error)
	SkipEntityFilterCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (interface{}, error)
	SkipEntityMarkedCount(ctx context.Context, obj *model.FeedVersionGtfsImport) (interface{}, error)
}
type LevelResolver interface {
	Stops(ctx context.Context, obj *model.Level) ([]*model.Stop, error)
}
type MutationResolver interface {
	ValidateGtfs(ctx context.Context, file *graphql.Upload, url *string, realtimeUrls []string) (*model.ValidationResult, error)
	FeedVersionUpdate(ctx context.Context, id int, set model.FeedVersionSetInput) (*model.FeedVersion, error)
	FeedVersionFetch(ctx context.Context, file *graphql.Upload, url *string, feedOnestopID string) (*model.FeedVersionFetchResult, error)
	FeedVersionImport(ctx context.Context, sha1 string) (*model.FeedVersionImportResult, error)
	FeedVersionUnimport(ctx context.Context, id int) (*model.FeedVersionUnimportResult, error)
	FeedVersionDelete(ctx context.Context, id int) (*model.FeedVersionDeleteResult, error)
}
type OperatorResolver interface {
	Agencies(ctx context.Context, obj *model.Operator) ([]*model.Agency, error)
	Feeds(ctx context.Context, obj *model.Operator, limit *int, where *model.FeedFilter) ([]*model.Feed, error)
}
type PathwayResolver interface {
	FromStop(ctx context.Context, obj *model.Pathway) (*model.Stop, error)
	ToStop(ctx context.Context, obj *model.Pathway) (*model.Stop, error)
}
type PlaceResolver interface {
	Count(ctx context.Context, obj *model.Place) (int, error)
	Operators(ctx context.Context, obj *model.Place) ([]*model.Operator, error)
}
type QueryResolver interface {
	FeedVersions(ctx context.Context, limit *int, after *int, ids []int, where *model.FeedVersionFilter) ([]*model.FeedVersion, error)
	Feeds(ctx context.Context, limit *int, after *int, ids []int, where *model.FeedFilter) ([]*model.Feed, error)
	Agencies(ctx context.Context, limit *int, after *int, ids []int, where *model.AgencyFilter) ([]*model.Agency, error)
	Routes(ctx context.Context, limit *int, after *int, ids []int, where *model.RouteFilter) ([]*model.Route, error)
	Stops(ctx context.Context, limit *int, after *int, ids []int, where *model.StopFilter) ([]*model.Stop, error)
	Trips(ctx context.Context, limit *int, after *int, ids []int, where *model.TripFilter) ([]*model.Trip, error)
	Operators(ctx context.Context, limit *int, after *int, ids []int, where *model.OperatorFilter) ([]*model.Operator, error)
	Directions(ctx context.Context, where model.DirectionRequest) (*model.Directions, error)
	Bikes(ctx context.Context, limit *int, where *model.GbfsBikeRequest) ([]*model.GbfsFreeBikeStatus, error)
	Docks(ctx context.Context, limit *int, where *model.GbfsDockRequest) ([]*model.GbfsStationInformation, error)
	Places(ctx context.Context, limit *int, after *int, level *model.PlaceAggregationLevel, where *model.PlaceFilter) ([]*model.Place, error)
}
type RouteResolver interface {
	Geometry(ctx context.Context, obj *model.Route) (*tt.Geometry, error)
	Agency(ctx context.Context, obj *model.Route) (*model.Agency, error)
	FeedVersion(ctx context.Context, obj *model.Route) (*model.FeedVersion, error)

	RouteAttribute(ctx context.Context, obj *model.Route) (*model.RouteAttribute, error)
	Trips(ctx context.Context, obj *model.Route, limit *int, where *model.TripFilter) ([]*model.Trip, error)
	Stops(ctx context.Context, obj *model.Route, limit *int, where *model.StopFilter) ([]*model.Stop, error)
	RouteStops(ctx context.Context, obj *model.Route, limit *int) ([]*model.RouteStop, error)
	Headways(ctx context.Context, obj *model.Route, limit *int) ([]*model.RouteHeadway, error)
	Geometries(ctx context.Context, obj *model.Route, limit *int) ([]*model.RouteGeometry, error)
	CensusGeographies(ctx context.Context, obj *model.Route, layer string, radius *float64, limit *int) ([]*model.CensusGeography, error)
	RouteStopBuffer(ctx context.Context, obj *model.Route, radius *float64) (*model.RouteStopBuffer, error)
	Patterns(ctx context.Context, obj *model.Route) ([]*model.RouteStopPattern, error)
	Alerts(ctx context.Context, obj *model.Route, active *bool, limit *int) ([]*model.Alert, error)
}
type RouteHeadwayResolver interface {
	Stop(ctx context.Context, obj *model.RouteHeadway) (*model.Stop, error)

	Departures(ctx context.Context, obj *model.RouteHeadway) ([]*tt.WideTime, error)
}
type RouteStopResolver interface {
	Route(ctx context.Context, obj *model.RouteStop) (*model.Route, error)
	Stop(ctx context.Context, obj *model.RouteStop) (*model.Stop, error)
	Agency(ctx context.Context, obj *model.RouteStop) (*model.Agency, error)
}
type RouteStopPatternResolver interface {
	Trips(ctx context.Context, obj *model.RouteStopPattern, limit *int) ([]*model.Trip, error)
}
type StopResolver interface {
	FeedVersion(ctx context.Context, obj *model.Stop) (*model.FeedVersion, error)
	Level(ctx context.Context, obj *model.Stop) (*model.Level, error)
	Parent(ctx context.Context, obj *model.Stop) (*model.Stop, error)
	ExternalReference(ctx context.Context, obj *model.Stop) (*model.StopExternalReference, error)
	Observations(ctx context.Context, obj *model.Stop, limit *int, where *model.StopObservationFilter) ([]*model.StopObservation, error)
	Children(ctx context.Context, obj *model.Stop, limit *int) ([]*model.Stop, error)
	RouteStops(ctx context.Context, obj *model.Stop, limit *int) ([]*model.RouteStop, error)
	PathwaysFromStop(ctx context.Context, obj *model.Stop, limit *int) ([]*model.Pathway, error)
	PathwaysToStop(ctx context.Context, obj *model.Stop, limit *int) ([]*model.Pathway, error)
	StopTimes(ctx context.Context, obj *model.Stop, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)
	Departures(ctx context.Context, obj *model.Stop, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)
	Arrivals(ctx context.Context, obj *model.Stop, limit *int, where *model.StopTimeFilter) ([]*model.StopTime, error)

	CensusGeographies(ctx context.Context, obj *model.Stop, layer string, radius *float64, limit *int) ([]*model.CensusGeography, error)
	Directions(ctx context.Context, obj *model.Stop, to *model.WaypointInput, from *model.WaypointInput, mode *model.StepMode, departAt *time.Time) (*model.Directions, error)
	NearbyStops(ctx context.Context, obj *model.Stop, limit *int, radius *float64) ([]*model.Stop, error)
	Alerts(ctx context.Context, obj *model.Stop, active *bool, limit *int) ([]*model.Alert, error)
}
type StopExternalReferenceResolver interface {
	TargetActiveStop(ctx context.Context, obj *model.StopExternalReference) (*model.Stop, error)
}
type StopTimeResolver interface {
	Stop(ctx context.Context, obj *model.StopTime) (*model.Stop, error)
	Trip(ctx context.Context, obj *model.StopTime) (*model.Trip, error)
	Arrival(ctx context.Context, obj *model.StopTime) (*model.StopTimeEvent, error)
	Departure(ctx context.Context, obj *model.StopTime) (*model.StopTimeEvent, error)
}
type TripResolver interface {
	Calendar(ctx context.Context, obj *model.Trip) (*model.Calendar, error)
	Route(ctx context.Context, obj *model.Trip) (*model.Route, error)
	Shape(ctx context.Context, obj *model.Trip) (*model.Shape, error)
	FeedVersion(ctx context.Context, obj *model.Trip) (*model.FeedVersion, error)
	StopTimes(ctx context.Context, obj *model.Trip, limit *int, where *model.TripStopTimeFilter) ([]*model.StopTime, error)
	Frequencies(ctx context.Context, obj *model.Trip, limit *int) ([]*model.Frequency, error)
	ScheduleRelationship(ctx context.Context, obj *model.Trip) (*model.ScheduleRelationship, error)
	Timestamp(ctx context.Context, obj *model.Trip) (*time.Time, error)
	Alerts(ctx context.Context, obj *model.Trip, active *bool, limit *int) ([]*model.Alert, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "Agency.agency_email":
		if e.complexity.Agency.AgencyEmail == nil {
			break
		}

		return e.complexity.Agency.AgencyEmail(childComplexity), true

	case "Agency.agency_fare_url":
		if e.complexity.Agency.AgencyFareURL == nil {
			break
		}

		return e.complexity.Agency.AgencyFareURL(childComplexity), true

	case "Agency.agency_id":
		if e.complexity.Agency.AgencyID == nil {
			break
		}

		return e.complexity.Agency.AgencyID(childComplexity), true

	case "Agency.agency_lang":
		if e.complexity.Agency.AgencyLang == nil {
			break
		}

		return e.complexity.Agency.AgencyLang(childComplexity), true

	case "Agency.agency_name":
		if e.complexity.Agency.AgencyName == nil {
			break
		}

		return e.complexity.Agency.AgencyName(childComplexity), true

	case "Agency.agency_phone":
		if e.complexity.Agency.AgencyPhone == nil {
			break
		}

		return e.complexity.Agency.AgencyPhone(childComplexity), true

	case "Agency.agency_timezone":
		if e.complexity.Agency.AgencyTimezone == nil {
			break
		}

		return e.complexity.Agency.AgencyTimezone(childComplexity), true

	case "Agency.agency_url":
		if e.complexity.Agency.AgencyURL == nil {
			break
		}

		return e.complexity.Agency.AgencyURL(childComplexity), true

	case "Agency.alerts":
		if e.complexity.Agency.Alerts == nil {
			break
		}

		args, err := ec.field_Agency_alerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Agency.census_geographies":
		if e.complexity.Agency.CensusGeographies == nil {
			break
		}

		args, err := ec.field_Agency_census_geographies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.CensusGeographies(childComplexity, args["layer"].(string), args["radius"].(*float64), args["limit"].(*int)), true

	case "Agency.feed_onestop_id":
		if e.complexity.Agency.FeedOnestopID == nil {
			break
		}

		return e.complexity.Agency.FeedOnestopID(childComplexity), true

	case "Agency.feed_version":
		if e.complexity.Agency.FeedVersion == nil {
			break
		}

		return e.complexity.Agency.FeedVersion(childComplexity), true

	case "Agency.feed_version_sha1":
		if e.complexity.Agency.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.Agency.FeedVersionSHA1(childComplexity), true

	case "Agency.geometry":
		if e.complexity.Agency.Geometry == nil {
			break
		}

		return e.complexity.Agency.Geometry(childComplexity), true

	case "Agency.id":
		if e.complexity.Agency.ID == nil {
			break
		}

		return e.complexity.Agency.ID(childComplexity), true

	case "Agency.onestop_id":
		if e.complexity.Agency.OnestopID == nil {
			break
		}

		return e.complexity.Agency.OnestopID(childComplexity), true

	case "Agency.operator":
		if e.complexity.Agency.Operator == nil {
			break
		}

		return e.complexity.Agency.Operator(childComplexity), true

	case "Agency.places":
		if e.complexity.Agency.Places == nil {
			break
		}

		args, err := ec.field_Agency_places_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.Places(childComplexity, args["limit"].(*int), args["where"].(*model.AgencyPlaceFilter)), true

	case "Agency.routes":
		if e.complexity.Agency.Routes == nil {
			break
		}

		args, err := ec.field_Agency_routes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Agency.Routes(childComplexity, args["limit"].(*int), args["where"].(*model.RouteFilter)), true

	case "Agency.search_rank":
		if e.complexity.Agency.SearchRank == nil {
			break
		}

		return e.complexity.Agency.SearchRank(childComplexity), true

	case "AgencyPlace.adm0_name":
		if e.complexity.AgencyPlace.Adm0Name == nil {
			break
		}

		return e.complexity.AgencyPlace.Adm0Name(childComplexity), true

	case "AgencyPlace.adm1_name":
		if e.complexity.AgencyPlace.Adm1Name == nil {
			break
		}

		return e.complexity.AgencyPlace.Adm1Name(childComplexity), true

	case "AgencyPlace.city_name":
		if e.complexity.AgencyPlace.CityName == nil {
			break
		}

		return e.complexity.AgencyPlace.CityName(childComplexity), true

	case "AgencyPlace.rank":
		if e.complexity.AgencyPlace.Rank == nil {
			break
		}

		return e.complexity.AgencyPlace.Rank(childComplexity), true

	case "Alert.active_period":
		if e.complexity.Alert.ActivePeriod == nil {
			break
		}

		return e.complexity.Alert.ActivePeriod(childComplexity), true

	case "Alert.cause":
		if e.complexity.Alert.Cause == nil {
			break
		}

		return e.complexity.Alert.Cause(childComplexity), true

	case "Alert.description_text":
		if e.complexity.Alert.DescriptionText == nil {
			break
		}

		return e.complexity.Alert.DescriptionText(childComplexity), true

	case "Alert.effect":
		if e.complexity.Alert.Effect == nil {
			break
		}

		return e.complexity.Alert.Effect(childComplexity), true

	case "Alert.header_text":
		if e.complexity.Alert.HeaderText == nil {
			break
		}

		return e.complexity.Alert.HeaderText(childComplexity), true

	case "Alert.severity_level":
		if e.complexity.Alert.SeverityLevel == nil {
			break
		}

		return e.complexity.Alert.SeverityLevel(childComplexity), true

	case "Alert.tts_description_text":
		if e.complexity.Alert.TtsDescriptionText == nil {
			break
		}

		return e.complexity.Alert.TtsDescriptionText(childComplexity), true

	case "Alert.tts_header_text":
		if e.complexity.Alert.TtsHeaderText == nil {
			break
		}

		return e.complexity.Alert.TtsHeaderText(childComplexity), true

	case "Alert.url":
		if e.complexity.Alert.URL == nil {
			break
		}

		return e.complexity.Alert.URL(childComplexity), true

	case "Calendar.added_dates":
		if e.complexity.Calendar.AddedDates == nil {
			break
		}

		args, err := ec.field_Calendar_added_dates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Calendar.AddedDates(childComplexity, args["limit"].(*int)), true

	case "Calendar.end_date":
		if e.complexity.Calendar.EndDate == nil {
			break
		}

		return e.complexity.Calendar.EndDate(childComplexity), true

	case "Calendar.friday":
		if e.complexity.Calendar.Friday == nil {
			break
		}

		return e.complexity.Calendar.Friday(childComplexity), true

	case "Calendar.id":
		if e.complexity.Calendar.ID == nil {
			break
		}

		return e.complexity.Calendar.ID(childComplexity), true

	case "Calendar.monday":
		if e.complexity.Calendar.Monday == nil {
			break
		}

		return e.complexity.Calendar.Monday(childComplexity), true

	case "Calendar.removed_dates":
		if e.complexity.Calendar.RemovedDates == nil {
			break
		}

		args, err := ec.field_Calendar_removed_dates_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Calendar.RemovedDates(childComplexity, args["limit"].(*int)), true

	case "Calendar.saturday":
		if e.complexity.Calendar.Saturday == nil {
			break
		}

		return e.complexity.Calendar.Saturday(childComplexity), true

	case "Calendar.service_id":
		if e.complexity.Calendar.ServiceID == nil {
			break
		}

		return e.complexity.Calendar.ServiceID(childComplexity), true

	case "Calendar.start_date":
		if e.complexity.Calendar.StartDate == nil {
			break
		}

		return e.complexity.Calendar.StartDate(childComplexity), true

	case "Calendar.sunday":
		if e.complexity.Calendar.Sunday == nil {
			break
		}

		return e.complexity.Calendar.Sunday(childComplexity), true

	case "Calendar.thursday":
		if e.complexity.Calendar.Thursday == nil {
			break
		}

		return e.complexity.Calendar.Thursday(childComplexity), true

	case "Calendar.tuesday":
		if e.complexity.Calendar.Tuesday == nil {
			break
		}

		return e.complexity.Calendar.Tuesday(childComplexity), true

	case "Calendar.wednesday":
		if e.complexity.Calendar.Wednesday == nil {
			break
		}

		return e.complexity.Calendar.Wednesday(childComplexity), true

	case "CensusGeography.aland":
		if e.complexity.CensusGeography.Aland == nil {
			break
		}

		return e.complexity.CensusGeography.Aland(childComplexity), true

	case "CensusGeography.awater":
		if e.complexity.CensusGeography.Awater == nil {
			break
		}

		return e.complexity.CensusGeography.Awater(childComplexity), true

	case "CensusGeography.geoid":
		if e.complexity.CensusGeography.Geoid == nil {
			break
		}

		return e.complexity.CensusGeography.Geoid(childComplexity), true

	case "CensusGeography.geometry":
		if e.complexity.CensusGeography.Geometry == nil {
			break
		}

		return e.complexity.CensusGeography.Geometry(childComplexity), true

	case "CensusGeography.id":
		if e.complexity.CensusGeography.ID == nil {
			break
		}

		return e.complexity.CensusGeography.ID(childComplexity), true

	case "CensusGeography.layer_name":
		if e.complexity.CensusGeography.LayerName == nil {
			break
		}

		return e.complexity.CensusGeography.LayerName(childComplexity), true

	case "CensusGeography.name":
		if e.complexity.CensusGeography.Name == nil {
			break
		}

		return e.complexity.CensusGeography.Name(childComplexity), true

	case "CensusGeography.values":
		if e.complexity.CensusGeography.Values == nil {
			break
		}

		args, err := ec.field_CensusGeography_values_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.CensusGeography.Values(childComplexity, args["table_names"].([]string), args["limit"].(*int)), true

	case "CensusTable.id":
		if e.complexity.CensusTable.ID == nil {
			break
		}

		return e.complexity.CensusTable.ID(childComplexity), true

	case "CensusTable.table_group":
		if e.complexity.CensusTable.TableGroup == nil {
			break
		}

		return e.complexity.CensusTable.TableGroup(childComplexity), true

	case "CensusTable.table_name":
		if e.complexity.CensusTable.TableName == nil {
			break
		}

		return e.complexity.CensusTable.TableName(childComplexity), true

	case "CensusTable.table_title":
		if e.complexity.CensusTable.TableTitle == nil {
			break
		}

		return e.complexity.CensusTable.TableTitle(childComplexity), true

	case "CensusValue.table":
		if e.complexity.CensusValue.Table == nil {
			break
		}

		return e.complexity.CensusValue.Table(childComplexity), true

	case "CensusValue.values":
		if e.complexity.CensusValue.Values == nil {
			break
		}

		return e.complexity.CensusValue.Values(childComplexity), true

	case "Directions.data_source":
		if e.complexity.Directions.DataSource == nil {
			break
		}

		return e.complexity.Directions.DataSource(childComplexity), true

	case "Directions.destination":
		if e.complexity.Directions.Destination == nil {
			break
		}

		return e.complexity.Directions.Destination(childComplexity), true

	case "Directions.distance":
		if e.complexity.Directions.Distance == nil {
			break
		}

		return e.complexity.Directions.Distance(childComplexity), true

	case "Directions.duration":
		if e.complexity.Directions.Duration == nil {
			break
		}

		return e.complexity.Directions.Duration(childComplexity), true

	case "Directions.end_time":
		if e.complexity.Directions.EndTime == nil {
			break
		}

		return e.complexity.Directions.EndTime(childComplexity), true

	case "Directions.exception":
		if e.complexity.Directions.Exception == nil {
			break
		}

		return e.complexity.Directions.Exception(childComplexity), true

	case "Directions.itineraries":
		if e.complexity.Directions.Itineraries == nil {
			break
		}

		return e.complexity.Directions.Itineraries(childComplexity), true

	case "Directions.origin":
		if e.complexity.Directions.Origin == nil {
			break
		}

		return e.complexity.Directions.Origin(childComplexity), true

	case "Directions.start_time":
		if e.complexity.Directions.StartTime == nil {
			break
		}

		return e.complexity.Directions.StartTime(childComplexity), true

	case "Directions.success":
		if e.complexity.Directions.Success == nil {
			break
		}

		return e.complexity.Directions.Success(childComplexity), true

	case "Distance.distance":
		if e.complexity.Distance.Distance == nil {
			break
		}

		return e.complexity.Distance.Distance(childComplexity), true

	case "Distance.units":
		if e.complexity.Distance.Units == nil {
			break
		}

		return e.complexity.Distance.Units(childComplexity), true

	case "Duration.duration":
		if e.complexity.Duration.Duration == nil {
			break
		}

		return e.complexity.Duration.Duration(childComplexity), true

	case "Duration.units":
		if e.complexity.Duration.Units == nil {
			break
		}

		return e.complexity.Duration.Units(childComplexity), true

	case "Feed.associated_operators":
		if e.complexity.Feed.AssociatedOperators == nil {
			break
		}

		return e.complexity.Feed.AssociatedOperators(childComplexity), true

	case "Feed.authorization":
		if e.complexity.Feed.Authorization == nil {
			break
		}

		return e.complexity.Feed.Authorization(childComplexity), true

	case "Feed.feed_fetches":
		if e.complexity.Feed.FeedFetches == nil {
			break
		}

		args, err := ec.field_Feed_feed_fetches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Feed.FeedFetches(childComplexity, args["limit"].(*int), args["where"].(*model.FeedFetchFilter)), true

	case "Feed.feed_state":
		if e.complexity.Feed.FeedState == nil {
			break
		}

		return e.complexity.Feed.FeedState(childComplexity), true

	case "Feed.feed_versions":
		if e.complexity.Feed.FeedVersions == nil {
			break
		}

		args, err := ec.field_Feed_feed_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Feed.FeedVersions(childComplexity, args["limit"].(*int), args["where"].(*model.FeedVersionFilter)), true

	case "Feed.file":
		if e.complexity.Feed.File == nil {
			break
		}

		return e.complexity.Feed.File(childComplexity), true

	case "Feed.id":
		if e.complexity.Feed.ID == nil {
			break
		}

		return e.complexity.Feed.ID(childComplexity), true

	case "Feed.languages":
		if e.complexity.Feed.Languages == nil {
			break
		}

		return e.complexity.Feed.Languages(childComplexity), true

	case "Feed.license":
		if e.complexity.Feed.License == nil {
			break
		}

		return e.complexity.Feed.License(childComplexity), true

	case "Feed.name":
		if e.complexity.Feed.Name == nil {
			break
		}

		return e.complexity.Feed.Name(childComplexity), true

	case "Feed.onestop_id":
		if e.complexity.Feed.OnestopID == nil {
			break
		}

		return e.complexity.Feed.OnestopID(childComplexity), true

	case "Feed.search_rank":
		if e.complexity.Feed.SearchRank == nil {
			break
		}

		return e.complexity.Feed.SearchRank(childComplexity), true

	case "Feed.spec":
		if e.complexity.Feed.Spec == nil {
			break
		}

		return e.complexity.Feed.Spec(childComplexity), true

	case "Feed.tags":
		if e.complexity.Feed.Tags == nil {
			break
		}

		return e.complexity.Feed.Tags(childComplexity), true

	case "Feed.urls":
		if e.complexity.Feed.Urls == nil {
			break
		}

		return e.complexity.Feed.Urls(childComplexity), true

	case "FeedAuthorization.info_url":
		if e.complexity.FeedAuthorization.InfoURL == nil {
			break
		}

		return e.complexity.FeedAuthorization.InfoURL(childComplexity), true

	case "FeedAuthorization.param_name":
		if e.complexity.FeedAuthorization.ParamName == nil {
			break
		}

		return e.complexity.FeedAuthorization.ParamName(childComplexity), true

	case "FeedAuthorization.type":
		if e.complexity.FeedAuthorization.Type == nil {
			break
		}

		return e.complexity.FeedAuthorization.Type(childComplexity), true

	case "FeedFetch.fetch_error":
		if e.complexity.FeedFetch.FetchError == nil {
			break
		}

		return e.complexity.FeedFetch.FetchError(childComplexity), true

	case "FeedFetch.fetched_at":
		if e.complexity.FeedFetch.FetchedAt == nil {
			break
		}

		return e.complexity.FeedFetch.FetchedAt(childComplexity), true

	case "FeedFetch.id":
		if e.complexity.FeedFetch.ID == nil {
			break
		}

		return e.complexity.FeedFetch.ID(childComplexity), true

	case "FeedFetch.response_code":
		if e.complexity.FeedFetch.ResponseCode == nil {
			break
		}

		return e.complexity.FeedFetch.ResponseCode(childComplexity), true

	case "FeedFetch.response_sha1":
		if e.complexity.FeedFetch.ResponseSha1 == nil {
			break
		}

		return e.complexity.FeedFetch.ResponseSha1(childComplexity), true

	case "FeedFetch.response_size":
		if e.complexity.FeedFetch.ResponseSize == nil {
			break
		}

		return e.complexity.FeedFetch.ResponseSize(childComplexity), true

	case "FeedFetch.success":
		if e.complexity.FeedFetch.Success == nil {
			break
		}

		return e.complexity.FeedFetch.Success(childComplexity), true

	case "FeedFetch.url":
		if e.complexity.FeedFetch.URL == nil {
			break
		}

		return e.complexity.FeedFetch.URL(childComplexity), true

	case "FeedFetch.url_type":
		if e.complexity.FeedFetch.URLType == nil {
			break
		}

		return e.complexity.FeedFetch.URLType(childComplexity), true

	case "FeedInfo.default_lang":
		if e.complexity.FeedInfo.DefaultLang == nil {
			break
		}

		return e.complexity.FeedInfo.DefaultLang(childComplexity), true

	case "FeedInfo.feed_contact_email":
		if e.complexity.FeedInfo.FeedContactEmail == nil {
			break
		}

		return e.complexity.FeedInfo.FeedContactEmail(childComplexity), true

	case "FeedInfo.feed_contact_url":
		if e.complexity.FeedInfo.FeedContactURL == nil {
			break
		}

		return e.complexity.FeedInfo.FeedContactURL(childComplexity), true

	case "FeedInfo.feed_end_date":
		if e.complexity.FeedInfo.FeedEndDate == nil {
			break
		}

		return e.complexity.FeedInfo.FeedEndDate(childComplexity), true

	case "FeedInfo.feed_lang":
		if e.complexity.FeedInfo.FeedLang == nil {
			break
		}

		return e.complexity.FeedInfo.FeedLang(childComplexity), true

	case "FeedInfo.feed_publisher_name":
		if e.complexity.FeedInfo.FeedPublisherName == nil {
			break
		}

		return e.complexity.FeedInfo.FeedPublisherName(childComplexity), true

	case "FeedInfo.feed_publisher_url":
		if e.complexity.FeedInfo.FeedPublisherURL == nil {
			break
		}

		return e.complexity.FeedInfo.FeedPublisherURL(childComplexity), true

	case "FeedInfo.feed_start_date":
		if e.complexity.FeedInfo.FeedStartDate == nil {
			break
		}

		return e.complexity.FeedInfo.FeedStartDate(childComplexity), true

	case "FeedInfo.feed_version":
		if e.complexity.FeedInfo.FeedVersion == nil {
			break
		}

		return e.complexity.FeedInfo.FeedVersion(childComplexity), true

	case "FeedInfo.id":
		if e.complexity.FeedInfo.ID == nil {
			break
		}

		return e.complexity.FeedInfo.ID(childComplexity), true

	case "FeedLicense.attribution_instructions":
		if e.complexity.FeedLicense.AttributionInstructions == nil {
			break
		}

		return e.complexity.FeedLicense.AttributionInstructions(childComplexity), true

	case "FeedLicense.attribution_text":
		if e.complexity.FeedLicense.AttributionText == nil {
			break
		}

		return e.complexity.FeedLicense.AttributionText(childComplexity), true

	case "FeedLicense.commercial_use_allowed":
		if e.complexity.FeedLicense.CommercialUseAllowed == nil {
			break
		}

		return e.complexity.FeedLicense.CommercialUseAllowed(childComplexity), true

	case "FeedLicense.create_derived_product":
		if e.complexity.FeedLicense.CreateDerivedProduct == nil {
			break
		}

		return e.complexity.FeedLicense.CreateDerivedProduct(childComplexity), true

	case "FeedLicense.redistribution_allowed":
		if e.complexity.FeedLicense.RedistributionAllowed == nil {
			break
		}

		return e.complexity.FeedLicense.RedistributionAllowed(childComplexity), true

	case "FeedLicense.share_alike_optional":
		if e.complexity.FeedLicense.ShareAlikeOptional == nil {
			break
		}

		return e.complexity.FeedLicense.ShareAlikeOptional(childComplexity), true

	case "FeedLicense.spdx_identifier":
		if e.complexity.FeedLicense.SpdxIdentifier == nil {
			break
		}

		return e.complexity.FeedLicense.SpdxIdentifier(childComplexity), true

	case "FeedLicense.url":
		if e.complexity.FeedLicense.URL == nil {
			break
		}

		return e.complexity.FeedLicense.URL(childComplexity), true

	case "FeedLicense.use_without_attribution":
		if e.complexity.FeedLicense.UseWithoutAttribution == nil {
			break
		}

		return e.complexity.FeedLicense.UseWithoutAttribution(childComplexity), true

	case "FeedState.feed_version":
		if e.complexity.FeedState.FeedVersion == nil {
			break
		}

		return e.complexity.FeedState.FeedVersion(childComplexity), true

	case "FeedState.id":
		if e.complexity.FeedState.ID == nil {
			break
		}

		return e.complexity.FeedState.ID(childComplexity), true

	case "FeedUrls.gbfs_auto_discovery":
		if e.complexity.FeedUrls.GbfsAutoDiscovery == nil {
			break
		}

		return e.complexity.FeedUrls.GbfsAutoDiscovery(childComplexity), true

	case "FeedUrls.mds_provider":
		if e.complexity.FeedUrls.MdsProvider == nil {
			break
		}

		return e.complexity.FeedUrls.MdsProvider(childComplexity), true

	case "FeedUrls.realtime_alerts":
		if e.complexity.FeedUrls.RealtimeAlerts == nil {
			break
		}

		return e.complexity.FeedUrls.RealtimeAlerts(childComplexity), true

	case "FeedUrls.realtime_trip_updates":
		if e.complexity.FeedUrls.RealtimeTripUpdates == nil {
			break
		}

		return e.complexity.FeedUrls.RealtimeTripUpdates(childComplexity), true

	case "FeedUrls.realtime_vehicle_positions":
		if e.complexity.FeedUrls.RealtimeVehiclePositions == nil {
			break
		}

		return e.complexity.FeedUrls.RealtimeVehiclePositions(childComplexity), true

	case "FeedUrls.static_current":
		if e.complexity.FeedUrls.StaticCurrent == nil {
			break
		}

		return e.complexity.FeedUrls.StaticCurrent(childComplexity), true

	case "FeedUrls.static_historic":
		if e.complexity.FeedUrls.StaticHistoric == nil {
			break
		}

		return e.complexity.FeedUrls.StaticHistoric(childComplexity), true

	case "FeedUrls.static_planned":
		if e.complexity.FeedUrls.StaticPlanned == nil {
			break
		}

		return e.complexity.FeedUrls.StaticPlanned(childComplexity), true

	case "FeedVersion.agencies":
		if e.complexity.FeedVersion.Agencies == nil {
			break
		}

		args, err := ec.field_FeedVersion_agencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Agencies(childComplexity, args["limit"].(*int), args["where"].(*model.AgencyFilter)), true

	case "FeedVersion.created_by":
		if e.complexity.FeedVersion.CreatedBy == nil {
			break
		}

		return e.complexity.FeedVersion.CreatedBy(childComplexity), true

	case "FeedVersion.description":
		if e.complexity.FeedVersion.Description == nil {
			break
		}

		return e.complexity.FeedVersion.Description(childComplexity), true

	case "FeedVersion.earliest_calendar_date":
		if e.complexity.FeedVersion.EarliestCalendarDate == nil {
			break
		}

		return e.complexity.FeedVersion.EarliestCalendarDate(childComplexity), true

	case "FeedVersion.feed":
		if e.complexity.FeedVersion.Feed == nil {
			break
		}

		return e.complexity.FeedVersion.Feed(childComplexity), true

	case "FeedVersion.feed_infos":
		if e.complexity.FeedVersion.FeedInfos == nil {
			break
		}

		args, err := ec.field_FeedVersion_feed_infos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.FeedInfos(childComplexity, args["limit"].(*int)), true

	case "FeedVersion.feed_version_gtfs_import":
		if e.complexity.FeedVersion.FeedVersionGtfsImport == nil {
			break
		}

		return e.complexity.FeedVersion.FeedVersionGtfsImport(childComplexity), true

	case "FeedVersion.fetched_at":
		if e.complexity.FeedVersion.FetchedAt == nil {
			break
		}

		return e.complexity.FeedVersion.FetchedAt(childComplexity), true

	case "FeedVersion.file":
		if e.complexity.FeedVersion.File == nil {
			break
		}

		return e.complexity.FeedVersion.File(childComplexity), true

	case "FeedVersion.files":
		if e.complexity.FeedVersion.Files == nil {
			break
		}

		args, err := ec.field_FeedVersion_files_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Files(childComplexity, args["limit"].(*int)), true

	case "FeedVersion.geometry":
		if e.complexity.FeedVersion.Geometry == nil {
			break
		}

		return e.complexity.FeedVersion.Geometry(childComplexity), true

	case "FeedVersion.id":
		if e.complexity.FeedVersion.ID == nil {
			break
		}

		return e.complexity.FeedVersion.ID(childComplexity), true

	case "FeedVersion.latest_calendar_date":
		if e.complexity.FeedVersion.LatestCalendarDate == nil {
			break
		}

		return e.complexity.FeedVersion.LatestCalendarDate(childComplexity), true

	case "FeedVersion.name":
		if e.complexity.FeedVersion.Name == nil {
			break
		}

		return e.complexity.FeedVersion.Name(childComplexity), true

	case "FeedVersion.routes":
		if e.complexity.FeedVersion.Routes == nil {
			break
		}

		args, err := ec.field_FeedVersion_routes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Routes(childComplexity, args["limit"].(*int), args["where"].(*model.RouteFilter)), true

	case "FeedVersion.sha1":
		if e.complexity.FeedVersion.SHA1 == nil {
			break
		}

		return e.complexity.FeedVersion.SHA1(childComplexity), true

	case "FeedVersion.service_levels":
		if e.complexity.FeedVersion.ServiceLevels == nil {
			break
		}

		args, err := ec.field_FeedVersion_service_levels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.ServiceLevels(childComplexity, args["limit"].(*int), args["where"].(*model.FeedVersionServiceLevelFilter)), true

	case "FeedVersion.stops":
		if e.complexity.FeedVersion.Stops == nil {
			break
		}

		args, err := ec.field_FeedVersion_stops_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Stops(childComplexity, args["limit"].(*int), args["where"].(*model.StopFilter)), true

	case "FeedVersion.trips":
		if e.complexity.FeedVersion.Trips == nil {
			break
		}

		args, err := ec.field_FeedVersion_trips_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.FeedVersion.Trips(childComplexity, args["limit"].(*int), args["where"].(*model.TripFilter)), true

	case "FeedVersion.url":
		if e.complexity.FeedVersion.URL == nil {
			break
		}

		return e.complexity.FeedVersion.URL(childComplexity), true

	case "FeedVersion.updated_by":
		if e.complexity.FeedVersion.UpdatedBy == nil {
			break
		}

		return e.complexity.FeedVersion.UpdatedBy(childComplexity), true

	case "FeedVersionDeleteResult.success":
		if e.complexity.FeedVersionDeleteResult.Success == nil {
			break
		}

		return e.complexity.FeedVersionDeleteResult.Success(childComplexity), true

	case "FeedVersionFetchResult.feed_version":
		if e.complexity.FeedVersionFetchResult.FeedVersion == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FeedVersion(childComplexity), true

	case "FeedVersionFetchResult.fetch_error":
		if e.complexity.FeedVersionFetchResult.FetchError == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FetchError(childComplexity), true

	case "FeedVersionFetchResult.found_dir_sha1":
		if e.complexity.FeedVersionFetchResult.FoundDirSHA1 == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FoundDirSHA1(childComplexity), true

	case "FeedVersionFetchResult.found_sha1":
		if e.complexity.FeedVersionFetchResult.FoundSHA1 == nil {
			break
		}

		return e.complexity.FeedVersionFetchResult.FoundSHA1(childComplexity), true

	case "FeedVersionFileInfo.csv_like":
		if e.complexity.FeedVersionFileInfo.CSVLike == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.CSVLike(childComplexity), true

	case "FeedVersionFileInfo.header":
		if e.complexity.FeedVersionFileInfo.Header == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Header(childComplexity), true

	case "FeedVersionFileInfo.id":
		if e.complexity.FeedVersionFileInfo.ID == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.ID(childComplexity), true

	case "FeedVersionFileInfo.name":
		if e.complexity.FeedVersionFileInfo.Name == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Name(childComplexity), true

	case "FeedVersionFileInfo.rows":
		if e.complexity.FeedVersionFileInfo.Rows == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Rows(childComplexity), true

	case "FeedVersionFileInfo.sha1":
		if e.complexity.FeedVersionFileInfo.SHA1 == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.SHA1(childComplexity), true

	case "FeedVersionFileInfo.size":
		if e.complexity.FeedVersionFileInfo.Size == nil {
			break
		}

		return e.complexity.FeedVersionFileInfo.Size(childComplexity), true

	case "FeedVersionGtfsImport.created_at":
		if e.complexity.FeedVersionGtfsImport.CreatedAt == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.CreatedAt(childComplexity), true

	case "FeedVersionGtfsImport.entity_count":
		if e.complexity.FeedVersionGtfsImport.EntityCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.EntityCount(childComplexity), true

	case "FeedVersionGtfsImport.exception_log":
		if e.complexity.FeedVersionGtfsImport.ExceptionLog == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.ExceptionLog(childComplexity), true

	case "FeedVersionGtfsImport.id":
		if e.complexity.FeedVersionGtfsImport.ID == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.ID(childComplexity), true

	case "FeedVersionGtfsImport.in_progress":
		if e.complexity.FeedVersionGtfsImport.InProgress == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.InProgress(childComplexity), true

	case "FeedVersionGtfsImport.interpolated_stop_time_count":
		if e.complexity.FeedVersionGtfsImport.InterpolatedStopTimeCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.InterpolatedStopTimeCount(childComplexity), true

	case "FeedVersionGtfsImport.schedule_removed":
		if e.complexity.FeedVersionGtfsImport.ScheduleRemoved == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.ScheduleRemoved(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_error_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityErrorCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityErrorCount(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_filter_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityFilterCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityFilterCount(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_marked_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityMarkedCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityMarkedCount(childComplexity), true

	case "FeedVersionGtfsImport.skip_entity_reference_count":
		if e.complexity.FeedVersionGtfsImport.SkipEntityReferenceCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.SkipEntityReferenceCount(childComplexity), true

	case "FeedVersionGtfsImport.success":
		if e.complexity.FeedVersionGtfsImport.Success == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.Success(childComplexity), true

	case "FeedVersionGtfsImport.updated_at":
		if e.complexity.FeedVersionGtfsImport.UpdatedAt == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.UpdatedAt(childComplexity), true

	case "FeedVersionGtfsImport.warning_count":
		if e.complexity.FeedVersionGtfsImport.WarningCount == nil {
			break
		}

		return e.complexity.FeedVersionGtfsImport.WarningCount(childComplexity), true

	case "FeedVersionImportResult.success":
		if e.complexity.FeedVersionImportResult.Success == nil {
			break
		}

		return e.complexity.FeedVersionImportResult.Success(childComplexity), true

	case "FeedVersionServiceLevel.end_date":
		if e.complexity.FeedVersionServiceLevel.EndDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.EndDate(childComplexity), true

	case "FeedVersionServiceLevel.friday":
		if e.complexity.FeedVersionServiceLevel.Friday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Friday(childComplexity), true

	case "FeedVersionServiceLevel.id":
		if e.complexity.FeedVersionServiceLevel.ID == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.ID(childComplexity), true

	case "FeedVersionServiceLevel.monday":
		if e.complexity.FeedVersionServiceLevel.Monday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Monday(childComplexity), true

	case "FeedVersionServiceLevel.saturday":
		if e.complexity.FeedVersionServiceLevel.Saturday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Saturday(childComplexity), true

	case "FeedVersionServiceLevel.start_date":
		if e.complexity.FeedVersionServiceLevel.StartDate == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.StartDate(childComplexity), true

	case "FeedVersionServiceLevel.sunday":
		if e.complexity.FeedVersionServiceLevel.Sunday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Sunday(childComplexity), true

	case "FeedVersionServiceLevel.thursday":
		if e.complexity.FeedVersionServiceLevel.Thursday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Thursday(childComplexity), true

	case "FeedVersionServiceLevel.tuesday":
		if e.complexity.FeedVersionServiceLevel.Tuesday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Tuesday(childComplexity), true

	case "FeedVersionServiceLevel.wednesday":
		if e.complexity.FeedVersionServiceLevel.Wednesday == nil {
			break
		}

		return e.complexity.FeedVersionServiceLevel.Wednesday(childComplexity), true

	case "FeedVersionUnimportResult.success":
		if e.complexity.FeedVersionUnimportResult.Success == nil {
			break
		}

		return e.complexity.FeedVersionUnimportResult.Success(childComplexity), true

	case "Frequency.end_time":
		if e.complexity.Frequency.EndTime == nil {
			break
		}

		return e.complexity.Frequency.EndTime(childComplexity), true

	case "Frequency.exact_times":
		if e.complexity.Frequency.ExactTimes == nil {
			break
		}

		return e.complexity.Frequency.ExactTimes(childComplexity), true

	case "Frequency.headway_secs":
		if e.complexity.Frequency.HeadwaySecs == nil {
			break
		}

		return e.complexity.Frequency.HeadwaySecs(childComplexity), true

	case "Frequency.id":
		if e.complexity.Frequency.ID == nil {
			break
		}

		return e.complexity.Frequency.ID(childComplexity), true

	case "Frequency.start_time":
		if e.complexity.Frequency.StartTime == nil {
			break
		}

		return e.complexity.Frequency.StartTime(childComplexity), true

	case "GbfsAlertTime.end":
		if e.complexity.GbfsAlertTime.End == nil {
			break
		}

		return e.complexity.GbfsAlertTime.End(childComplexity), true

	case "GbfsAlertTime.start":
		if e.complexity.GbfsAlertTime.Start == nil {
			break
		}

		return e.complexity.GbfsAlertTime.Start(childComplexity), true

	case "GbfsBrandAsset.brand_image_url":
		if e.complexity.GbfsBrandAsset.BrandImageURL == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandImageURL(childComplexity), true

	case "GbfsBrandAsset.brand_image_url_dark":
		if e.complexity.GbfsBrandAsset.BrandImageURLDark == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandImageURLDark(childComplexity), true

	case "GbfsBrandAsset.brand_last_modified":
		if e.complexity.GbfsBrandAsset.BrandLastModified == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandLastModified(childComplexity), true

	case "GbfsBrandAsset.brand_terms_url":
		if e.complexity.GbfsBrandAsset.BrandTermsURL == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.BrandTermsURL(childComplexity), true

	case "GbfsBrandAsset.color":
		if e.complexity.GbfsBrandAsset.Color == nil {
			break
		}

		return e.complexity.GbfsBrandAsset.Color(childComplexity), true

	case "GbfsFeed.alerts":
		if e.complexity.GbfsFeed.Alerts == nil {
			break
		}

		return e.complexity.GbfsFeed.Alerts(childComplexity), true

	case "GbfsFeed.calendars":
		if e.complexity.GbfsFeed.Calendars == nil {
			break
		}

		return e.complexity.GbfsFeed.Calendars(childComplexity), true

	case "GbfsFeed.rental_hours":
		if e.complexity.GbfsFeed.RentalHours == nil {
			break
		}

		return e.complexity.GbfsFeed.RentalHours(childComplexity), true

	case "GbfsFeed.station_information":
		if e.complexity.GbfsFeed.StationInformation == nil {
			break
		}

		return e.complexity.GbfsFeed.StationInformation(childComplexity), true

	case "GbfsFeed.system_information":
		if e.complexity.GbfsFeed.SystemInformation == nil {
			break
		}

		return e.complexity.GbfsFeed.SystemInformation(childComplexity), true

	case "GbfsFreeBikeStatus.available_until":
		if e.complexity.GbfsFreeBikeStatus.AvailableUntil == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.AvailableUntil(childComplexity), true

	case "GbfsFreeBikeStatus.bike_id":
		if e.complexity.GbfsFreeBikeStatus.BikeID == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.BikeID(childComplexity), true

	case "GbfsFreeBikeStatus.current_fuel_percent":
		if e.complexity.GbfsFreeBikeStatus.CurrentFuelPercent == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.CurrentFuelPercent(childComplexity), true

	case "GbfsFreeBikeStatus.current_range_meters":
		if e.complexity.GbfsFreeBikeStatus.CurrentRangeMeters == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.CurrentRangeMeters(childComplexity), true

	case "GbfsFreeBikeStatus.feed":
		if e.complexity.GbfsFreeBikeStatus.Feed == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Feed(childComplexity), true

	case "GbfsFreeBikeStatus.home_station":
		if e.complexity.GbfsFreeBikeStatus.HomeStation == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.HomeStation(childComplexity), true

	case "GbfsFreeBikeStatus.is_disabled":
		if e.complexity.GbfsFreeBikeStatus.IsDisabled == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.IsDisabled(childComplexity), true

	case "GbfsFreeBikeStatus.is_reserved":
		if e.complexity.GbfsFreeBikeStatus.IsReserved == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.IsReserved(childComplexity), true

	case "GbfsFreeBikeStatus.last_reported":
		if e.complexity.GbfsFreeBikeStatus.LastReported == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.LastReported(childComplexity), true

	case "GbfsFreeBikeStatus.lat":
		if e.complexity.GbfsFreeBikeStatus.Lat == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Lat(childComplexity), true

	case "GbfsFreeBikeStatus.lon":
		if e.complexity.GbfsFreeBikeStatus.Lon == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Lon(childComplexity), true

	case "GbfsFreeBikeStatus.pricing_plan":
		if e.complexity.GbfsFreeBikeStatus.PricingPlan == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.PricingPlan(childComplexity), true

	case "GbfsFreeBikeStatus.rental_uris":
		if e.complexity.GbfsFreeBikeStatus.RentalUris == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.RentalUris(childComplexity), true

	case "GbfsFreeBikeStatus.station":
		if e.complexity.GbfsFreeBikeStatus.Station == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.Station(childComplexity), true

	case "GbfsFreeBikeStatus.vehicle_equipment":
		if e.complexity.GbfsFreeBikeStatus.VehicleEquipment == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.VehicleEquipment(childComplexity), true

	case "GbfsFreeBikeStatus.vehicle_type":
		if e.complexity.GbfsFreeBikeStatus.VehicleType == nil {
			break
		}

		return e.complexity.GbfsFreeBikeStatus.VehicleType(childComplexity), true

	case "GbfsGeofenceFeature.geometry":
		if e.complexity.GbfsGeofenceFeature.Geometry == nil {
			break
		}

		return e.complexity.GbfsGeofenceFeature.Geometry(childComplexity), true

	case "GbfsGeofenceFeature.type":
		if e.complexity.GbfsGeofenceFeature.Type == nil {
			break
		}

		return e.complexity.GbfsGeofenceFeature.Type(childComplexity), true

	case "GbfsGeofenceProperty.end":
		if e.complexity.GbfsGeofenceProperty.End == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.End(childComplexity), true

	case "GbfsGeofenceProperty.name":
		if e.complexity.GbfsGeofenceProperty.Name == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.Name(childComplexity), true

	case "GbfsGeofenceProperty.rules":
		if e.complexity.GbfsGeofenceProperty.Rules == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.Rules(childComplexity), true

	case "GbfsGeofenceProperty.start":
		if e.complexity.GbfsGeofenceProperty.Start == nil {
			break
		}

		return e.complexity.GbfsGeofenceProperty.Start(childComplexity), true

	case "GbfsGeofenceRule.maximum_speed_kph":
		if e.complexity.GbfsGeofenceRule.MaximumSpeedKph == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.MaximumSpeedKph(childComplexity), true

	case "GbfsGeofenceRule.ride_allowed":
		if e.complexity.GbfsGeofenceRule.RideAllowed == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.RideAllowed(childComplexity), true

	case "GbfsGeofenceRule.ride_through_allowed":
		if e.complexity.GbfsGeofenceRule.RideThroughAllowed == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.RideThroughAllowed(childComplexity), true

	case "GbfsGeofenceRule.station_parking":
		if e.complexity.GbfsGeofenceRule.StationParking == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.StationParking(childComplexity), true

	case "GbfsGeofenceRule.vehicle_type":
		if e.complexity.GbfsGeofenceRule.VehicleType == nil {
			break
		}

		return e.complexity.GbfsGeofenceRule.VehicleType(childComplexity), true

	case "GbfsGeofenceZone.features":
		if e.complexity.GbfsGeofenceZone.Features == nil {
			break
		}

		return e.complexity.GbfsGeofenceZone.Features(childComplexity), true

	case "GbfsGeofenceZone.type":
		if e.complexity.GbfsGeofenceZone.Type == nil {
			break
		}

		return e.complexity.GbfsGeofenceZone.Type(childComplexity), true

	case "GbfsPlanPrice.end":
		if e.complexity.GbfsPlanPrice.End == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.End(childComplexity), true

	case "GbfsPlanPrice.interval":
		if e.complexity.GbfsPlanPrice.Interval == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.Interval(childComplexity), true

	case "GbfsPlanPrice.rate":
		if e.complexity.GbfsPlanPrice.Rate == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.Rate(childComplexity), true

	case "GbfsPlanPrice.start":
		if e.complexity.GbfsPlanPrice.Start == nil {
			break
		}

		return e.complexity.GbfsPlanPrice.Start(childComplexity), true

	case "GbfsRentalApp.discovery_uri":
		if e.complexity.GbfsRentalApp.DiscoveryURI == nil {
			break
		}

		return e.complexity.GbfsRentalApp.DiscoveryURI(childComplexity), true

	case "GbfsRentalApp.store_uri":
		if e.complexity.GbfsRentalApp.StoreURI == nil {
			break
		}

		return e.complexity.GbfsRentalApp.StoreURI(childComplexity), true

	case "GbfsRentalApps.android":
		if e.complexity.GbfsRentalApps.Android == nil {
			break
		}

		return e.complexity.GbfsRentalApps.Android(childComplexity), true

	case "GbfsRentalApps.ios":
		if e.complexity.GbfsRentalApps.Ios == nil {
			break
		}

		return e.complexity.GbfsRentalApps.Ios(childComplexity), true

	case "GbfsRentalUris.android":
		if e.complexity.GbfsRentalUris.Android == nil {
			break
		}

		return e.complexity.GbfsRentalUris.Android(childComplexity), true

	case "GbfsRentalUris.ios":
		if e.complexity.GbfsRentalUris.IOS == nil {
			break
		}

		return e.complexity.GbfsRentalUris.IOS(childComplexity), true

	case "GbfsRentalUris.web":
		if e.complexity.GbfsRentalUris.Web == nil {
			break
		}

		return e.complexity.GbfsRentalUris.Web(childComplexity), true

	case "GbfsStationInformation.address":
		if e.complexity.GbfsStationInformation.Address == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Address(childComplexity), true

	case "GbfsStationInformation.capacity":
		if e.complexity.GbfsStationInformation.Capacity == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Capacity(childComplexity), true

	case "GbfsStationInformation.contact_phone":
		if e.complexity.GbfsStationInformation.ContactPhone == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ContactPhone(childComplexity), true

	case "GbfsStationInformation.cross_street":
		if e.complexity.GbfsStationInformation.CrossStreet == nil {
			break
		}

		return e.complexity.GbfsStationInformation.CrossStreet(childComplexity), true

	case "GbfsStationInformation.feed":
		if e.complexity.GbfsStationInformation.Feed == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Feed(childComplexity), true

	case "GbfsStationInformation.is_charging_station":
		if e.complexity.GbfsStationInformation.IsChargingStation == nil {
			break
		}

		return e.complexity.GbfsStationInformation.IsChargingStation(childComplexity), true

	case "GbfsStationInformation.is_valet_station":
		if e.complexity.GbfsStationInformation.IsValetStation == nil {
			break
		}

		return e.complexity.GbfsStationInformation.IsValetStation(childComplexity), true

	case "GbfsStationInformation.is_virtual_station":
		if e.complexity.GbfsStationInformation.IsVirtualStation == nil {
			break
		}

		return e.complexity.GbfsStationInformation.IsVirtualStation(childComplexity), true

	case "GbfsStationInformation.lat":
		if e.complexity.GbfsStationInformation.Lat == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Lat(childComplexity), true

	case "GbfsStationInformation.lon":
		if e.complexity.GbfsStationInformation.Lon == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Lon(childComplexity), true

	case "GbfsStationInformation.name":
		if e.complexity.GbfsStationInformation.Name == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Name(childComplexity), true

	case "GbfsStationInformation.parking_hoop":
		if e.complexity.GbfsStationInformation.ParkingHoop == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ParkingHoop(childComplexity), true

	case "GbfsStationInformation.parking_type":
		if e.complexity.GbfsStationInformation.ParkingType == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ParkingType(childComplexity), true

	case "GbfsStationInformation.post_code":
		if e.complexity.GbfsStationInformation.PostCode == nil {
			break
		}

		return e.complexity.GbfsStationInformation.PostCode(childComplexity), true

	case "GbfsStationInformation.region":
		if e.complexity.GbfsStationInformation.Region == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Region(childComplexity), true

	case "GbfsStationInformation.rental_methods":
		if e.complexity.GbfsStationInformation.RentalMethods == nil {
			break
		}

		return e.complexity.GbfsStationInformation.RentalMethods(childComplexity), true

	case "GbfsStationInformation.short_name":
		if e.complexity.GbfsStationInformation.ShortName == nil {
			break
		}

		return e.complexity.GbfsStationInformation.ShortName(childComplexity), true

	case "GbfsStationInformation.station_area":
		if e.complexity.GbfsStationInformation.StationArea == nil {
			break
		}

		return e.complexity.GbfsStationInformation.StationArea(childComplexity), true

	case "GbfsStationInformation.station_id":
		if e.complexity.GbfsStationInformation.StationID == nil {
			break
		}

		return e.complexity.GbfsStationInformation.StationID(childComplexity), true

	case "GbfsStationInformation.status":
		if e.complexity.GbfsStationInformation.Status == nil {
			break
		}

		return e.complexity.GbfsStationInformation.Status(childComplexity), true

	case "GbfsStationStatus.is_installed":
		if e.complexity.GbfsStationStatus.IsInstalled == nil {
			break
		}

		return e.complexity.GbfsStationStatus.IsInstalled(childComplexity), true

	case "GbfsStationStatus.is_renting":
		if e.complexity.GbfsStationStatus.IsRenting == nil {
			break
		}

		return e.complexity.GbfsStationStatus.IsRenting(childComplexity), true

	case "GbfsStationStatus.is_returning":
		if e.complexity.GbfsStationStatus.IsReturning == nil {
			break
		}

		return e.complexity.GbfsStationStatus.IsReturning(childComplexity), true

	case "GbfsStationStatus.last_reported":
		if e.complexity.GbfsStationStatus.LastReported == nil {
			break
		}

		return e.complexity.GbfsStationStatus.LastReported(childComplexity), true

	case "GbfsStationStatus.num_bikes_available":
		if e.complexity.GbfsStationStatus.NumBikesAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumBikesAvailable(childComplexity), true

	case "GbfsStationStatus.num_bikes_disabled":
		if e.complexity.GbfsStationStatus.NumBikesDisabled == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumBikesDisabled(childComplexity), true

	case "GbfsStationStatus.num_docks_available":
		if e.complexity.GbfsStationStatus.NumDocksAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumDocksAvailable(childComplexity), true

	case "GbfsStationStatus.num_docks_disabled":
		if e.complexity.GbfsStationStatus.NumDocksDisabled == nil {
			break
		}

		return e.complexity.GbfsStationStatus.NumDocksDisabled(childComplexity), true

	case "GbfsStationStatus.station_id":
		if e.complexity.GbfsStationStatus.StationID == nil {
			break
		}

		return e.complexity.GbfsStationStatus.StationID(childComplexity), true

	case "GbfsStationStatus.vehicle_docks_available":
		if e.complexity.GbfsStationStatus.VehicleDocksAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.VehicleDocksAvailable(childComplexity), true

	case "GbfsStationStatus.vehicle_types_available":
		if e.complexity.GbfsStationStatus.VehicleTypesAvailable == nil {
			break
		}

		return e.complexity.GbfsStationStatus.VehicleTypesAvailable(childComplexity), true

	case "GbfsSystemAlert.alert_id":
		if e.complexity.GbfsSystemAlert.AlertID == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.AlertID(childComplexity), true

	case "GbfsSystemAlert.description":
		if e.complexity.GbfsSystemAlert.Description == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Description(childComplexity), true

	case "GbfsSystemAlert.last_updated":
		if e.complexity.GbfsSystemAlert.LastUpdated == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.LastUpdated(childComplexity), true

	case "GbfsSystemAlert.summary":
		if e.complexity.GbfsSystemAlert.Summary == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Summary(childComplexity), true

	case "GbfsSystemAlert.times":
		if e.complexity.GbfsSystemAlert.Times == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Times(childComplexity), true

	case "GbfsSystemAlert.type":
		if e.complexity.GbfsSystemAlert.Type == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.Type(childComplexity), true

	case "GbfsSystemAlert.url":
		if e.complexity.GbfsSystemAlert.URL == nil {
			break
		}

		return e.complexity.GbfsSystemAlert.URL(childComplexity), true

	case "GbfsSystemCalendar.end_day":
		if e.complexity.GbfsSystemCalendar.EndDay == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.EndDay(childComplexity), true

	case "GbfsSystemCalendar.end_month":
		if e.complexity.GbfsSystemCalendar.EndMonth == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.EndMonth(childComplexity), true

	case "GbfsSystemCalendar.end_year":
		if e.complexity.GbfsSystemCalendar.EndYear == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.EndYear(childComplexity), true

	case "GbfsSystemCalendar.start_day":
		if e.complexity.GbfsSystemCalendar.StartDay == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.StartDay(childComplexity), true

	case "GbfsSystemCalendar.start_month":
		if e.complexity.GbfsSystemCalendar.StartMonth == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.StartMonth(childComplexity), true

	case "GbfsSystemCalendar.start_year":
		if e.complexity.GbfsSystemCalendar.StartYear == nil {
			break
		}

		return e.complexity.GbfsSystemCalendar.StartYear(childComplexity), true

	case "GbfsSystemHour.days":
		if e.complexity.GbfsSystemHour.Days == nil {
			break
		}

		return e.complexity.GbfsSystemHour.Days(childComplexity), true

	case "GbfsSystemHour.end_time":
		if e.complexity.GbfsSystemHour.EndTime == nil {
			break
		}

		return e.complexity.GbfsSystemHour.EndTime(childComplexity), true

	case "GbfsSystemHour.start_time":
		if e.complexity.GbfsSystemHour.StartTime == nil {
			break
		}

		return e.complexity.GbfsSystemHour.StartTime(childComplexity), true

	case "GbfsSystemHour.user_types":
		if e.complexity.GbfsSystemHour.UserTypes == nil {
			break
		}

		return e.complexity.GbfsSystemHour.UserTypes(childComplexity), true

	case "GbfsSystemInformation.brand_assets":
		if e.complexity.GbfsSystemInformation.BrandAssets == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.BrandAssets(childComplexity), true

	case "GbfsSystemInformation.email":
		if e.complexity.GbfsSystemInformation.Email == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Email(childComplexity), true

	case "GbfsSystemInformation.feed_contact_email":
		if e.complexity.GbfsSystemInformation.FeedContactEmail == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.FeedContactEmail(childComplexity), true

	case "GbfsSystemInformation.language":
		if e.complexity.GbfsSystemInformation.Language == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Language(childComplexity), true

	case "GbfsSystemInformation.license_url":
		if e.complexity.GbfsSystemInformation.LicenseURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.LicenseURL(childComplexity), true

	case "GbfsSystemInformation.name":
		if e.complexity.GbfsSystemInformation.Name == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Name(childComplexity), true

	case "GbfsSystemInformation.operator":
		if e.complexity.GbfsSystemInformation.Operator == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Operator(childComplexity), true

	case "GbfsSystemInformation.phone_number":
		if e.complexity.GbfsSystemInformation.PhoneNumber == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PhoneNumber(childComplexity), true

	case "GbfsSystemInformation.privacy_last_updated":
		if e.complexity.GbfsSystemInformation.PrivacyLastUpdated == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PrivacyLastUpdated(childComplexity), true

	case "GbfsSystemInformation.privacy_url":
		if e.complexity.GbfsSystemInformation.PrivacyURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PrivacyURL(childComplexity), true

	case "GbfsSystemInformation.purchase_url":
		if e.complexity.GbfsSystemInformation.PurchaseURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.PurchaseURL(childComplexity), true

	case "GbfsSystemInformation.rental_apps":
		if e.complexity.GbfsSystemInformation.RentalApps == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.RentalApps(childComplexity), true

	case "GbfsSystemInformation.short_name":
		if e.complexity.GbfsSystemInformation.ShortName == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.ShortName(childComplexity), true

	case "GbfsSystemInformation.start_date":
		if e.complexity.GbfsSystemInformation.StartDate == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.StartDate(childComplexity), true

	case "GbfsSystemInformation.system_id":
		if e.complexity.GbfsSystemInformation.SystemID == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.SystemID(childComplexity), true

	case "GbfsSystemInformation.terms_last_updated":
		if e.complexity.GbfsSystemInformation.TermsLastUpdated == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.TermsLastUpdated(childComplexity), true

	case "GbfsSystemInformation.terms_url":
		if e.complexity.GbfsSystemInformation.TermsURL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.TermsURL(childComplexity), true

	case "GbfsSystemInformation.timezone":
		if e.complexity.GbfsSystemInformation.Timezone == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.Timezone(childComplexity), true

	case "GbfsSystemInformation.url":
		if e.complexity.GbfsSystemInformation.URL == nil {
			break
		}

		return e.complexity.GbfsSystemInformation.URL(childComplexity), true

	case "GbfsSystemPricingPlan.currency":
		if e.complexity.GbfsSystemPricingPlan.Currency == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Currency(childComplexity), true

	case "GbfsSystemPricingPlan.description":
		if e.complexity.GbfsSystemPricingPlan.Description == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Description(childComplexity), true

	case "GbfsSystemPricingPlan.is_taxable":
		if e.complexity.GbfsSystemPricingPlan.IsTaxable == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.IsTaxable(childComplexity), true

	case "GbfsSystemPricingPlan.name":
		if e.complexity.GbfsSystemPricingPlan.Name == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Name(childComplexity), true

	case "GbfsSystemPricingPlan.per_km_pricing":
		if e.complexity.GbfsSystemPricingPlan.PerKmPricing == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.PerKmPricing(childComplexity), true

	case "GbfsSystemPricingPlan.per_min_pricing":
		if e.complexity.GbfsSystemPricingPlan.PerMinPricing == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.PerMinPricing(childComplexity), true

	case "GbfsSystemPricingPlan.plan_id":
		if e.complexity.GbfsSystemPricingPlan.PlanID == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.PlanID(childComplexity), true

	case "GbfsSystemPricingPlan.price":
		if e.complexity.GbfsSystemPricingPlan.Price == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.Price(childComplexity), true

	case "GbfsSystemPricingPlan.surge_pricing":
		if e.complexity.GbfsSystemPricingPlan.SurgePricing == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.SurgePricing(childComplexity), true

	case "GbfsSystemPricingPlan.url":
		if e.complexity.GbfsSystemPricingPlan.URL == nil {
			break
		}

		return e.complexity.GbfsSystemPricingPlan.URL(childComplexity), true

	case "GbfsSystemRegion.name":
		if e.complexity.GbfsSystemRegion.Name == nil {
			break
		}

		return e.complexity.GbfsSystemRegion.Name(childComplexity), true

	case "GbfsSystemRegion.region_id":
		if e.complexity.GbfsSystemRegion.RegionID == nil {
			break
		}

		return e.complexity.GbfsSystemRegion.RegionID(childComplexity), true

	case "GbfsSystemVersion.url":
		if e.complexity.GbfsSystemVersion.URL == nil {
			break
		}

		return e.complexity.GbfsSystemVersion.URL(childComplexity), true

	case "GbfsSystemVersion.version":
		if e.complexity.GbfsSystemVersion.Version == nil {
			break
		}

		return e.complexity.GbfsSystemVersion.Version(childComplexity), true

	case "GbfsVehicleAssets.icon_last_modified":
		if e.complexity.GbfsVehicleAssets.IconLastModified == nil {
			break
		}

		return e.complexity.GbfsVehicleAssets.IconLastModified(childComplexity), true

	case "GbfsVehicleAssets.icon_url":
		if e.complexity.GbfsVehicleAssets.IconURL == nil {
			break
		}

		return e.complexity.GbfsVehicleAssets.IconURL(childComplexity), true

	case "GbfsVehicleAssets.icon_url_dark":
		if e.complexity.GbfsVehicleAssets.IconURLDark == nil {
			break
		}

		return e.complexity.GbfsVehicleAssets.IconURLDark(childComplexity), true

	case "GbfsVehicleDockAvailable.count":
		if e.complexity.GbfsVehicleDockAvailable.Count == nil {
			break
		}

		return e.complexity.GbfsVehicleDockAvailable.Count(childComplexity), true

	case "GbfsVehicleDockAvailable.vehicle_types":
		if e.complexity.GbfsVehicleDockAvailable.VehicleTypes == nil {
			break
		}

		return e.complexity.GbfsVehicleDockAvailable.VehicleTypes(childComplexity), true

	case "GbfsVehicleType.cargo_load_capacity":
		if e.complexity.GbfsVehicleType.CargoLoadCapacity == nil {
			break
		}

		return e.complexity.GbfsVehicleType.CargoLoadCapacity(childComplexity), true

	case "GbfsVehicleType.cargo_volume_capacity":
		if e.complexity.GbfsVehicleType.CargoVolumeCapacity == nil {
			break
		}

		return e.complexity.GbfsVehicleType.CargoVolumeCapacity(childComplexity), true

	case "GbfsVehicleType.color":
		if e.complexity.GbfsVehicleType.Color == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Color(childComplexity), true

	case "GbfsVehicleType.country_code":
		if e.complexity.GbfsVehicleType.CountryCode == nil {
			break
		}

		return e.complexity.GbfsVehicleType.CountryCode(childComplexity), true

	case "GbfsVehicleType.default_pricing_plan":
		if e.complexity.GbfsVehicleType.DefaultPricingPlan == nil {
			break
		}

		return e.complexity.GbfsVehicleType.DefaultPricingPlan(childComplexity), true

	case "GbfsVehicleType.default_reserve_time":
		if e.complexity.GbfsVehicleType.DefaultReserveTime == nil {
			break
		}

		return e.complexity.GbfsVehicleType.DefaultReserveTime(childComplexity), true

	case "GbfsVehicleType.eco_label":
		if e.complexity.GbfsVehicleType.EcoLabel == nil {
			break
		}

		return e.complexity.GbfsVehicleType.EcoLabel(childComplexity), true

	case "GbfsVehicleType.eco_sticker":
		if e.complexity.GbfsVehicleType.EcoSticker == nil {
			break
		}

		return e.complexity.GbfsVehicleType.EcoSticker(childComplexity), true

	case "GbfsVehicleType.form_factor":
		if e.complexity.GbfsVehicleType.FormFactor == nil {
			break
		}

		return e.complexity.GbfsVehicleType.FormFactor(childComplexity), true

	case "GbfsVehicleType.gco_2_km":
		if e.complexity.GbfsVehicleType.GCO2Km == nil {
			break
		}

		return e.complexity.GbfsVehicleType.GCO2Km(childComplexity), true

	case "GbfsVehicleType.make":
		if e.complexity.GbfsVehicleType.Make == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Make(childComplexity), true

	case "GbfsVehicleType.max_permitted_speed":
		if e.complexity.GbfsVehicleType.MaxPermittedSpeed == nil {
			break
		}

		return e.complexity.GbfsVehicleType.MaxPermittedSpeed(childComplexity), true

	case "GbfsVehicleType.max_range_meters":
		if e.complexity.GbfsVehicleType.MaxRangeMeters == nil {
			break
		}

		return e.complexity.GbfsVehicleType.MaxRangeMeters(childComplexity), true

	case "GbfsVehicleType.model":
		if e.complexity.GbfsVehicleType.Model == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Model(childComplexity), true

	case "GbfsVehicleType.name":
		if e.complexity.GbfsVehicleType.Name == nil {
			break
		}

		return e.complexity.GbfsVehicleType.Name(childComplexity), true

	case "GbfsVehicleType.pricing_plans":
		if e.complexity.GbfsVehicleType.PricingPlans == nil {
			break
		}

		return e.complexity.GbfsVehicleType.PricingPlans(childComplexity), true

	case "GbfsVehicleType.propulsion_type":
		if e.complexity.GbfsVehicleType.PropulsionType == nil {
			break
		}

		return e.complexity.GbfsVehicleType.PropulsionType(childComplexity), true

	case "GbfsVehicleType.rated_power":
		if e.complexity.GbfsVehicleType.RatedPower == nil {
			break
		}

		return e.complexity.GbfsVehicleType.RatedPower(childComplexity), true

	case "GbfsVehicleType.rental_uris":
		if e.complexity.GbfsVehicleType.RentalUris == nil {
			break
		}

		return e.complexity.GbfsVehicleType.RentalUris(childComplexity), true

	case "GbfsVehicleType.return_constraint":
		if e.complexity.GbfsVehicleType.ReturnConstraint == nil {
			break
		}

		return e.complexity.GbfsVehicleType.ReturnConstraint(childComplexity), true

	case "GbfsVehicleType.rider_capacity":
		if e.complexity.GbfsVehicleType.RiderCapacity == nil {
			break
		}

		return e.complexity.GbfsVehicleType.RiderCapacity(childComplexity), true

	case "GbfsVehicleType.vehicle_accessories":
		if e.complexity.GbfsVehicleType.VehicleAccessories == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleAccessories(childComplexity), true

	case "GbfsVehicleType.vehicle_assets":
		if e.complexity.GbfsVehicleType.VehicleAssets == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleAssets(childComplexity), true

	case "GbfsVehicleType.vehicle_image":
		if e.complexity.GbfsVehicleType.VehicleImage == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleImage(childComplexity), true

	case "GbfsVehicleType.vehicle_type_id":
		if e.complexity.GbfsVehicleType.VehicleTypeID == nil {
			break
		}

		return e.complexity.GbfsVehicleType.VehicleTypeID(childComplexity), true

	case "GbfsVehicleType.wheel_count":
		if e.complexity.GbfsVehicleType.WheelCount == nil {
			break
		}

		return e.complexity.GbfsVehicleType.WheelCount(childComplexity), true

	case "GbfsVehicleTypeAvailable.count":
		if e.complexity.GbfsVehicleTypeAvailable.Count == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.Count(childComplexity), true

	case "GbfsVehicleTypeAvailable.num_bikes_disabled":
		if e.complexity.GbfsVehicleTypeAvailable.NumBikesDisabled == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.NumBikesDisabled(childComplexity), true

	case "GbfsVehicleTypeAvailable.num_docks_available":
		if e.complexity.GbfsVehicleTypeAvailable.NumDocksAvailable == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.NumDocksAvailable(childComplexity), true

	case "GbfsVehicleTypeAvailable.vehicle_type":
		if e.complexity.GbfsVehicleTypeAvailable.VehicleType == nil {
			break
		}

		return e.complexity.GbfsVehicleTypeAvailable.VehicleType(childComplexity), true

	case "Itinerary.distance":
		if e.complexity.Itinerary.Distance == nil {
			break
		}

		return e.complexity.Itinerary.Distance(childComplexity), true

	case "Itinerary.duration":
		if e.complexity.Itinerary.Duration == nil {
			break
		}

		return e.complexity.Itinerary.Duration(childComplexity), true

	case "Itinerary.end_time":
		if e.complexity.Itinerary.EndTime == nil {
			break
		}

		return e.complexity.Itinerary.EndTime(childComplexity), true

	case "Itinerary.from":
		if e.complexity.Itinerary.From == nil {
			break
		}

		return e.complexity.Itinerary.From(childComplexity), true

	case "Itinerary.legs":
		if e.complexity.Itinerary.Legs == nil {
			break
		}

		return e.complexity.Itinerary.Legs(childComplexity), true

	case "Itinerary.start_time":
		if e.complexity.Itinerary.StartTime == nil {
			break
		}

		return e.complexity.Itinerary.StartTime(childComplexity), true

	case "Itinerary.to":
		if e.complexity.Itinerary.To == nil {
			break
		}

		return e.complexity.Itinerary.To(childComplexity), true

	case "Leg.distance":
		if e.complexity.Leg.Distance == nil {
			break
		}

		return e.complexity.Leg.Distance(childComplexity), true

	case "Leg.duration":
		if e.complexity.Leg.Duration == nil {
			break
		}

		return e.complexity.Leg.Duration(childComplexity), true

	case "Leg.end_time":
		if e.complexity.Leg.EndTime == nil {
			break
		}

		return e.complexity.Leg.EndTime(childComplexity), true

	case "Leg.from":
		if e.complexity.Leg.From == nil {
			break
		}

		return e.complexity.Leg.From(childComplexity), true

	case "Leg.geometry":
		if e.complexity.Leg.Geometry == nil {
			break
		}

		return e.complexity.Leg.Geometry(childComplexity), true

	case "Leg.start_time":
		if e.complexity.Leg.StartTime == nil {
			break
		}

		return e.complexity.Leg.StartTime(childComplexity), true

	case "Leg.steps":
		if e.complexity.Leg.Steps == nil {
			break
		}

		return e.complexity.Leg.Steps(childComplexity), true

	case "Leg.to":
		if e.complexity.Leg.To == nil {
			break
		}

		return e.complexity.Leg.To(childComplexity), true

	case "Level.geometry":
		if e.complexity.Level.Geometry == nil {
			break
		}

		return e.complexity.Level.Geometry(childComplexity), true

	case "Level.id":
		if e.complexity.Level.ID == nil {
			break
		}

		return e.complexity.Level.ID(childComplexity), true

	case "Level.level_id":
		if e.complexity.Level.LevelID == nil {
			break
		}

		return e.complexity.Level.LevelID(childComplexity), true

	case "Level.level_index":
		if e.complexity.Level.LevelIndex == nil {
			break
		}

		return e.complexity.Level.LevelIndex(childComplexity), true

	case "Level.level_name":
		if e.complexity.Level.LevelName == nil {
			break
		}

		return e.complexity.Level.LevelName(childComplexity), true

	case "Level.stops":
		if e.complexity.Level.Stops == nil {
			break
		}

		return e.complexity.Level.Stops(childComplexity), true

	case "Mutation.feed_version_delete":
		if e.complexity.Mutation.FeedVersionDelete == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_delete_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionDelete(childComplexity, args["id"].(int)), true

	case "Mutation.feed_version_fetch":
		if e.complexity.Mutation.FeedVersionFetch == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_fetch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionFetch(childComplexity, args["file"].(*graphql.Upload), args["url"].(*string), args["feed_onestop_id"].(string)), true

	case "Mutation.feed_version_import":
		if e.complexity.Mutation.FeedVersionImport == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_import_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionImport(childComplexity, args["sha1"].(string)), true

	case "Mutation.feed_version_unimport":
		if e.complexity.Mutation.FeedVersionUnimport == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_unimport_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionUnimport(childComplexity, args["id"].(int)), true

	case "Mutation.feed_version_update":
		if e.complexity.Mutation.FeedVersionUpdate == nil {
			break
		}

		args, err := ec.field_Mutation_feed_version_update_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.FeedVersionUpdate(childComplexity, args["id"].(int), args["set"].(model.FeedVersionSetInput)), true

	case "Mutation.validate_gtfs":
		if e.complexity.Mutation.ValidateGtfs == nil {
			break
		}

		args, err := ec.field_Mutation_validate_gtfs_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ValidateGtfs(childComplexity, args["file"].(*graphql.Upload), args["url"].(*string), args["realtime_urls"].([]string)), true

	case "Operator.agencies":
		if e.complexity.Operator.Agencies == nil {
			break
		}

		return e.complexity.Operator.Agencies(childComplexity), true

	case "Operator.feeds":
		if e.complexity.Operator.Feeds == nil {
			break
		}

		args, err := ec.field_Operator_feeds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Operator.Feeds(childComplexity, args["limit"].(*int), args["where"].(*model.FeedFilter)), true

	case "Operator.file":
		if e.complexity.Operator.File == nil {
			break
		}

		return e.complexity.Operator.File(childComplexity), true

	case "Operator.generated":
		if e.complexity.Operator.Generated == nil {
			break
		}

		return e.complexity.Operator.Generated(childComplexity), true

	case "Operator.id":
		if e.complexity.Operator.ID == nil {
			break
		}

		return e.complexity.Operator.ID(childComplexity), true

	case "Operator.name":
		if e.complexity.Operator.Name == nil {
			break
		}

		return e.complexity.Operator.Name(childComplexity), true

	case "Operator.onestop_id":
		if e.complexity.Operator.OnestopID == nil {
			break
		}

		return e.complexity.Operator.OnestopID(childComplexity), true

	case "Operator.search_rank":
		if e.complexity.Operator.SearchRank == nil {
			break
		}

		return e.complexity.Operator.SearchRank(childComplexity), true

	case "Operator.short_name":
		if e.complexity.Operator.ShortName == nil {
			break
		}

		return e.complexity.Operator.ShortName(childComplexity), true

	case "Operator.tags":
		if e.complexity.Operator.Tags == nil {
			break
		}

		return e.complexity.Operator.Tags(childComplexity), true

	case "Operator.website":
		if e.complexity.Operator.Website == nil {
			break
		}

		return e.complexity.Operator.Website(childComplexity), true

	case "Pathway.from_stop":
		if e.complexity.Pathway.FromStop == nil {
			break
		}

		return e.complexity.Pathway.FromStop(childComplexity), true

	case "Pathway.id":
		if e.complexity.Pathway.ID == nil {
			break
		}

		return e.complexity.Pathway.ID(childComplexity), true

	case "Pathway.is_bidirectional":
		if e.complexity.Pathway.IsBidirectional == nil {
			break
		}

		return e.complexity.Pathway.IsBidirectional(childComplexity), true

	case "Pathway.length":
		if e.complexity.Pathway.Length == nil {
			break
		}

		return e.complexity.Pathway.Length(childComplexity), true

	case "Pathway.max_slope":
		if e.complexity.Pathway.MaxSlope == nil {
			break
		}

		return e.complexity.Pathway.MaxSlope(childComplexity), true

	case "Pathway.min_width":
		if e.complexity.Pathway.MinWidth == nil {
			break
		}

		return e.complexity.Pathway.MinWidth(childComplexity), true

	case "Pathway.pathway_id":
		if e.complexity.Pathway.PathwayID == nil {
			break
		}

		return e.complexity.Pathway.PathwayID(childComplexity), true

	case "Pathway.pathway_mode":
		if e.complexity.Pathway.PathwayMode == nil {
			break
		}

		return e.complexity.Pathway.PathwayMode(childComplexity), true

	case "Pathway.reverse_signposted_as":
		if e.complexity.Pathway.ReverseSignpostedAs == nil {
			break
		}

		return e.complexity.Pathway.ReverseSignpostedAs(childComplexity), true

	case "Pathway.signposted_as":
		if e.complexity.Pathway.SignpostedAs == nil {
			break
		}

		return e.complexity.Pathway.SignpostedAs(childComplexity), true

	case "Pathway.stair_count":
		if e.complexity.Pathway.StairCount == nil {
			break
		}

		return e.complexity.Pathway.StairCount(childComplexity), true

	case "Pathway.to_stop":
		if e.complexity.Pathway.ToStop == nil {
			break
		}

		return e.complexity.Pathway.ToStop(childComplexity), true

	case "Pathway.traversal_time":
		if e.complexity.Pathway.TraversalTime == nil {
			break
		}

		return e.complexity.Pathway.TraversalTime(childComplexity), true

	case "Place.adm0_name":
		if e.complexity.Place.Adm0Name == nil {
			break
		}

		return e.complexity.Place.Adm0Name(childComplexity), true

	case "Place.adm1_name":
		if e.complexity.Place.Adm1Name == nil {
			break
		}

		return e.complexity.Place.Adm1Name(childComplexity), true

	case "Place.city_name":
		if e.complexity.Place.CityName == nil {
			break
		}

		return e.complexity.Place.CityName(childComplexity), true

	case "Place.count":
		if e.complexity.Place.Count == nil {
			break
		}

		return e.complexity.Place.Count(childComplexity), true

	case "Place.operators":
		if e.complexity.Place.Operators == nil {
			break
		}

		return e.complexity.Place.Operators(childComplexity), true

	case "Query.agencies":
		if e.complexity.Query.Agencies == nil {
			break
		}

		args, err := ec.field_Query_agencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Agencies(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.AgencyFilter)), true

	case "Query.bikes":
		if e.complexity.Query.Bikes == nil {
			break
		}

		args, err := ec.field_Query_bikes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Bikes(childComplexity, args["limit"].(*int), args["where"].(*model.GbfsBikeRequest)), true

	case "Query.directions":
		if e.complexity.Query.Directions == nil {
			break
		}

		args, err := ec.field_Query_directions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Directions(childComplexity, args["where"].(model.DirectionRequest)), true

	case "Query.docks":
		if e.complexity.Query.Docks == nil {
			break
		}

		args, err := ec.field_Query_docks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Docks(childComplexity, args["limit"].(*int), args["where"].(*model.GbfsDockRequest)), true

	case "Query.feed_versions":
		if e.complexity.Query.FeedVersions == nil {
			break
		}

		args, err := ec.field_Query_feed_versions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FeedVersions(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.FeedVersionFilter)), true

	case "Query.feeds":
		if e.complexity.Query.Feeds == nil {
			break
		}

		args, err := ec.field_Query_feeds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Feeds(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.FeedFilter)), true

	case "Query.operators":
		if e.complexity.Query.Operators == nil {
			break
		}

		args, err := ec.field_Query_operators_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Operators(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.OperatorFilter)), true

	case "Query.places":
		if e.complexity.Query.Places == nil {
			break
		}

		args, err := ec.field_Query_places_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Places(childComplexity, args["limit"].(*int), args["after"].(*int), args["level"].(*model.PlaceAggregationLevel), args["where"].(*model.PlaceFilter)), true

	case "Query.routes":
		if e.complexity.Query.Routes == nil {
			break
		}

		args, err := ec.field_Query_routes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Routes(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.RouteFilter)), true

	case "Query.stops":
		if e.complexity.Query.Stops == nil {
			break
		}

		args, err := ec.field_Query_stops_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Stops(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.StopFilter)), true

	case "Query.trips":
		if e.complexity.Query.Trips == nil {
			break
		}

		args, err := ec.field_Query_trips_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Trips(childComplexity, args["limit"].(*int), args["after"].(*int), args["ids"].([]int), args["where"].(*model.TripFilter)), true

	case "RTTimeRange.end":
		if e.complexity.RTTimeRange.End == nil {
			break
		}

		return e.complexity.RTTimeRange.End(childComplexity), true

	case "RTTimeRange.start":
		if e.complexity.RTTimeRange.Start == nil {
			break
		}

		return e.complexity.RTTimeRange.Start(childComplexity), true

	case "RTTranslation.language":
		if e.complexity.RTTranslation.Language == nil {
			break
		}

		return e.complexity.RTTranslation.Language(childComplexity), true

	case "RTTranslation.text":
		if e.complexity.RTTranslation.Text == nil {
			break
		}

		return e.complexity.RTTranslation.Text(childComplexity), true

	case "RTTripDescriptor.direction_id":
		if e.complexity.RTTripDescriptor.DirectionID == nil {
			break
		}

		return e.complexity.RTTripDescriptor.DirectionID(childComplexity), true

	case "RTTripDescriptor.route_id":
		if e.complexity.RTTripDescriptor.RouteID == nil {
			break
		}

		return e.complexity.RTTripDescriptor.RouteID(childComplexity), true

	case "RTTripDescriptor.schedule_relationship":
		if e.complexity.RTTripDescriptor.ScheduleRelationship == nil {
			break
		}

		return e.complexity.RTTripDescriptor.ScheduleRelationship(childComplexity), true

	case "RTTripDescriptor.start_date":
		if e.complexity.RTTripDescriptor.StartDate == nil {
			break
		}

		return e.complexity.RTTripDescriptor.StartDate(childComplexity), true

	case "RTTripDescriptor.start_time":
		if e.complexity.RTTripDescriptor.StartTime == nil {
			break
		}

		return e.complexity.RTTripDescriptor.StartTime(childComplexity), true

	case "RTTripDescriptor.trip_id":
		if e.complexity.RTTripDescriptor.TripID == nil {
			break
		}

		return e.complexity.RTTripDescriptor.TripID(childComplexity), true

	case "RTVehicleDescriptor.id":
		if e.complexity.RTVehicleDescriptor.ID == nil {
			break
		}

		return e.complexity.RTVehicleDescriptor.ID(childComplexity), true

	case "RTVehicleDescriptor.label":
		if e.complexity.RTVehicleDescriptor.Label == nil {
			break
		}

		return e.complexity.RTVehicleDescriptor.Label(childComplexity), true

	case "RTVehicleDescriptor.license_plate":
		if e.complexity.RTVehicleDescriptor.LicensePlate == nil {
			break
		}

		return e.complexity.RTVehicleDescriptor.LicensePlate(childComplexity), true

	case "Route.agency":
		if e.complexity.Route.Agency == nil {
			break
		}

		return e.complexity.Route.Agency(childComplexity), true

	case "Route.alerts":
		if e.complexity.Route.Alerts == nil {
			break
		}

		args, err := ec.field_Route_alerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Route.census_geographies":
		if e.complexity.Route.CensusGeographies == nil {
			break
		}

		args, err := ec.field_Route_census_geographies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.CensusGeographies(childComplexity, args["layer"].(string), args["radius"].(*float64), args["limit"].(*int)), true

	case "Route.continuous_drop_off":
		if e.complexity.Route.ContinuousDropOff == nil {
			break
		}

		return e.complexity.Route.ContinuousDropOff(childComplexity), true

	case "Route.continuous_pickup":
		if e.complexity.Route.ContinuousPickup == nil {
			break
		}

		return e.complexity.Route.ContinuousPickup(childComplexity), true

	case "Route.feed_onestop_id":
		if e.complexity.Route.FeedOnestopID == nil {
			break
		}

		return e.complexity.Route.FeedOnestopID(childComplexity), true

	case "Route.feed_version":
		if e.complexity.Route.FeedVersion == nil {
			break
		}

		return e.complexity.Route.FeedVersion(childComplexity), true

	case "Route.feed_version_sha1":
		if e.complexity.Route.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.Route.FeedVersionSHA1(childComplexity), true

	case "Route.geometries":
		if e.complexity.Route.Geometries == nil {
			break
		}

		args, err := ec.field_Route_geometries_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Geometries(childComplexity, args["limit"].(*int)), true

	case "Route.geometry":
		if e.complexity.Route.Geometry == nil {
			break
		}

		return e.complexity.Route.Geometry(childComplexity), true

	case "Route.headways":
		if e.complexity.Route.Headways == nil {
			break
		}

		args, err := ec.field_Route_headways_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Headways(childComplexity, args["limit"].(*int)), true

	case "Route.id":
		if e.complexity.Route.ID == nil {
			break
		}

		return e.complexity.Route.ID(childComplexity), true

	case "Route.onestop_id":
		if e.complexity.Route.OnestopID == nil {
			break
		}

		return e.complexity.Route.OnestopID(childComplexity), true

	case "Route.patterns":
		if e.complexity.Route.Patterns == nil {
			break
		}

		return e.complexity.Route.Patterns(childComplexity), true

	case "Route.route_attribute":
		if e.complexity.Route.RouteAttribute == nil {
			break
		}

		return e.complexity.Route.RouteAttribute(childComplexity), true

	case "Route.route_color":
		if e.complexity.Route.RouteColor == nil {
			break
		}

		return e.complexity.Route.RouteColor(childComplexity), true

	case "Route.route_desc":
		if e.complexity.Route.RouteDesc == nil {
			break
		}

		return e.complexity.Route.RouteDesc(childComplexity), true

	case "Route.route_id":
		if e.complexity.Route.RouteID == nil {
			break
		}

		return e.complexity.Route.RouteID(childComplexity), true

	case "Route.route_long_name":
		if e.complexity.Route.RouteLongName == nil {
			break
		}

		return e.complexity.Route.RouteLongName(childComplexity), true

	case "Route.route_short_name":
		if e.complexity.Route.RouteShortName == nil {
			break
		}

		return e.complexity.Route.RouteShortName(childComplexity), true

	case "Route.route_sort_order":
		if e.complexity.Route.RouteSortOrder == nil {
			break
		}

		return e.complexity.Route.RouteSortOrder(childComplexity), true

	case "Route.route_stop_buffer":
		if e.complexity.Route.RouteStopBuffer == nil {
			break
		}

		args, err := ec.field_Route_route_stop_buffer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.RouteStopBuffer(childComplexity, args["radius"].(*float64)), true

	case "Route.route_stops":
		if e.complexity.Route.RouteStops == nil {
			break
		}

		args, err := ec.field_Route_route_stops_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.RouteStops(childComplexity, args["limit"].(*int)), true

	case "Route.route_text_color":
		if e.complexity.Route.RouteTextColor == nil {
			break
		}

		return e.complexity.Route.RouteTextColor(childComplexity), true

	case "Route.route_type":
		if e.complexity.Route.RouteType == nil {
			break
		}

		return e.complexity.Route.RouteType(childComplexity), true

	case "Route.route_url":
		if e.complexity.Route.RouteURL == nil {
			break
		}

		return e.complexity.Route.RouteURL(childComplexity), true

	case "Route.search_rank":
		if e.complexity.Route.SearchRank == nil {
			break
		}

		return e.complexity.Route.SearchRank(childComplexity), true

	case "Route.stops":
		if e.complexity.Route.Stops == nil {
			break
		}

		args, err := ec.field_Route_stops_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Stops(childComplexity, args["limit"].(*int), args["where"].(*model.StopFilter)), true

	case "Route.trips":
		if e.complexity.Route.Trips == nil {
			break
		}

		args, err := ec.field_Route_trips_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Route.Trips(childComplexity, args["limit"].(*int), args["where"].(*model.TripFilter)), true

	case "RouteAttribute.category":
		if e.complexity.RouteAttribute.Category == nil {
			break
		}

		return e.complexity.RouteAttribute.Category(childComplexity), true

	case "RouteAttribute.running_way":
		if e.complexity.RouteAttribute.RunningWay == nil {
			break
		}

		return e.complexity.RouteAttribute.RunningWay(childComplexity), true

	case "RouteAttribute.subcategory":
		if e.complexity.RouteAttribute.Subcategory == nil {
			break
		}

		return e.complexity.RouteAttribute.Subcategory(childComplexity), true

	case "RouteGeometry.combined_geometry":
		if e.complexity.RouteGeometry.CombinedGeometry == nil {
			break
		}

		return e.complexity.RouteGeometry.CombinedGeometry(childComplexity), true

	case "RouteGeometry.first_point_max_distance":
		if e.complexity.RouteGeometry.FirstPointMaxDistance == nil {
			break
		}

		return e.complexity.RouteGeometry.FirstPointMaxDistance(childComplexity), true

	case "RouteGeometry.generated":
		if e.complexity.RouteGeometry.Generated == nil {
			break
		}

		return e.complexity.RouteGeometry.Generated(childComplexity), true

	case "RouteGeometry.geometry":
		if e.complexity.RouteGeometry.Geometry == nil {
			break
		}

		return e.complexity.RouteGeometry.Geometry(childComplexity), true

	case "RouteGeometry.length":
		if e.complexity.RouteGeometry.Length == nil {
			break
		}

		return e.complexity.RouteGeometry.Length(childComplexity), true

	case "RouteGeometry.max_segment_length":
		if e.complexity.RouteGeometry.MaxSegmentLength == nil {
			break
		}

		return e.complexity.RouteGeometry.MaxSegmentLength(childComplexity), true

	case "RouteHeadway.departures":
		if e.complexity.RouteHeadway.Departures == nil {
			break
		}

		return e.complexity.RouteHeadway.Departures(childComplexity), true

	case "RouteHeadway.direction_id":
		if e.complexity.RouteHeadway.DirectionID == nil {
			break
		}

		return e.complexity.RouteHeadway.DirectionID(childComplexity), true

	case "RouteHeadway.dow_category":
		if e.complexity.RouteHeadway.DowCategory == nil {
			break
		}

		return e.complexity.RouteHeadway.DowCategory(childComplexity), true

	case "RouteHeadway.headway_secs":
		if e.complexity.RouteHeadway.HeadwaySecs == nil {
			break
		}

		return e.complexity.RouteHeadway.HeadwaySecs(childComplexity), true

	case "RouteHeadway.service_date":
		if e.complexity.RouteHeadway.ServiceDate == nil {
			break
		}

		return e.complexity.RouteHeadway.ServiceDate(childComplexity), true

	case "RouteHeadway.stop":
		if e.complexity.RouteHeadway.Stop == nil {
			break
		}

		return e.complexity.RouteHeadway.Stop(childComplexity), true

	case "RouteHeadway.stop_trip_count":
		if e.complexity.RouteHeadway.StopTripCount == nil {
			break
		}

		return e.complexity.RouteHeadway.StopTripCount(childComplexity), true

	case "RouteStop.agency":
		if e.complexity.RouteStop.Agency == nil {
			break
		}

		return e.complexity.RouteStop.Agency(childComplexity), true

	case "RouteStop.agency_id":
		if e.complexity.RouteStop.AgencyID == nil {
			break
		}

		return e.complexity.RouteStop.AgencyID(childComplexity), true

	case "RouteStop.id":
		if e.complexity.RouteStop.ID == nil {
			break
		}

		return e.complexity.RouteStop.ID(childComplexity), true

	case "RouteStop.route":
		if e.complexity.RouteStop.Route == nil {
			break
		}

		return e.complexity.RouteStop.Route(childComplexity), true

	case "RouteStop.route_id":
		if e.complexity.RouteStop.RouteID == nil {
			break
		}

		return e.complexity.RouteStop.RouteID(childComplexity), true

	case "RouteStop.stop":
		if e.complexity.RouteStop.Stop == nil {
			break
		}

		return e.complexity.RouteStop.Stop(childComplexity), true

	case "RouteStop.stop_id":
		if e.complexity.RouteStop.StopID == nil {
			break
		}

		return e.complexity.RouteStop.StopID(childComplexity), true

	case "RouteStopBuffer.stop_buffer":
		if e.complexity.RouteStopBuffer.StopBuffer == nil {
			break
		}

		return e.complexity.RouteStopBuffer.StopBuffer(childComplexity), true

	case "RouteStopBuffer.stop_convexhull":
		if e.complexity.RouteStopBuffer.StopConvexhull == nil {
			break
		}

		return e.complexity.RouteStopBuffer.StopConvexhull(childComplexity), true

	case "RouteStopBuffer.stop_points":
		if e.complexity.RouteStopBuffer.StopPoints == nil {
			break
		}

		return e.complexity.RouteStopBuffer.StopPoints(childComplexity), true

	case "RouteStopPattern.count":
		if e.complexity.RouteStopPattern.Count == nil {
			break
		}

		return e.complexity.RouteStopPattern.Count(childComplexity), true

	case "RouteStopPattern.direction_id":
		if e.complexity.RouteStopPattern.DirectionID == nil {
			break
		}

		return e.complexity.RouteStopPattern.DirectionID(childComplexity), true

	case "RouteStopPattern.stop_pattern_id":
		if e.complexity.RouteStopPattern.StopPatternID == nil {
			break
		}

		return e.complexity.RouteStopPattern.StopPatternID(childComplexity), true

	case "RouteStopPattern.trips":
		if e.complexity.RouteStopPattern.Trips == nil {
			break
		}

		args, err := ec.field_RouteStopPattern_trips_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.RouteStopPattern.Trips(childComplexity, args["limit"].(*int)), true

	case "Shape.generated":
		if e.complexity.Shape.Generated == nil {
			break
		}

		return e.complexity.Shape.Generated(childComplexity), true

	case "Shape.geometry":
		if e.complexity.Shape.Geometry == nil {
			break
		}

		return e.complexity.Shape.Geometry(childComplexity), true

	case "Shape.id":
		if e.complexity.Shape.ID == nil {
			break
		}

		return e.complexity.Shape.ID(childComplexity), true

	case "Shape.shape_id":
		if e.complexity.Shape.ShapeID == nil {
			break
		}

		return e.complexity.Shape.ShapeID(childComplexity), true

	case "Step.distance":
		if e.complexity.Step.Distance == nil {
			break
		}

		return e.complexity.Step.Distance(childComplexity), true

	case "Step.duration":
		if e.complexity.Step.Duration == nil {
			break
		}

		return e.complexity.Step.Duration(childComplexity), true

	case "Step.end_time":
		if e.complexity.Step.EndTime == nil {
			break
		}

		return e.complexity.Step.EndTime(childComplexity), true

	case "Step.geometry_offset":
		if e.complexity.Step.GeometryOffset == nil {
			break
		}

		return e.complexity.Step.GeometryOffset(childComplexity), true

	case "Step.instruction":
		if e.complexity.Step.Instruction == nil {
			break
		}

		return e.complexity.Step.Instruction(childComplexity), true

	case "Step.mode":
		if e.complexity.Step.Mode == nil {
			break
		}

		return e.complexity.Step.Mode(childComplexity), true

	case "Step.start_time":
		if e.complexity.Step.StartTime == nil {
			break
		}

		return e.complexity.Step.StartTime(childComplexity), true

	case "Step.to":
		if e.complexity.Step.To == nil {
			break
		}

		return e.complexity.Step.To(childComplexity), true

	case "Stop.alerts":
		if e.complexity.Stop.Alerts == nil {
			break
		}

		args, err := ec.field_Stop_alerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Stop.arrivals":
		if e.complexity.Stop.Arrivals == nil {
			break
		}

		args, err := ec.field_Stop_arrivals_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Arrivals(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "Stop.census_geographies":
		if e.complexity.Stop.CensusGeographies == nil {
			break
		}

		args, err := ec.field_Stop_census_geographies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.CensusGeographies(childComplexity, args["layer"].(string), args["radius"].(*float64), args["limit"].(*int)), true

	case "Stop.children":
		if e.complexity.Stop.Children == nil {
			break
		}

		args, err := ec.field_Stop_children_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Children(childComplexity, args["limit"].(*int)), true

	case "Stop.departures":
		if e.complexity.Stop.Departures == nil {
			break
		}

		args, err := ec.field_Stop_departures_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Departures(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "Stop.directions":
		if e.complexity.Stop.Directions == nil {
			break
		}

		args, err := ec.field_Stop_directions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Directions(childComplexity, args["to"].(*model.WaypointInput), args["from"].(*model.WaypointInput), args["mode"].(*model.StepMode), args["depart_at"].(*time.Time)), true

	case "Stop.external_reference":
		if e.complexity.Stop.ExternalReference == nil {
			break
		}

		return e.complexity.Stop.ExternalReference(childComplexity), true

	case "Stop.feed_onestop_id":
		if e.complexity.Stop.FeedOnestopID == nil {
			break
		}

		return e.complexity.Stop.FeedOnestopID(childComplexity), true

	case "Stop.feed_version":
		if e.complexity.Stop.FeedVersion == nil {
			break
		}

		return e.complexity.Stop.FeedVersion(childComplexity), true

	case "Stop.feed_version_sha1":
		if e.complexity.Stop.FeedVersionSHA1 == nil {
			break
		}

		return e.complexity.Stop.FeedVersionSHA1(childComplexity), true

	case "Stop.geometry":
		if e.complexity.Stop.Geometry == nil {
			break
		}

		return e.complexity.Stop.Geometry(childComplexity), true

	case "Stop.id":
		if e.complexity.Stop.ID == nil {
			break
		}

		return e.complexity.Stop.ID(childComplexity), true

	case "Stop.level":
		if e.complexity.Stop.Level == nil {
			break
		}

		return e.complexity.Stop.Level(childComplexity), true

	case "Stop.location_type":
		if e.complexity.Stop.LocationType == nil {
			break
		}

		return e.complexity.Stop.LocationType(childComplexity), true

	case "Stop.nearby_stops":
		if e.complexity.Stop.NearbyStops == nil {
			break
		}

		args, err := ec.field_Stop_nearby_stops_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.NearbyStops(childComplexity, args["limit"].(*int), args["radius"].(*float64)), true

	case "Stop.observations":
		if e.complexity.Stop.Observations == nil {
			break
		}

		args, err := ec.field_Stop_observations_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.Observations(childComplexity, args["limit"].(*int), args["where"].(*model.StopObservationFilter)), true

	case "Stop.onestop_id":
		if e.complexity.Stop.OnestopID == nil {
			break
		}

		return e.complexity.Stop.OnestopID(childComplexity), true

	case "Stop.parent":
		if e.complexity.Stop.Parent == nil {
			break
		}

		return e.complexity.Stop.Parent(childComplexity), true

	case "Stop.pathways_from_stop":
		if e.complexity.Stop.PathwaysFromStop == nil {
			break
		}

		args, err := ec.field_Stop_pathways_from_stop_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.PathwaysFromStop(childComplexity, args["limit"].(*int)), true

	case "Stop.pathways_to_stop":
		if e.complexity.Stop.PathwaysToStop == nil {
			break
		}

		args, err := ec.field_Stop_pathways_to_stop_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.PathwaysToStop(childComplexity, args["limit"].(*int)), true

	case "Stop.platform_code":
		if e.complexity.Stop.PlatformCode == nil {
			break
		}

		return e.complexity.Stop.PlatformCode(childComplexity), true

	case "Stop.route_stops":
		if e.complexity.Stop.RouteStops == nil {
			break
		}

		args, err := ec.field_Stop_route_stops_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.RouteStops(childComplexity, args["limit"].(*int)), true

	case "Stop.search_rank":
		if e.complexity.Stop.SearchRank == nil {
			break
		}

		return e.complexity.Stop.SearchRank(childComplexity), true

	case "Stop.stop_code":
		if e.complexity.Stop.StopCode == nil {
			break
		}

		return e.complexity.Stop.StopCode(childComplexity), true

	case "Stop.stop_desc":
		if e.complexity.Stop.StopDesc == nil {
			break
		}

		return e.complexity.Stop.StopDesc(childComplexity), true

	case "Stop.stop_id":
		if e.complexity.Stop.StopID == nil {
			break
		}

		return e.complexity.Stop.StopID(childComplexity), true

	case "Stop.stop_name":
		if e.complexity.Stop.StopName == nil {
			break
		}

		return e.complexity.Stop.StopName(childComplexity), true

	case "Stop.stop_times":
		if e.complexity.Stop.StopTimes == nil {
			break
		}

		args, err := ec.field_Stop_stop_times_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Stop.StopTimes(childComplexity, args["limit"].(*int), args["where"].(*model.StopTimeFilter)), true

	case "Stop.stop_timezone":
		if e.complexity.Stop.StopTimezone == nil {
			break
		}

		return e.complexity.Stop.StopTimezone(childComplexity), true

	case "Stop.stop_url":
		if e.complexity.Stop.StopURL == nil {
			break
		}

		return e.complexity.Stop.StopURL(childComplexity), true

	case "Stop.tts_stop_name":
		if e.complexity.Stop.TtsStopName == nil {
			break
		}

		return e.complexity.Stop.TtsStopName(childComplexity), true

	case "Stop.wheelchair_boarding":
		if e.complexity.Stop.WheelchairBoarding == nil {
			break
		}

		return e.complexity.Stop.WheelchairBoarding(childComplexity), true

	case "Stop.zone_id":
		if e.complexity.Stop.ZoneID == nil {
			break
		}

		return e.complexity.Stop.ZoneID(childComplexity), true

	case "StopExternalReference.id":
		if e.complexity.StopExternalReference.ID == nil {
			break
		}

		return e.complexity.StopExternalReference.ID(childComplexity), true

	case "StopExternalReference.inactive":
		if e.complexity.StopExternalReference.Inactive == nil {
			break
		}

		return e.complexity.StopExternalReference.Inactive(childComplexity), true

	case "StopExternalReference.target_active_stop":
		if e.complexity.StopExternalReference.TargetActiveStop == nil {
			break
		}

		return e.complexity.StopExternalReference.TargetActiveStop(childComplexity), true

	case "StopExternalReference.target_feed_onestop_id":
		if e.complexity.StopExternalReference.TargetFeedOnestopID == nil {
			break
		}

		return e.complexity.StopExternalReference.TargetFeedOnestopID(childComplexity), true

	case "StopExternalReference.target_stop_id":
		if e.complexity.StopExternalReference.TargetStopID == nil {
			break
		}

		return e.complexity.StopExternalReference.TargetStopID(childComplexity), true

	case "StopObservation.agency_id":
		if e.complexity.StopObservation.AgencyID == nil {
			break
		}

		return e.complexity.StopObservation.AgencyID(childComplexity), true

	case "StopObservation.from_stop_id":
		if e.complexity.StopObservation.FromStopID == nil {
			break
		}

		return e.complexity.StopObservation.FromStopID(childComplexity), true

	case "StopObservation.observed_arrival_time":
		if e.complexity.StopObservation.ObservedArrivalTime == nil {
			break
		}

		return e.complexity.StopObservation.ObservedArrivalTime(childComplexity), true

	case "StopObservation.observed_departure_time":
		if e.complexity.StopObservation.ObservedDepartureTime == nil {
			break
		}

		return e.complexity.StopObservation.ObservedDepartureTime(childComplexity), true

	case "StopObservation.route_id":
		if e.complexity.StopObservation.RouteID == nil {
			break
		}

		return e.complexity.StopObservation.RouteID(childComplexity), true

	case "StopObservation.schedule_relationship":
		if e.complexity.StopObservation.ScheduleRelationship == nil {
			break
		}

		return e.complexity.StopObservation.ScheduleRelationship(childComplexity), true

	case "StopObservation.scheduled_arrival_time":
		if e.complexity.StopObservation.ScheduledArrivalTime == nil {
			break
		}

		return e.complexity.StopObservation.ScheduledArrivalTime(childComplexity), true

	case "StopObservation.scheduled_departure_time":
		if e.complexity.StopObservation.ScheduledDepartureTime == nil {
			break
		}

		return e.complexity.StopObservation.ScheduledDepartureTime(childComplexity), true

	case "StopObservation.source":
		if e.complexity.StopObservation.Source == nil {
			break
		}

		return e.complexity.StopObservation.Source(childComplexity), true

	case "StopObservation.stop_sequence":
		if e.complexity.StopObservation.StopSequence == nil {
			break
		}

		return e.complexity.StopObservation.StopSequence(childComplexity), true

	case "StopObservation.to_stop_id":
		if e.complexity.StopObservation.ToStopID == nil {
			break
		}

		return e.complexity.StopObservation.ToStopID(childComplexity), true

	case "StopObservation.trip_id":
		if e.complexity.StopObservation.TripID == nil {
			break
		}

		return e.complexity.StopObservation.TripID(childComplexity), true

	case "StopObservation.trip_start_date":
		if e.complexity.StopObservation.TripStartDate == nil {
			break
		}

		return e.complexity.StopObservation.TripStartDate(childComplexity), true

	case "StopObservation.trip_start_time":
		if e.complexity.StopObservation.TripStartTime == nil {
			break
		}

		return e.complexity.StopObservation.TripStartTime(childComplexity), true

	case "StopTime.arrival":
		if e.complexity.StopTime.Arrival == nil {
			break
		}

		return e.complexity.StopTime.Arrival(childComplexity), true

	case "StopTime.arrival_time":
		if e.complexity.StopTime.ArrivalTime == nil {
			break
		}

		return e.complexity.StopTime.ArrivalTime(childComplexity), true

	case "StopTime.continuous_drop_off":
		if e.complexity.StopTime.ContinuousDropOff == nil {
			break
		}

		return e.complexity.StopTime.ContinuousDropOff(childComplexity), true

	case "StopTime.continuous_pickup":
		if e.complexity.StopTime.ContinuousPickup == nil {
			break
		}

		return e.complexity.StopTime.ContinuousPickup(childComplexity), true

	case "StopTime.departure":
		if e.complexity.StopTime.Departure == nil {
			break
		}

		return e.complexity.StopTime.Departure(childComplexity), true

	case "StopTime.departure_time":
		if e.complexity.StopTime.DepartureTime == nil {
			break
		}

		return e.complexity.StopTime.DepartureTime(childComplexity), true

	case "StopTime.drop_off_type":
		if e.complexity.StopTime.DropOffType == nil {
			break
		}

		return e.complexity.StopTime.DropOffType(childComplexity), true

	case "StopTime.interpolated":
		if e.complexity.StopTime.Interpolated == nil {
			break
		}

		return e.complexity.StopTime.Interpolated(childComplexity), true

	case "StopTime.pickup_type":
		if e.complexity.StopTime.PickupType == nil {
			break
		}

		return e.complexity.StopTime.PickupType(childComplexity), true

	case "StopTime.service_date":
		if e.complexity.StopTime.ServiceDate == nil {
			break
		}

		return e.complexity.StopTime.ServiceDate(childComplexity), true

	case "StopTime.shape_dist_traveled":
		if e.complexity.StopTime.ShapeDistTraveled == nil {
			break
		}

		return e.complexity.StopTime.ShapeDistTraveled(childComplexity), true

	case "StopTime.stop":
		if e.complexity.StopTime.Stop == nil {
			break
		}

		return e.complexity.StopTime.Stop(childComplexity), true

	case "StopTime.stop_headsign":
		if e.complexity.StopTime.StopHeadsign == nil {
			break
		}

		return e.complexity.StopTime.StopHeadsign(childComplexity), true

	case "StopTime.stop_sequence":
		if e.complexity.StopTime.StopSequence == nil {
			break
		}

		return e.complexity.StopTime.StopSequence(childComplexity), true

	case "StopTime.timepoint":
		if e.complexity.StopTime.Timepoint == nil {
			break
		}

		return e.complexity.StopTime.Timepoint(childComplexity), true

	case "StopTime.trip":
		if e.complexity.StopTime.Trip == nil {
			break
		}

		return e.complexity.StopTime.Trip(childComplexity), true

	case "StopTimeEvent.delay":
		if e.complexity.StopTimeEvent.Delay == nil {
			break
		}

		return e.complexity.StopTimeEvent.Delay(childComplexity), true

	case "StopTimeEvent.estimated":
		if e.complexity.StopTimeEvent.Estimated == nil {
			break
		}

		return e.complexity.StopTimeEvent.Estimated(childComplexity), true

	case "StopTimeEvent.estimated_utc":
		if e.complexity.StopTimeEvent.EstimatedUtc == nil {
			break
		}

		return e.complexity.StopTimeEvent.EstimatedUtc(childComplexity), true

	case "StopTimeEvent.scheduled":
		if e.complexity.StopTimeEvent.Scheduled == nil {
			break
		}

		return e.complexity.StopTimeEvent.Scheduled(childComplexity), true

	case "StopTimeEvent.stop_timezone":
		if e.complexity.StopTimeEvent.StopTimezone == nil {
			break
		}

		return e.complexity.StopTimeEvent.StopTimezone(childComplexity), true

	case "StopTimeEvent.uncertainty":
		if e.complexity.StopTimeEvent.Uncertainty == nil {
			break
		}

		return e.complexity.StopTimeEvent.Uncertainty(childComplexity), true

	case "Trip.alerts":
		if e.complexity.Trip.Alerts == nil {
			break
		}

		args, err := ec.field_Trip_alerts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trip.Alerts(childComplexity, args["active"].(*bool), args["limit"].(*int)), true

	case "Trip.bikes_allowed":
		if e.complexity.Trip.BikesAllowed == nil {
			break
		}

		return e.complexity.Trip.BikesAllowed(childComplexity), true

	case "Trip.block_id":
		if e.complexity.Trip.BlockID == nil {
			break
		}

		return e.complexity.Trip.BlockID(childComplexity), true

	case "Trip.calendar":
		if e.complexity.Trip.Calendar == nil {
			break
		}

		return e.complexity.Trip.Calendar(childComplexity), true

	case "Trip.direction_id":
		if e.complexity.Trip.DirectionID == nil {
			break
		}

		return e.complexity.Trip.DirectionID(childComplexity), true

	case "Trip.feed_version":
		if e.complexity.Trip.FeedVersion == nil {
			break
		}

		return e.complexity.Trip.FeedVersion(childComplexity), true

	case "Trip.frequencies":
		if e.complexity.Trip.Frequencies == nil {
			break
		}

		args, err := ec.field_Trip_frequencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trip.Frequencies(childComplexity, args["limit"].(*int)), true

	case "Trip.id":
		if e.complexity.Trip.ID == nil {
			break
		}

		return e.complexity.Trip.ID(childComplexity), true

	case "Trip.route":
		if e.complexity.Trip.Route == nil {
			break
		}

		return e.complexity.Trip.Route(childComplexity), true

	case "Trip.schedule_relationship":
		if e.complexity.Trip.ScheduleRelationship == nil {
			break
		}

		return e.complexity.Trip.ScheduleRelationship(childComplexity), true

	case "Trip.shape":
		if e.complexity.Trip.Shape == nil {
			break
		}

		return e.complexity.Trip.Shape(childComplexity), true

	case "Trip.stop_pattern_id":
		if e.complexity.Trip.StopPatternID == nil {
			break
		}

		return e.complexity.Trip.StopPatternID(childComplexity), true

	case "Trip.stop_times":
		if e.complexity.Trip.StopTimes == nil {
			break
		}

		args, err := ec.field_Trip_stop_times_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Trip.StopTimes(childComplexity, args["limit"].(*int), args["where"].(*model.TripStopTimeFilter)), true

	case "Trip.timestamp":
		if e.complexity.Trip.Timestamp == nil {
			break
		}

		return e.complexity.Trip.Timestamp(childComplexity), true

	case "Trip.trip_headsign":
		if e.complexity.Trip.TripHeadsign == nil {
			break
		}

		return e.complexity.Trip.TripHeadsign(childComplexity), true

	case "Trip.trip_id":
		if e.complexity.Trip.TripID == nil {
			break
		}

		return e.complexity.Trip.TripID(childComplexity), true

	case "Trip.trip_short_name":
		if e.complexity.Trip.TripShortName == nil {
			break
		}

		return e.complexity.Trip.TripShortName(childComplexity), true

	case "Trip.wheelchair_accessible":
		if e.complexity.Trip.WheelchairAccessible == nil {
			break
		}

		return e.complexity.Trip.WheelchairAccessible(childComplexity), true

	case "ValidationResult.agencies":
		if e.complexity.ValidationResult.Agencies == nil {
			break
		}

		args, err := ec.field_ValidationResult_agencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationResult.Agencies(childComplexity, args["limit"].(*int)), true

	case "ValidationResult.earliest_calendar_date":
		if e.complexity.ValidationResult.EarliestCalendarDate == nil {
			break
		}

		return e.complexity.ValidationResult.EarliestCalendarDate(childComplexity), true

	case "ValidationResult.errors":
		if e.complexity.ValidationResult.Errors == nil {
			break
		}

		return e.complexity.ValidationResult.Errors(childComplexity), true

	case "ValidationResult.failure_reason":
		if e.complexity.ValidationResult.FailureReason == nil {
			break
		}

		return e.complexity.ValidationResult.FailureReason(childComplexity), true

	case "ValidationResult.feed_infos":
		if e.complexity.ValidationResult.FeedInfos == nil {
			break
		}

		args, err := ec.field_ValidationResult_feed_infos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationResult.FeedInfos(childComplexity, args["limit"].(*int)), true

	case "ValidationResult.files":
		if e.complexity.ValidationResult.Files == nil {
			break
		}

		return e.complexity.ValidationResult.Files(childComplexity), true

	case "ValidationResult.latest_calendar_date":
		if e.complexity.ValidationResult.LatestCalendarDate == nil {
			break
		}

		return e.complexity.ValidationResult.LatestCalendarDate(childComplexity), true

	case "ValidationResult.routes":
		if e.complexity.ValidationResult.Routes == nil {
			break
		}

		args, err := ec.field_ValidationResult_routes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationResult.Routes(childComplexity, args["limit"].(*int)), true

	case "ValidationResult.service_levels":
		if e.complexity.ValidationResult.ServiceLevels == nil {
			break
		}

		args, err := ec.field_ValidationResult_service_levels_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationResult.ServiceLevels(childComplexity, args["limit"].(*int), args["route_id"].(*string)), true

	case "ValidationResult.sha1":
		if e.complexity.ValidationResult.Sha1 == nil {
			break
		}

		return e.complexity.ValidationResult.Sha1(childComplexity), true

	case "ValidationResult.stops":
		if e.complexity.ValidationResult.Stops == nil {
			break
		}

		args, err := ec.field_ValidationResult_stops_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.ValidationResult.Stops(childComplexity, args["limit"].(*int)), true

	case "ValidationResult.success":
		if e.complexity.ValidationResult.Success == nil {
			break
		}

		return e.complexity.ValidationResult.Success(childComplexity), true

	case "ValidationResult.warnings":
		if e.complexity.ValidationResult.Warnings == nil {
			break
		}

		return e.complexity.ValidationResult.Warnings(childComplexity), true

	case "ValidationResultError.entity_id":
		if e.complexity.ValidationResultError.EntityID == nil {
			break
		}

		return e.complexity.ValidationResultError.EntityID(childComplexity), true

	case "ValidationResultError.error_type":
		if e.complexity.ValidationResultError.ErrorType == nil {
			break
		}

		return e.complexity.ValidationResultError.ErrorType(childComplexity), true

	case "ValidationResultError.field":
		if e.complexity.ValidationResultError.Field == nil {
			break
		}

		return e.complexity.ValidationResultError.Field(childComplexity), true

	case "ValidationResultError.filename":
		if e.complexity.ValidationResultError.Filename == nil {
			break
		}

		return e.complexity.ValidationResultError.Filename(childComplexity), true

	case "ValidationResultError.message":
		if e.complexity.ValidationResultError.Message == nil {
			break
		}

		return e.complexity.ValidationResultError.Message(childComplexity), true

	case "ValidationResultError.value":
		if e.complexity.ValidationResultError.Value == nil {
			break
		}

		return e.complexity.ValidationResultError.Value(childComplexity), true

	case "ValidationResultErrorGroup.count":
		if e.complexity.ValidationResultErrorGroup.Count == nil {
			break
		}

		return e.complexity.ValidationResultErrorGroup.Count(childComplexity), true

	case "ValidationResultErrorGroup.error_type":
		if e.complexity.ValidationResultErrorGroup.ErrorType == nil {
			break
		}

		return e.complexity.ValidationResultErrorGroup.ErrorType(childComplexity), true

	case "ValidationResultErrorGroup.errors":
		if e.complexity.ValidationResultErrorGroup.Errors == nil {
			break
		}

		return e.complexity.ValidationResultErrorGroup.Errors(childComplexity), true

	case "ValidationResultErrorGroup.filename":
		if e.complexity.ValidationResultErrorGroup.Filename == nil {
			break
		}

		return e.complexity.ValidationResultErrorGroup.Filename(childComplexity), true

	case "ValidationResultErrorGroup.limit":
		if e.complexity.ValidationResultErrorGroup.Limit == nil {
			break
		}

		return e.complexity.ValidationResultErrorGroup.Limit(childComplexity), true

	case "VehiclePosition.congestion_level":
		if e.complexity.VehiclePosition.CongestionLevel == nil {
			break
		}

		return e.complexity.VehiclePosition.CongestionLevel(childComplexity), true

	case "VehiclePosition.current_status":
		if e.complexity.VehiclePosition.CurrentStatus == nil {
			break
		}

		return e.complexity.VehiclePosition.CurrentStatus(childComplexity), true

	case "VehiclePosition.current_stop_sequence":
		if e.complexity.VehiclePosition.CurrentStopSequence == nil {
			break
		}

		return e.complexity.VehiclePosition.CurrentStopSequence(childComplexity), true

	case "VehiclePosition.position":
		if e.complexity.VehiclePosition.Position == nil {
			break
		}

		return e.complexity.VehiclePosition.Position(childComplexity), true

	case "VehiclePosition.stop_id":
		if e.complexity.VehiclePosition.StopID == nil {
			break
		}

		return e.complexity.VehiclePosition.StopID(childComplexity), true

	case "VehiclePosition.timestamp":
		if e.complexity.VehiclePosition.Timestamp == nil {
			break
		}

		return e.complexity.VehiclePosition.Timestamp(childComplexity), true

	case "VehiclePosition.vehicle":
		if e.complexity.VehiclePosition.Vehicle == nil {
			break
		}

		return e.complexity.VehiclePosition.Vehicle(childComplexity), true

	case "Waypoint.lat":
		if e.complexity.Waypoint.Lat == nil {
			break
		}

		return e.complexity.Waypoint.Lat(childComplexity), true

	case "Waypoint.lon":
		if e.complexity.Waypoint.Lon == nil {
			break
		}

		return e.complexity.Waypoint.Lon(childComplexity), true

	case "Waypoint.name":
		if e.complexity.Waypoint.Name == nil {
			break
		}

		return e.complexity.Waypoint.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAgencyFilter,
		ec.unmarshalInputAgencyPlaceFilter,
		ec.unmarshalInputCalendarDateFilter,
		ec.unmarshalInputDirectionRequest,
		ec.unmarshalInputFeedFetchFilter,
		ec.unmarshalInputFeedFilter,
		ec.unmarshalInputFeedSourceUrl,
		ec.unmarshalInputFeedVersionFilter,
		ec.unmarshalInputFeedVersionServiceLevelFilter,
		ec.unmarshalInputFeedVersionSetInput,
		ec.unmarshalInputGbfsBikeRequest,
		ec.unmarshalInputGbfsDockRequest,
		ec.unmarshalInputLicenseFilter,
		ec.unmarshalInputOperatorFilter,
		ec.unmarshalInputPathwayFilter,
		ec.unmarshalInputPlaceFilter,
		ec.unmarshalInputPointRadius,
		ec.unmarshalInputRouteFilter,
		ec.unmarshalInputStopFilter,
		ec.unmarshalInputStopObservationFilter,
		ec.unmarshalInputStopTimeFilter,
		ec.unmarshalInputTripFilter,
		ec.unmarshalInputTripStopTimeFilter,
		ec.unmarshalInputWaypointInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../schema/directions.graphqls", Input: `# Directions API

input DirectionRequest {
  to: WaypointInput!
  from: WaypointInput!
  mode: StepMode!
  depart_at: Time
}

input WaypointInput {
  lon: Float!
  lat: Float!
  name: String
}

type Waypoint {
  lon: Float!
  lat: Float!
  name: String
}

type Directions {
  # metadata
  success: Boolean!
  exception: String
  data_source: String
  # input
  origin: Waypoint
  destination: Waypoint
  # first itin summary
  duration: Duration
  distance: Distance
  start_time: Time
  end_time: Time
  # itineraries
  itineraries: [Itinerary!]
}

type Itinerary {
  duration: Duration!
  distance: Distance!
  start_time: Time!
  end_time: Time!
  from: Waypoint!
  to: Waypoint!
  legs: [Leg!]
}

type Leg {
  duration: Duration!
  distance: Distance!
  start_time: Time!
  end_time: Time!
  from: Waypoint
  to: Waypoint
  steps: [Step!]
  geometry: LineString!
}

type Step {
  duration: Duration!
  distance: Distance!
  start_time: Time!
  end_time: Time!
  to: Waypoint
  mode: StepMode!
  instruction: String!
  geometry_offset: Int!
}

type Distance {
  distance: Float!
  units: DistanceUnit!
}

type Duration {
  duration: Float!
  units: DurationUnit!
}

enum DurationUnit {
  SECONDS
}

enum DistanceUnit {
  KILOMETERS
  MILES
}

enum StepMode {
  WALK
  AUTO
  BICYCLE
  TRANSIT
  LINE
}
`, BuiltIn: false},
	{Name: "../../schema/gbfs.graphqls", Input: `# GBFS

type GbfsFeed {
	system_information:  GbfsSystemInformation
	station_information: [GbfsStationInformation!]
	rental_hours:  [GbfsSystemHour!]
	calendars: [GbfsSystemCalendar!]
	alerts: [GbfsSystemAlert!]
}

type GbfsSystemInformation  {
  system_id: String
  language: String
  name: String
  short_name: String
  operator: String
  url: String
  purchase_url: String
  start_date: Date
  phone_number: String
  email: String
  feed_contact_email: String
  timezone: String
  license_url: String
  terms_url: String
  terms_last_updated: Date
  privacy_url: String
  privacy_last_updated: Date
  brand_assets: GbfsBrandAsset
  rental_apps: GbfsRentalApps
}

type GbfsRentalApps {
	ios: GbfsRentalApp
	android: GbfsRentalApp
}

type GbfsRentalApp {
	store_uri: String
	discovery_uri: String
}

type GbfsBrandAsset {
	brand_last_modified: Date
	brand_terms_url: String
	brand_image_url: String
	brand_image_url_dark: String
	color: String
}

type GbfsStationInformation {
	station_id: String
	name: String
	short_name: String
	lat: Float
	lon: Float
	address: String
	cross_street: String
	post_code: String
	rental_methods: Strings
	is_virtual_station: Bool
	station_area: Geometry
	parking_type: String
	parking_hoop: Int
	contact_phone: String
	capacity: Int
	is_valet_station: Bool
	is_charging_station: Bool
	# vehicle_capacity: map[string]int
	feed: GbfsFeed
	region: GbfsSystemRegion
	status: GbfsStationStatus
}

type GbfsStationStatus  {
	station_id: String                
	num_bikes_available: Int                
	num_bikes_disabled: Int                
	num_docks_available: Int                
	num_docks_disabled:  Int                
	is_returning: Bool               
	is_renting: Bool               
	is_installed: Bool               
	last_reported: Int               
	vehicle_types_available: [GbfsVehicleTypeAvailable!]
	vehicle_docks_available: [GbfsVehicleDockAvailable!]
}

type GbfsVehicleTypeAvailable  {
	num_bikes_disabled: Int 
	num_docks_available: Int 
	count: Int 
	vehicle_type: GbfsVehicleType
}

type GbfsVehicleDockAvailable  {
	count: Int     
	vehicle_types: [GbfsVehicleType!]
}

type GbfsSystemVersion  {
	version: String 
	url: String 
}

type GbfsVehicleType  {
	vehicle_type_id: String     
	form_factor: String  
	rider_capacity: Int     
	cargo_volume_capacity: Int     
	cargo_load_capacity: Int     
	propulsion_type: String  
	eco_label: String  
	country_code: String  
	eco_sticker: String  
	max_range_meters: Float   
	name: String  
	vehicle_accessories: Strings
	gco_2_km: Int     
	vehicle_image: String  
	make: String  
	model: String  
	color: String  
	wheel_count: Int     
	max_permitted_speed: Int     
	rated_power: Int     
	default_reserve_time: Int     
	return_constraint: String  
	default_pricing_plan: GbfsSystemPricingPlan
	pricing_plans: [GbfsSystemPricingPlan!]
	rental_uris: GbfsRentalUris
	vehicle_assets: GbfsVehicleAssets
}

type GbfsVehicleAssets {
	icon_url: String
	icon_url_dark: String
	icon_last_modified: Date
}

type GbfsFreeBikeStatus {
	bike_id: String
	lat: Float   
	lon: Float   
	is_reserved: Bool    
	is_disabled: Bool    
	last_reported: Int
	current_range_meters: Float   
	current_fuel_percent: Float   
	vehicle_equipment: Strings
	available_until: Int    
	station: GbfsStationInformation    
	home_station: GbfsStationInformation    
	pricing_plan: GbfsSystemPricingPlan
	vehicle_type: GbfsVehicleType
	rental_uris: GbfsRentalUris
	feed: GbfsFeed
}

type GbfsRentalUris {
	android: String
	ios: String
	web: String
}

type GbfsSystemHour  {
	user_types: Strings 
	days: Strings
	start_time: String  
	end_time: String  
}

type GbfsSystemCalendar  {
	start_month: Int 
	start_day: Int 
	start_year: Int 
	end_month: Int 
	end_day: Int 
	end_year: Int 
}

type GbfsSystemRegion  {
	region_id: String    
	name: String 
}

type GbfsSystemPricingPlan  {
	plan_id: String      
	url: String   
	name: String   
	currency: String   
	price: Float    
	is_taxable: Bool     
	description: String   
	surge_pricing: Bool     
	per_km_pricing: [GbfsPlanPrice!] 
	per_min_pricing: [GbfsPlanPrice!]
}

type GbfsPlanPrice  {
	start: Int 
	rate: Float
	interval: Int 
	end: Int 
}

type GbfsSystemAlert  {
	alert_id: String      
	type: String   
	url: String   
	summary: String   
	description: String   
	last_updated: Int     
	# station_ids: Strings
	# region_ids: Strings
	times: [GbfsAlertTime!]
}

type GbfsAlertTime  {
	start: Int
	end: Int
}

type GbfsGeofenceZone  {
	type:     String
	features: [GbfsGeofenceFeature!]
}

type GbfsGeofenceFeature  {
	type: String           
	geometry: Geometry         
	# properties: map[string]GbfsGeofenceProperty 
}

type GbfsGeofenceProperty  {
	name: String      
	start: Int        
	end: Int        
	rules: [GbfsGeofenceRule]
}

type GbfsGeofenceRule  {
	ride_allowed: Bool    
	ride_through_allowed: Bool    
	maximum_speed_kph: Int     
	station_parking: Bool    
	vehicle_type: GbfsVehicleType
}

########

input GbfsBikeRequest {
	near: PointRadius
}

input GbfsDockRequest {
	near: PointRadius
}
`, BuiltIn: false},
	{Name: "../../schema/input.graphqls", Input: `
# Update inputs

input FeedVersionSetInput {
  name: String
  description: String
}

# Query filters

input OperatorFilter {
  merged: Boolean
  onestop_id: String
  feed_onestop_id: String
  agency_id: String
  search: String
  tags: Tags
  city_name: String
  adm0_name: String
  adm1_name: String
  adm0_iso: String
  adm1_iso: String
  license: LicenseFilter
}

input FeedVersionFilter {
  import_status: ImportStatus
  feed_onestop_id: String
  sha1: String
  file: String
  feed_ids: [Int!]
}

enum ImportStatus {
  SUCCESS
  ERROR
  IN_PROGRESS
}

enum LicenseValue {
  YES
  NO
  EXCLUDE_NO
  UNKNOWN
}

input FeedFilter {
  "Search for feed with a specific Onestop ID"
  onestop_id: String
  "Search for feeds of certain data types"
  spec: [FeedSpecTypes!]
  "Search for feeds with or without a fetch error"
  fetch_error: Boolean
  "Search for feeds by their import status"
  import_status: ImportStatus
  "Full text search"
  search: String
  "Search for feeds with a tag"
  tags: Tags,
  "Search for feeds by their source URLs"
  source_url: FeedSourceUrl
  license: LicenseFilter
}

input FeedFetchFilter {
  success: Boolean
}

input FeedSourceUrl {
  url: String
  type: FeedSourceUrlTypes
  case_sensitive: Boolean
}

enum FeedSourceUrlTypes {
  static_current
  static_historic
  static_planned
  static_hypothetical
  realtime_vehicle_positions
  realtime_trip_updates
  realtime_alerts
  gbfs_auto_discovery
  mds_provider
}

"""
Type of data contained in a source feed
"""
enum FeedSpecTypes {
  GTFS
  GTFS_RT
  GBFS
  MDS
}

input AgencyFilter {
  onestop_id: String
  feed_version_sha1: String
  feed_onestop_id: String
  agency_id: String
  "Search for records with this GTFS agency_name"
  agency_name: String
  within: Polygon
  "Search for agencies within a radius"
  near: PointRadius
  "Full text search"
  search: String
  "Search by city name (provided by Natural Earth)"
  city_name: String
  "Search by country name (provided by Natural Earth)"
  adm0_name: String
  "Search by state/province/division name (provided by Natural Earth)"
  adm1_name: String
  "Search by country 2 letter ISO 3166 code (provided by Natural Earth)"
  adm0_iso: String
  "Search by state/province/division ISO 3166-2 code (provided by Natural Earth)"
  adm1_iso: String
  license: LicenseFilter
}

input RouteFilter {
  onestop_id: String
  onestop_ids: [String!]
  allow_previous_onestop_ids: Boolean
  feed_version_sha1: String
  feed_onestop_id: String
  route_id: String
  route_type: Int
  within: Polygon
  near: PointRadius
  search: String
  operator_onestop_id: String
  license: LicenseFilter
  agency_ids: [Int!] # keep?
}

input StopFilter {
  onestop_id: String
  onestop_ids: [String!]
  allow_previous_onestop_ids: Boolean
  feed_version_sha1: String
  feed_onestop_id: String
  stop_id: String
  stop_code: String
  location_type: Int
  within: Polygon
  near: PointRadius
  search: String
  license: LicenseFilter
  served_by_onestop_ids: [String!]
  agency_ids: [Int!] # keep?
}

input StopTimeFilter {
  service_date: Date
  use_service_window: Boolean
  start_time: Int
  end_time: Int
  start: Seconds
  end: Seconds
  next: Int
  route_onestop_ids: [String!] # keep?
  allow_previous_route_onestop_ids: Boolean
  exclude_first: Boolean
  exclude_last: Boolean
}

input TripStopTimeFilter {
  start: Seconds
  end: Seconds
}

input StopObservationFilter {
  source: String!
  feed_version_id: Int!
  trip_start_date: Date!
}

input PathwayFilter {
  pathway_mode: Int
}

input TripFilter {
  service_date: Date
  trip_id: String
  stop_pattern_id: Int
  license: LicenseFilter
  route_ids: [Int!] # keep?
  route_onestop_ids: [String!] # keep?
  feed_version_sha1: String
  feed_onestop_id: String
}


input LicenseFilter {
  share_alike_optional: LicenseValue
  create_derived_product: LicenseValue
  commercial_use_allowed: LicenseValue
  use_without_attribution: LicenseValue
  redistribution_allowed: LicenseValue
}

input FeedVersionServiceLevelFilter {
  start_date: Date
  end_date: Date
}

input AgencyPlaceFilter {
  min_rank: Float
}

input PlaceFilter {
  min_rank: Float
  adm0_name: String
  adm1_name: String
  city_name: String
}

input CalendarDateFilter {
  date: Date
  exception_type: Int
}

input PointRadius {
  lat: Float!
  lon: Float!
  radius: Float!
}
`, BuiltIn: false},
	{Name: "../../schema/schema.graphqls", Input: `# Scalar types
scalar Tags
scalar Geometry
scalar Time
scalar Date
scalar Point
scalar LineString
scalar Seconds
scalar Polygon
scalar Map
scalar Any
scalar Upload
scalar Key
scalar Bool
scalar Strings

# Roles
directive @hasRole(role: Role!) on FIELD_DEFINITION
enum Role {
  ANON
  ADMIN
  USER
}

# Force resolver
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Root query and mutation

type Query {
  feed_versions(limit: Int, after: Int, ids: [Int!], where: FeedVersionFilter): [FeedVersion!]!
  feeds(limit: Int, after: Int, ids: [Int!], where: FeedFilter): [Feed!]!
  agencies(limit: Int, after: Int, ids: [Int!], where: AgencyFilter): [Agency!]!
  routes(limit: Int, after: Int, ids: [Int!], where: RouteFilter): [Route!]!
  stops(limit: Int, after: Int, ids: [Int!], where: StopFilter): [Stop!]!
  trips(limit: Int, after: Int, ids: [Int!], where: TripFilter): [Trip!]!
  operators(limit: Int, after: Int, ids: [Int!], where: OperatorFilter): [Operator!]!
  directions(where: DirectionRequest!): Directions!
  bikes(limit: Int, where: GbfsBikeRequest): [GbfsFreeBikeStatus!]
  docks(limit: Int, where: GbfsDockRequest): [GbfsStationInformation!]
  places(limit: Int,after: Int, level: PlaceAggregationLevel, where: PlaceFilter): [Place!]
}

type Mutation {
    validate_gtfs(file: Upload, url: String, realtime_urls: [String!]): ValidationResult @hasRole(role: USER)
    feed_version_update(id: Int!, set: FeedVersionSetInput!): FeedVersion @hasRole(role: ADMIN)
    feed_version_fetch(file: Upload, url: String, feed_onestop_id: String!): FeedVersionFetchResult @hasRole(role: ADMIN)
    feed_version_import(sha1: String!): FeedVersionImportResult! @hasRole(role: ADMIN)
    feed_version_unimport(id: Int!): FeedVersionUnimportResult! @hasRole(role: ADMIN)
    feed_version_delete(id: Int!): FeedVersionDeleteResult! @hasRole(role: ADMIN)
}

"""
Feeds contain details on how to access transit information, including URLs to data sources in various formats (GTFS, GTFS-RT, GBFS, etc), license information, related feeds, details on how to make authorized requests, and feed version archives. Feed versions are archived (as ` + "`" + `.zip` + "`" + ` files) and imported into the Transitland database for querying agencies, stops, routes, trips, etc.
"""
type Feed {
  "Unique integer ID"
  id: Int!
  "Onestop ID for this feed"
  onestop_id: String!
  "A common name for this feed. Optional. Alternatively use ` + "`" + `associated_operators[].name` + "`" + `"
  name: String
  file: String!
  spec: FeedSpecTypes
  "Language(s) included in this feed"
  languages: [String!]
  tags: Tags
  authorization: FeedAuthorization
  urls: FeedUrls
  license: FeedLicense
  search_rank: String # only for search results
  associated_operators: [Operator!]
  feed_state: FeedState
  feed_fetches(limit: Int, where: FeedFetchFilter): [FeedFetch!]
  "Versions of this feed that have been fetched, archived, and imported by Transitland"
  feed_versions(limit: Int, where: FeedVersionFilter): [FeedVersion!]!
}

"""
Details on the current state of this feed, such as active version, last fetch time, etc.
"""
type FeedState {
  id: Int!
  "The active feed version for this feed"
  feed_version: FeedVersion
}

type FeedFetch {
  id: Int!
  url_type: String
  url: String
  success: Boolean
  fetched_at: Time
  fetch_error: String
  response_size: Int
  response_code: Int
  response_sha1: String
}

"""
Details on how to construct an HTTP request to access a protected resource
"""
type FeedAuthorization {
  "Method for inserting authorization secret into request"
  type: String!
  "When ` + "`" + `type=query_param` + "`" + `, this specifies the name of the query parameter. When ` + "`" + `type=header` + "`" + `, this specifies the name of the header"
  param_name: String!
  "Website to visit to sign up for an account"
  info_url: String!
}

"""
License information for this feed, curated by Interline and contributors to the Transitland Atlas feed registry. Note that this does not constitute legal advice. Users are advised to review and confirm any terms and conditions attached to a source feed.
"""
type FeedLicense {
  "SPDX identifier for a common license. See https://spdx.org/licenses/"
  spdx_identifier: String!
  "URL for a custom license"
  url: String!
  "Are feed consumers allowed to use the feed contents without including attribution text in their app or map?"
  use_without_attribution: String!
  "Are feed consumers allowed to create and share derived products from the feed?"
  create_derived_product: String!
  "Are feed consumers allowed to redistribute the feed in its entirety?"
  redistribution_allowed: String!
  "Are feed consumers allowed to use the feed for commercial purposes?"
  commercial_use_allowed: String!
  "Are feed consumers allowed to keep their modifications of this feed private?"
  share_alike_optional: String!
  "Feed consumers must include this particular text when using this feed"
  attribution_text: String!
  "Feed consumers must follow these instructions for how to provide attribution"
  attribution_instructions: String!
}

"""
URL(s) from which Transitland sources a feed
"""
type FeedUrls {
  "URL for the static feed that represents today's service"
  static_current: String!
  "URLs for static feeds that represent past service that is no longer in effect "
  static_historic: [String!]!
  "URLs for static feeds that represent service planned for upcoming dates. Typically used to represent calendar/service changes that will take effect few weeks or months in the future"
  static_planned: String!
  "URL for GTFS Realtime VehiclePosition messages"
  realtime_vehicle_positions: String!
  "URL for GTFS Realtime TripUpdate messages"
  realtime_trip_updates: String!
  "URL for GTFS Realtime Alert messages"
  realtime_alerts: String!
  "URL for GBFS feed ` + "`" + `gbfs.json` + "`" + ` auto-discovery file"
  gbfs_auto_discovery: String!
  "URL for MDS feed provider endpoint"
  mds_provider: String!
}

"""
Feed versions represent a specific static GTFS file that was published at a particular point in time, and are generally accessed and referenced using the [SHA1 checksum](https://en.wikipedia.org/wiki/SHA-1) of the GTFS archive.
"""
type FeedVersion {
  id: Int!
  sha1: String!
  fetched_at: Time!
  url: String!
  earliest_calendar_date: Date!
  latest_calendar_date: Date!
  created_by: String
  updated_by: String
  name: String
  description: String
  file: String  
  "Convex hull around all active stops in the feed version"
  geometry: Polygon
  feed: Feed!
  feed_version_gtfs_import: FeedVersionGtfsImport
  "Metadata for each text file present in the main directory of the zip archive "
  files(limit: Int): [FeedVersionFileInfo!]!
  service_levels(limit: Int, where: FeedVersionServiceLevelFilter): [FeedVersionServiceLevel!]!
  agencies(limit: Int, where: AgencyFilter): [Agency!]!
  routes(limit: Int, where: RouteFilter): [Route!]!
  stops(limit: Int, where: StopFilter): [Stop!]!
  trips(limit: Int, where: TripFilter): [Trip!]!
  feed_infos(limit: Int): [FeedInfo!]!
}

type FeedVersionFileInfo {
  id: Int!
  name: String!
  rows: Int!
  sha1: String!
  header: String!
  csv_like: Boolean!
  size: Int!
}

type FeedVersionGtfsImport {
  id: Int!
  in_progress: Boolean!
  success: Boolean!
  schedule_removed: Boolean!
  exception_log: String!
  skip_entity_error_count: Any
  entity_count: Any
  warning_count: Any
  created_at: Time
  updated_at: Time
  skip_entity_reference_count: Any
  skip_entity_filter_count: Any
  skip_entity_marked_count: Any
  interpolated_stop_time_count: Int
}

type FeedVersionServiceLevel {
  id: Int!
  start_date: Date!
  end_date: Date!
  monday: Int!
  tuesday: Int!
  wednesday: Int!
  thursday: Int!
  friday: Int!
  saturday: Int!
  sunday: Int!
}

# Operator
"""
An agency represents a single GTFS ` + "`" + `agencies.txt` + "`" + ` entity that was imported from a single feed version. The metadata, routes, etc., for an agency include only the data for that specific agency in that specific feed version. 

Operators are a higher-level abstraction over agencies, with each operator defined by an entry in the [Transitland Atlas](/documentation/atlas). Operators provide a method for enriching the basic GTFS agency data, as well as grouping agencies that span across multiple source feeds. Operators are matched with GTFS agencies using ` + "`" + `associated_feeds` + "`" + `, a simple list of Feed OnestopIDs and GTFS ` + "`" + `agency_id` + "`" + `s. For instance, the [Atlas operator record](https://github.com/transitland/transitland-atlas/blob/master/operators/o-dr5r-nyct.json) for the [New York City MTA](/operators/o-dr5r-nyct) has ` + "`" + `associated_feeds` + "`" + ` values for 8 different GTFS feeds. A query for this operator OnestopID thus represents the union of data from all 8 feeds, and includes routes for the subway, bus service for all 5 boroughs, commuter rail agencies, etc., operated by the MTA. This record also includes additional metadata about the MTA, such as the United States National Transit Database ID, Wikidata IDs, and alternate names for the agency. Operator records are created and maintained through pull requests to the Atlas json files and synchronized with the Transitland database on each commit.
"""
type Operator {
  id: Int!
  generated: Boolean!
  file: String
  onestop_id: String
  name: String
  short_name: String
  website: String
  tags: Tags
  search_rank: String # only for search results
  agencies: [Agency!]
  feeds(limit: Int, where: FeedFilter): [Feed!]
}

# GTFS Entities

"""
See https://gtfs.org/schedule/reference/#agencytxt
"""
type Agency {
  id: Int!
  onestop_id: String!
  agency_email: String!
  agency_fare_url: String!
  agency_id: String!
  agency_lang: String!
  agency_name: String!
  agency_phone: String!
  agency_timezone: String!
  agency_url: String!
  feed_version_sha1: String
  feed_onestop_id: String
  feed_version: FeedVersion!
  geometry: Polygon
  search_rank: String # only for search results
  operator: Operator
  places(limit: Int, where: AgencyPlaceFilter): [AgencyPlace!]
  routes(limit: Int, where: RouteFilter): [Route!]!
  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]
  alerts(active: Boolean, limit: Int): [Alert!]
}

"""
See https://gtfs.org/schedule/reference/#routestxt
"""
type Route {
  id: Int!
  onestop_id: String
  route_id: String!
  route_short_name: String!
  route_long_name: String!
  route_type: Int!
  route_color: String!
  route_text_color: String!
  route_sort_order: Int!
  route_url: String!
  route_desc: String!
  continuous_pickup: Int
  continuous_drop_off: Int
  geometry: Geometry @goField(forceResolver: true)
  agency: Agency!
  feed_version: FeedVersion!
  feed_version_sha1: String!
  feed_onestop_id: String!
  search_rank: String # only for search results
  route_attribute: RouteAttribute
  trips(limit: Int, where: TripFilter): [Trip!]!
  stops(limit: Int, where: StopFilter): [Stop!]!
  route_stops(limit: Int): [RouteStop!]!
  headways(limit: Int): [RouteHeadway!]!
  geometries(limit: Int): [RouteGeometry!]!
  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]
  route_stop_buffer(radius: Float): RouteStopBuffer!
  patterns: [RouteStopPattern!]
  alerts(active: Boolean, limit: Int): [Alert!]
}

"""
See https://gtfs.org/reference/static/#stopstxt
"""
type Stop {
  id: Int!
  onestop_id: String!
  location_type: Int!
  stop_code: String!
  stop_desc: String!
  stop_id: String!
  stop_name: String!
  stop_timezone: String!
  stop_url: String!
  wheelchair_boarding: Int!
  zone_id: String!
  platform_code: String
  tts_stop_name: String
  geometry: Point!
  feed_version_sha1: String!
  feed_onestop_id: String!
  feed_version: FeedVersion!
  level: Level
  parent: Stop
  external_reference: StopExternalReference  
  observations(limit: Int, where: StopObservationFilter): [StopObservation!]
  children(limit: Int): [Stop!]
  route_stops(limit: Int): [RouteStop!]!
  pathways_from_stop(limit: Int): [Pathway!]!
  pathways_to_stop(limit: Int): [Pathway!]!
  stop_times(limit: Int, where: StopTimeFilter): [StopTime!]!
  departures(limit: Int, where: StopTimeFilter): [StopTime!]!
  arrivals(limit: Int, where: StopTimeFilter): [StopTime!]!
  search_rank: String # only for search results
  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]
  directions(to:WaypointInput, from: WaypointInput, mode: StepMode, depart_at: Time): Directions!
  nearby_stops(limit: Int, radius: Float): [Stop!]
  alerts(active: Boolean, limit: Int): [Alert!]
}

"""
The GTFS-Pathways extension uses a graph representation to describe subway or train, with nodes (the locations) and edges (the pathways). See https://gtfs.org/reference/static/#pathwaystxt
"""
type Pathway {
  id: Int!
  pathway_id: String!
  pathway_mode: Int!
  is_bidirectional: Int!
  length: Float!
  traversal_time: Int!
  stair_count: Int!
  max_slope: Float!
  min_width: Float!
  signposted_as: String!
  reverse_signposted_as: String!
  from_stop: Stop!
  to_stop: Stop!
}

"""
Describe the different levels of a station. Is mostly useful when used in conjunction with pathways. See https://gtfs.org/reference/static/#levelstxt
"""
type Level {
  id: Int!
  level_id: String!
  level_name: String!
  level_index: Float!
  geometry: Polygon!
  stops: [Stop!]
}

"""
Record from a static GTFS [trips.txt](https://gtfs.org/schedule/reference/#tripstxt) file optionally enriched with by GTFS Realtime [TripUpdate](https://gtfs.org/reference/realtime/v2/#message-tripupdate) and [Alert](https://gtfs.org/reference/realtime/v2/#message-alert) messages.
"""
type Trip {
  id: Int!
  trip_id: String!
  trip_headsign: String!
  trip_short_name: String!
  direction_id: Int!
  block_id: String!
  wheelchair_accessible: Int!
  bikes_allowed: Int!
  stop_pattern_id: Int!
  calendar: Calendar!
  route: Route!
  shape: Shape
  feed_version: FeedVersion!
  stop_times(limit: Int, where: TripStopTimeFilter): [StopTime]!
  frequencies(limit: Int): [Frequency!]!
  # rt
  schedule_relationship: ScheduleRelationship
  timestamp: Time
  alerts(active: Boolean, limit: Int): [Alert!]
}

"""
Record from a static GTFS [calendars.txt](https://gtfs.org/schedule/reference/#calendarstxt) file.
"""
type Calendar {
  id: Int!
  service_id: String!
  start_date: Date!
  end_date: Date!
  monday: Int!
  tuesday: Int!
  wednesday: Int!
  thursday: Int!
  friday: Int!
  saturday: Int!
  sunday: Int!
  added_dates(limit: Int): [Date!]!
  removed_dates(limit: Int): [Date!]!
}

"""
Record from a static GTFS [shapes.txt](https://gtfs.org/schedule/reference/#shapestxt) file.
"""
type Shape {
  id: Int!
  shape_id: String!
  geometry: LineString!
  generated: Boolean!
}

"""
Record from a static GTFS [frequencies.txt](https://gtfs.org/schedule/reference/#frequenciestxt) file.
"""
type Frequency {
  id: Int!
  start_time: Seconds!
  end_time: Seconds!
  headway_secs: Int!
  exact_times: Int!
}

"""
Record from a static GTFS [stop_times.txt](https://gtfs.org/schedule/reference/#stop_timestxt) file.
"""
type StopTime {
  arrival_time: Seconds!
  departure_time: Seconds!
  stop_sequence: Int!
  stop_headsign: String
  pickup_type: Int
  drop_off_type: Int
  timepoint: Int
  interpolated: Int
  stop: Stop!
  trip: Trip!
  arrival: StopTimeEvent!
  departure: StopTimeEvent!
  continuous_drop_off: Int
  continuous_pickup: Int
  shape_dist_traveled: Float
  service_date: Date
}

"""
Record from a static GTFS [feed_info.txt](https://gtfs.org/schedule/reference/#feed_infotxt) file.
"""
type FeedInfo {
  id: Int!
  feed_publisher_name: String!
  feed_publisher_url: String!
  feed_lang: String!
  default_lang: String
  feed_version: String!
  feed_start_date: Date
  feed_end_date: Date
  feed_contact_email: String
  feed_contact_url: String
}

# Archived observed stop-times

type StopObservation {
  schedule_relationship: String
  trip_start_date: Date
  trip_start_time: Seconds
  from_stop_id: String
  to_stop_id: String
  agency_id: String
  route_id: String
  trip_id: String
  stop_sequence: Int
  source: String
  scheduled_arrival_time: Seconds
  scheduled_departure_time: Seconds
  observed_arrival_time: Seconds
  observed_departure_time: Seconds
}

# GTFS Support Entities

type StopExternalReference {
  id: Int!
  target_feed_onestop_id: String
  target_stop_id: String
  inactive: Boolean
  target_active_stop: Stop
}

type AgencyPlace {
  city_name: String
  adm1_name: String
  adm0_name: String
  rank: Float
}

enum PlaceAggregationLevel {
  ADM0
  ADM0_ADM1
  ADM0_ADM1_CITY
  ADM0_CITY
  ADM1_CITY
  CITY
}

type Place {
  adm0_name: String
  adm1_name: String
  city_name: String
  count: Int!
  operators: [Operator!]
}

type RouteStop {
  id: Int!
  stop_id: Int!
  route_id: Int!
  agency_id: Int!
  route: Route!
  stop: Stop!
  agency: Agency!
}

type RouteStopPattern {
  stop_pattern_id: Int!
  direction_id: Int!
  count: Int!
  trips(limit: Int): [Trip!]
}

type RouteGeometry {
  "If true, the source GTFS feed provides no shapes. This route geometry is based on straight lines between stop points."
  generated: Boolean!
  geometry: LineString
  combined_geometry: Geometry
  length: Float
  max_segment_length: Float
  first_point_max_distance: Float
}

type RouteHeadway {
  stop: Stop!
  dow_category: Int
  direction_id: Int
  headway_secs: Int
  service_date: Date
  stop_trip_count: Int
  departures: [Seconds!]
}

"""
MTC GTFS+ Extension: route_attributes.txt
"""
type RouteAttribute {
  category: Int
  subcategory: Int
  running_way: Int
}

# Census entities

type CensusGeography {
  id: Int!
  layer_name: String!
  geoid: String
  name: String
  aland: Float
  awater: Float
  geometry: Polygon
  values(table_names: [String!]!, limit: Int): [CensusValue]!
}

type CensusValue {
  table: CensusTable!
  values: Any! # json blob
}

type CensusTable {
  id: Int!
  table_name: String!
  table_title: String!
  table_group: String!
}

# Realtime updates

enum ScheduleRelationship {
  SCHEDULED
  ADDED
  UNSCHEDULED
  CANCELED
}

type StopTimeEvent {
  stop_timezone: String!
  scheduled: Seconds
  estimated: Seconds
  estimated_utc: Time
  delay: Int
  uncertainty: Int
}

"""
[Vehicle Position](https://gtfs.org/reference/realtime/v2/#message-vehicleposition) message provided by a source GTFS Realtime feed.
"""
type VehiclePosition {
  vehicle: RTVehicleDescriptor
  position: Point
  current_stop_sequence: Int
  stop_id: Stop
  current_status: String
  timestamp: Time
  congestion_level: String
}

"""
[Alert](https://gtfs.org/reference/realtime/v2/#message-alert) message, also called a service alert, provided by a source GTFS Realtime feed.
"""
type Alert {
  active_period: [RTTimeRange!]
  cause: String
  effect: String
  header_text: [RTTranslation!]!
  description_text: [RTTranslation!]!
  tts_header_text: [RTTranslation!]
  tts_description_text: [RTTranslation!]
  url: [RTTranslation!]
  severity_level: String
}

"""
See https://gtfs.org/reference/realtime/v2/#message-timerange
"""
type RTTimeRange {
  start: Int
  end: Int
}

"""
See https://gtfs.org/reference/realtime/v2/#message-vehicledescriptor
"""
type RTVehicleDescriptor {
  id: String
  label: String
  license_plate: String
}

"""
See https://gtfs.org/reference/realtime/v2/#message-tripdescriptor
"""
type RTTripDescriptor {
  trip_id: String
  route_id: String
  direction_id: Int
  start_time: Seconds
  start_date: Date
  schedule_relationship: String
}

"""
See https://gtfs.org/reference/realtime/v2/#message-translatedstring
"""
type RTTranslation {
  text: String!
  language: String
}


# Analysis tools

type RouteStopBuffer {
  stop_points: Geometry
  stop_buffer: Geometry
  stop_convexhull: Polygon
}

# Validation tools

type ValidationResult {
  # Validation output
  success: Boolean!
  failure_reason: String!
  errors: [ValidationResultErrorGroup!]!
  warnings: [ValidationResultErrorGroup!]!
  # FeedVersion-like
  sha1: String!
  earliest_calendar_date: Date
  latest_calendar_date: Date
  files: [FeedVersionFileInfo!]!
  service_levels(limit: Int, route_id: String): [FeedVersionServiceLevel!]!
  agencies(limit: Int): [Agency!]!
  routes(limit: Int): [Route!]!
  stops(limit: Int): [Stop!]!
  feed_infos(limit: Int): [FeedInfo!]!
}

type ValidationResultErrorGroup {
  filename: String!
  error_type: String!
  count: Int!
  limit: Int!
  errors: [ValidationResultError!]!
}

type ValidationResultError {
  filename: String!
  error_type: String!
  entity_id: String!
  field: String!
  value: String!
  message: String!
}

type FeedVersionFetchResult {
  feed_version: FeedVersion
  fetch_error: String
  found_sha1: Boolean!
  found_dir_sha1: Boolean!
}

type FeedVersionImportResult {
  success: Boolean!
}

type FeedVersionUnimportResult {
  success: Boolean!
}

type FeedVersionDeleteResult {
  success: Boolean!
}

`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_hasRole_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.Role
	if tmp, ok := rawArgs["role"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("role"))
		arg0, err = ec.unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["role"] = arg0
	return args, nil
}

func (ec *executionContext) field_Agency_alerts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["active"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["active"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Agency_census_geographies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["layer"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["layer"] = arg0
	var arg1 *float64
	if tmp, ok := rawArgs["radius"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
		arg1, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["radius"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Agency_places_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.AgencyPlaceFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOAgencyPlaceFilter2githubcominterlineiotransitlandservermodelAgencyPlaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Agency_routes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.RouteFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalORouteFilter2githubcominterlineiotransitlandservermodelRouteFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Calendar_added_dates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Calendar_removed_dates_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_CensusGeography_values_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["table_names"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("table_names"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["table_names"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_agencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.AgencyFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOAgencyFilter2githubcominterlineiotransitlandservermodelAgencyFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_feed_infos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_FeedVersion_files_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_FeedVersion_routes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.RouteFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalORouteFilter2githubcominterlineiotransitlandservermodelRouteFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_service_levels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.FeedVersionServiceLevelFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOFeedVersionServiceLevelFilter2githubcominterlineiotransitlandservermodelFeedVersionServiceLevelFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_stops_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.StopFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOStopFilter2githubcominterlineiotransitlandservermodelStopFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_FeedVersion_trips_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.TripFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOTripFilter2githubcominterlineiotransitlandservermodelTripFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Feed_feed_fetches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.FeedFetchFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOFeedFetchFilter2githubcominterlineiotransitlandservermodelFeedFetchFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Feed_feed_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.FeedVersionFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOFeedVersionFilter2githubcominterlineiotransitlandservermodelFeedVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_delete_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_fetch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *graphql.Upload
	if tmp, ok := rawArgs["file"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
		arg0, err = ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["file"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["url"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["url"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["feed_onestop_id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["feed_onestop_id"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_import_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["sha1"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sha1"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sha1"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_unimport_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_feed_version_update_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 int
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 model.FeedVersionSetInput
	if tmp, ok := rawArgs["set"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("set"))
		arg1, err = ec.unmarshalNFeedVersionSetInput2githubcominterlineiotransitlandservermodelFeedVersionSetInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["set"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_validate_gtfs_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *graphql.Upload
	if tmp, ok := rawArgs["file"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
		arg0, err = ec.unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["file"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["url"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["url"] = arg1
	var arg2 []string
	if tmp, ok := rawArgs["realtime_urls"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("realtime_urls"))
		arg2, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["realtime_urls"] = arg2
	return args, nil
}

func (ec *executionContext) field_Operator_feeds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.FeedFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOFeedFilter2githubcominterlineiotransitlandservermodelFeedFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_agencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg2
	var arg3 *model.AgencyFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalOAgencyFilter2githubcominterlineiotransitlandservermodelAgencyFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_bikes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.GbfsBikeRequest
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOGbfsBikeRequest2githubcominterlineiotransitlandservermodelGbfsBikeRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_directions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.DirectionRequest
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg0, err = ec.unmarshalNDirectionRequest2githubcominterlineiotransitlandservermodelDirectionRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_docks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.GbfsDockRequest
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOGbfsDockRequest2githubcominterlineiotransitlandservermodelGbfsDockRequest(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_feed_versions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg2
	var arg3 *model.FeedVersionFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalOFeedVersionFilter2githubcominterlineiotransitlandservermodelFeedVersionFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_feeds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg2
	var arg3 *model.FeedFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalOFeedFilter2githubcominterlineiotransitlandservermodelFeedFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_operators_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg2
	var arg3 *model.OperatorFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalOOperatorFilter2githubcominterlineiotransitlandservermodelOperatorFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_places_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *model.PlaceAggregationLevel
	if tmp, ok := rawArgs["level"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
		arg2, err = ec.unmarshalOPlaceAggregationLevel2githubcominterlineiotransitlandservermodelPlaceAggregationLevel(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["level"] = arg2
	var arg3 *model.PlaceFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalOPlaceFilter2githubcominterlineiotransitlandservermodelPlaceFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_routes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg2
	var arg3 *model.RouteFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalORouteFilter2githubcominterlineiotransitlandservermodelRouteFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_stops_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg2
	var arg3 *model.StopFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalOStopFilter2githubcominterlineiotransitlandservermodelStopFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_trips_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 []int
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg2
	var arg3 *model.TripFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg3, err = ec.unmarshalOTripFilter2githubcominterlineiotransitlandservermodelTripFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg3
	return args, nil
}

func (ec *executionContext) field_RouteStopPattern_trips_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_alerts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["active"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["active"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Route_census_geographies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["layer"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["layer"] = arg0
	var arg1 *float64
	if tmp, ok := rawArgs["radius"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
		arg1, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["radius"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Route_geometries_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_headways_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_route_stop_buffer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *float64
	if tmp, ok := rawArgs["radius"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
		arg0, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["radius"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_route_stops_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Route_stops_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.StopFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOStopFilter2githubcominterlineiotransitlandservermodelStopFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Route_trips_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.TripFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOTripFilter2githubcominterlineiotransitlandservermodelTripFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_alerts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["active"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["active"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_arrivals_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.StopTimeFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandservermodelStopTimeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_census_geographies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["layer"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("layer"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["layer"] = arg0
	var arg1 *float64
	if tmp, ok := rawArgs["radius"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
		arg1, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["radius"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	return args, nil
}

func (ec *executionContext) field_Stop_children_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_departures_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.StopTimeFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandservermodelStopTimeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_directions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.WaypointInput
	if tmp, ok := rawArgs["to"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
		arg0, err = ec.unmarshalOWaypointInput2githubcominterlineiotransitlandservermodelWaypointInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["to"] = arg0
	var arg1 *model.WaypointInput
	if tmp, ok := rawArgs["from"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
		arg1, err = ec.unmarshalOWaypointInput2githubcominterlineiotransitlandservermodelWaypointInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["from"] = arg1
	var arg2 *model.StepMode
	if tmp, ok := rawArgs["mode"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
		arg2, err = ec.unmarshalOStepMode2githubcominterlineiotransitlandservermodelStepMode(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["mode"] = arg2
	var arg3 *time.Time
	if tmp, ok := rawArgs["depart_at"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("depart_at"))
		arg3, err = ec.unmarshalOTime2timeTime(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["depart_at"] = arg3
	return args, nil
}

func (ec *executionContext) field_Stop_nearby_stops_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *float64
	if tmp, ok := rawArgs["radius"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
		arg1, err = ec.unmarshalOFloat2float64(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["radius"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_observations_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.StopObservationFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOStopObservationFilter2githubcominterlineiotransitlandservermodelStopObservationFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Stop_pathways_from_stop_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_pathways_to_stop_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_route_stops_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Stop_stop_times_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.StopTimeFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOStopTimeFilter2githubcominterlineiotransitlandservermodelStopTimeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_Trip_alerts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *bool
	if tmp, ok := rawArgs["active"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("active"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["active"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	return args, nil
}

func (ec *executionContext) field_Trip_frequencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_Trip_stop_times_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *model.TripStopTimeFilter
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg1, err = ec.unmarshalOTripStopTimeFilter2githubcominterlineiotransitlandservermodelTripStopTimeFilter(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg1
	return args, nil
}

func (ec *executionContext) field_ValidationResult_agencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationResult_feed_infos_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationResult_routes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field_ValidationResult_service_levels_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["route_id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_id"))
		arg1, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["route_id"] = arg1
	return args, nil
}

func (ec *executionContext) field_ValidationResult_stops_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _Agency_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_email(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_fare_url(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_fare_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyFareURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_fare_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_lang(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyLang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_lang(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_name(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_phone(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyPhone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_phone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_timezone(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_timezone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_agency_url(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_agency_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_agency_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_feed_version_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_feed_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_feed_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Polygon)
	fc.Result = res
	return ec.marshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_search_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_operator(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Operator(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Operator)
	fc.Result = res
	return ec.marshalOOperator2githubcominterlineiotransitlandservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Agency_places(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_places(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Places(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.AgencyPlaceFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AgencyPlace)
	fc.Result = res
	return ec.marshalOAgencyPlace2githubcominterlineiotransitlandservermodelAgencyPlace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_places(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "city_name":
				return ec.fieldContext_AgencyPlace_city_name(ctx, field)
			case "adm1_name":
				return ec.fieldContext_AgencyPlace_adm1_name(ctx, field)
			case "adm0_name":
				return ec.fieldContext_AgencyPlace_adm0_name(ctx, field)
			case "rank":
				return ec.fieldContext_AgencyPlace_rank(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AgencyPlace", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_places_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Agency_routes(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Routes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.RouteFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Agency_census_geographies(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_census_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().CensusGeographies(rctx, obj, fc.Args["layer"].(string), fc.Args["radius"].(*float64), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_census_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_census_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Agency_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Agency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Agency_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Agency().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Agency_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Agency",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Agency_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_city_name(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_city_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_city_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_adm1_name(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_adm1_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_adm1_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_adm0_name(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_adm0_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_adm0_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AgencyPlace_rank(ctx context.Context, field graphql.CollectedField, obj *model.AgencyPlace) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AgencyPlace_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AgencyPlace_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AgencyPlace",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_active_period(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_active_period(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivePeriod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTimeRange)
	fc.Result = res
	return ec.marshalORTTimeRange2githubcominterlineiotransitlandservermodelRTTimeRange(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_active_period(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_RTTimeRange_start(ctx, field)
			case "end":
				return ec.fieldContext_RTTimeRange_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTimeRange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_cause(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_cause(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cause, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_cause(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_effect(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_effect(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Effect, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_effect(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_header_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_header_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeaderText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalNRTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_header_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_description_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_description_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DescriptionText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalNRTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_description_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_tts_header_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_tts_header_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TtsHeaderText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalORTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_tts_header_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_tts_description_text(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_tts_description_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TtsDescriptionText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalORTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_tts_description_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_url(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RTTranslation)
	fc.Result = res
	return ec.marshalORTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_RTTranslation_text(ctx, field)
			case "language":
				return ec.fieldContext_RTTranslation_language(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTTranslation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Alert_severity_level(ctx context.Context, field graphql.CollectedField, obj *model.Alert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Alert_severity_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SeverityLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Alert_severity_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Alert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_id(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_service_id(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_service_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_service_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_start_date(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Calendar().StartDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_start_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_end_date(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_end_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Calendar().EndDate(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_end_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_monday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_monday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Monday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_monday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_tuesday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_tuesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tuesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_tuesday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_wednesday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_wednesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wednesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_wednesday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_thursday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_thursday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Thursday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_thursday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_friday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_friday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Friday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_friday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_saturday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_saturday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Saturday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_saturday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_sunday(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_sunday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sunday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_sunday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_added_dates(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_added_dates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Calendar().AddedDates(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_added_dates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Calendar_added_dates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Calendar_removed_dates(ctx context.Context, field graphql.CollectedField, obj *model.Calendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Calendar_removed_dates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Calendar().RemovedDates(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Calendar_removed_dates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Calendar",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Calendar_removed_dates_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_layer_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_layer_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LayerName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_layer_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_geoid(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_geoid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geoid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_geoid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_aland(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_aland(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aland, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_aland(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_awater(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_awater(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Awater, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_awater(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_geometry(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Polygon)
	fc.Result = res
	return ec.marshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusGeography_values(ctx context.Context, field graphql.CollectedField, obj *model.CensusGeography) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusGeography_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusGeography().Values(rctx, obj, fc.Args["table_names"].([]string), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.CensusValue)
	fc.Result = res
	return ec.marshalNCensusValue2githubcominterlineiotransitlandservermodelCensusValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusGeography_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusGeography",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "table":
				return ec.fieldContext_CensusValue_table(ctx, field)
			case "values":
				return ec.fieldContext_CensusValue_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_CensusGeography_values_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_id(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_table_name(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_table_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TableName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_table_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_table_title(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_table_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TableTitle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_table_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusTable_table_group(ctx context.Context, field graphql.CollectedField, obj *model.CensusTable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusTable_table_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TableGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusTable_table_group(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusTable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusValue_table(ctx context.Context, field graphql.CollectedField, obj *model.CensusValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusValue_table(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusValue().Table(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.CensusTable)
	fc.Result = res
	return ec.marshalNCensusTable2githubcominterlineiotransitlandservermodelCensusTable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusValue_table(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusTable_id(ctx, field)
			case "table_name":
				return ec.fieldContext_CensusTable_table_name(ctx, field)
			case "table_title":
				return ec.fieldContext_CensusTable_table_title(ctx, field)
			case "table_group":
				return ec.fieldContext_CensusTable_table_group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusTable", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CensusValue_values(ctx context.Context, field graphql.CollectedField, obj *model.CensusValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CensusValue_values(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CensusValue().Values(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalNAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CensusValue_values(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CensusValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_success(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_exception(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_exception(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exception, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_exception(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_data_source(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_data_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DataSource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_data_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_origin(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_origin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Origin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_origin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_destination(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_destination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Destination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_destination(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_duration(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalODuration2githubcominterlineiotransitlandservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_distance(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalODistance2githubcominterlineiotransitlandservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Directions_itineraries(ctx context.Context, field graphql.CollectedField, obj *model.Directions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Directions_itineraries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Itineraries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Itinerary)
	fc.Result = res
	return ec.marshalOItinerary2githubcominterlineiotransitlandservermodelItinerary(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Directions_itineraries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Directions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Itinerary_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Itinerary_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Itinerary_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Itinerary_end_time(ctx, field)
			case "from":
				return ec.fieldContext_Itinerary_from(ctx, field)
			case "to":
				return ec.fieldContext_Itinerary_to(ctx, field)
			case "legs":
				return ec.fieldContext_Itinerary_legs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Itinerary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distance_distance(ctx context.Context, field graphql.CollectedField, obj *model.Distance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distance_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distance_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distance_units(ctx context.Context, field graphql.CollectedField, obj *model.Distance) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distance_units(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DistanceUnit)
	fc.Result = res
	return ec.marshalNDistanceUnit2githubcominterlineiotransitlandservermodelDistanceUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distance_units(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distance",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DistanceUnit does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Duration_duration(ctx context.Context, field graphql.CollectedField, obj *model.Duration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Duration_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Duration_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Duration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Duration_units(ctx context.Context, field graphql.CollectedField, obj *model.Duration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Duration_units(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Units, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.DurationUnit)
	fc.Result = res
	return ec.marshalNDurationUnit2githubcominterlineiotransitlandservermodelDurationUnit(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Duration_units(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Duration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DurationUnit does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_id(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_name(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_file(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_file(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.File, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_file(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_spec(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_spec(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Spec(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedSpecTypes)
	fc.Result = res
	return ec.marshalOFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_spec(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FeedSpecTypes does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_languages(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_languages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Languages(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_languages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_tags(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Tags)
	fc.Result = res
	return ec.marshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Tags does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_authorization(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_authorization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Authorization(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedAuthorization)
	fc.Result = res
	return ec.marshalOFeedAuthorization2githubcominterlineiotransitlandservermodelFeedAuthorization(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_authorization(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_FeedAuthorization_type(ctx, field)
			case "param_name":
				return ec.fieldContext_FeedAuthorization_param_name(ctx, field)
			case "info_url":
				return ec.fieldContext_FeedAuthorization_info_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedAuthorization", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_urls(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_urls(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().Urls(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedUrls)
	fc.Result = res
	return ec.marshalOFeedUrls2githubcominterlineiotransitlandservermodelFeedUrls(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_urls(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "static_current":
				return ec.fieldContext_FeedUrls_static_current(ctx, field)
			case "static_historic":
				return ec.fieldContext_FeedUrls_static_historic(ctx, field)
			case "static_planned":
				return ec.fieldContext_FeedUrls_static_planned(ctx, field)
			case "realtime_vehicle_positions":
				return ec.fieldContext_FeedUrls_realtime_vehicle_positions(ctx, field)
			case "realtime_trip_updates":
				return ec.fieldContext_FeedUrls_realtime_trip_updates(ctx, field)
			case "realtime_alerts":
				return ec.fieldContext_FeedUrls_realtime_alerts(ctx, field)
			case "gbfs_auto_discovery":
				return ec.fieldContext_FeedUrls_gbfs_auto_discovery(ctx, field)
			case "mds_provider":
				return ec.fieldContext_FeedUrls_mds_provider(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedUrls", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_license(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_license(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().License(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedLicense)
	fc.Result = res
	return ec.marshalOFeedLicense2githubcominterlineiotransitlandservermodelFeedLicense(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_license(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spdx_identifier":
				return ec.fieldContext_FeedLicense_spdx_identifier(ctx, field)
			case "url":
				return ec.fieldContext_FeedLicense_url(ctx, field)
			case "use_without_attribution":
				return ec.fieldContext_FeedLicense_use_without_attribution(ctx, field)
			case "create_derived_product":
				return ec.fieldContext_FeedLicense_create_derived_product(ctx, field)
			case "redistribution_allowed":
				return ec.fieldContext_FeedLicense_redistribution_allowed(ctx, field)
			case "commercial_use_allowed":
				return ec.fieldContext_FeedLicense_commercial_use_allowed(ctx, field)
			case "share_alike_optional":
				return ec.fieldContext_FeedLicense_share_alike_optional(ctx, field)
			case "attribution_text":
				return ec.fieldContext_FeedLicense_attribution_text(ctx, field)
			case "attribution_instructions":
				return ec.fieldContext_FeedLicense_attribution_instructions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedLicense", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_search_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_associated_operators(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_associated_operators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().AssociatedOperators(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Operator)
	fc.Result = res
	return ec.marshalOOperator2githubcominterlineiotransitlandservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_associated_operators(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_feed_state(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_feed_state(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FeedState(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedState)
	fc.Result = res
	return ec.marshalOFeedState2githubcominterlineiotransitlandservermodelFeedState(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_feed_state(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedState_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_FeedState_feed_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedState", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Feed_feed_fetches(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_feed_fetches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FeedFetches(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedFetchFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.FeedFetch)
	fc.Result = res
	return ec.marshalOFeedFetch2githubcominterlineiotransitlandservermodelFeedFetch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_feed_fetches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedFetch_id(ctx, field)
			case "url_type":
				return ec.fieldContext_FeedFetch_url_type(ctx, field)
			case "url":
				return ec.fieldContext_FeedFetch_url(ctx, field)
			case "success":
				return ec.fieldContext_FeedFetch_success(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedFetch_fetched_at(ctx, field)
			case "fetch_error":
				return ec.fieldContext_FeedFetch_fetch_error(ctx, field)
			case "response_size":
				return ec.fieldContext_FeedFetch_response_size(ctx, field)
			case "response_code":
				return ec.fieldContext_FeedFetch_response_code(ctx, field)
			case "response_sha1":
				return ec.fieldContext_FeedFetch_response_sha1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedFetch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Feed_feed_fetches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Feed_feed_versions(ctx context.Context, field graphql.CollectedField, obj *model.Feed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Feed_feed_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Feed().FeedVersions(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedVersionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Feed_feed_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Feed",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Feed_feed_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedAuthorization_type(ctx context.Context, field graphql.CollectedField, obj *model.FeedAuthorization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedAuthorization_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedAuthorization_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedAuthorization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedAuthorization_param_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedAuthorization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedAuthorization_param_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParamName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedAuthorization_param_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedAuthorization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedAuthorization_info_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedAuthorization) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedAuthorization_info_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InfoURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedAuthorization_info_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedAuthorization",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_url_type(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_url_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_url_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_fetched_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_fetched_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Time)
	fc.Result = res
	return ec.marshalOTime2githubcominterlineiotransitlandlibtlttTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_fetched_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_fetch_error(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_fetch_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_fetch_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_response_size(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_response_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_response_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_response_code(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_response_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_response_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedFetch_response_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedFetch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedFetch_response_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResponseSha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedFetch_response_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedFetch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_publisher_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_publisher_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedPublisherName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_publisher_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_publisher_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_publisher_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedPublisherURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_publisher_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_lang(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedLang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_lang(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_default_lang(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_default_lang(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultLang, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_default_lang(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_start_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedStartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_start_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_end_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_end_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedEndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_end_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_contact_email(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_contact_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedContactEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_contact_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedInfo_feed_contact_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedInfo_feed_contact_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedContactURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedInfo_feed_contact_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_spdx_identifier(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_spdx_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpdxIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_spdx_identifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_use_without_attribution(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_use_without_attribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseWithoutAttribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_use_without_attribution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_create_derived_product(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_create_derived_product(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateDerivedProduct, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_create_derived_product(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_redistribution_allowed(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_redistribution_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedistributionAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_redistribution_allowed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_commercial_use_allowed(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_commercial_use_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommercialUseAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_commercial_use_allowed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_share_alike_optional(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_share_alike_optional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShareAlikeOptional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_share_alike_optional(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_attribution_text(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_attribution_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AttributionText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_attribution_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedLicense_attribution_instructions(ctx context.Context, field graphql.CollectedField, obj *model.FeedLicense) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedLicense_attribution_instructions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AttributionInstructions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedLicense_attribution_instructions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedLicense",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedState_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedState_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.FeedState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedState_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedState().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalOFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedState_feed_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedState",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_static_current(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_static_current(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticCurrent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_static_current(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_static_historic(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_static_historic(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticHistoric, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_static_historic(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_static_planned(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_static_planned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticPlanned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_static_planned(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_realtime_vehicle_positions(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_realtime_vehicle_positions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RealtimeVehiclePositions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_realtime_vehicle_positions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_realtime_trip_updates(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_realtime_trip_updates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RealtimeTripUpdates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_realtime_trip_updates(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_realtime_alerts(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_realtime_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RealtimeAlerts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_realtime_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_gbfs_auto_discovery(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_gbfs_auto_discovery(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GbfsAutoDiscovery, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_gbfs_auto_discovery(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedUrls_mds_provider(ctx context.Context, field graphql.CollectedField, obj *model.FeedUrls) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedUrls_mds_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MdsProvider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedUrls_mds_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedUrls",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_fetched_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_fetched_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_fetched_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_url(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_earliest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EarliestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_earliest_calendar_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_latest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_latest_calendar_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_created_by(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_created_by(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_created_by(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_updated_by(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_updated_by(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_updated_by(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_description(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_file(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_file(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.File, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_file(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_geometry(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Geometry(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Polygon)
	fc.Result = res
	return ec.marshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_feed(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_feed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Feed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcominterlineiotransitlandservermodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_feed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Feed_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "file":
				return ec.fieldContext_Feed_file(ctx, field)
			case "spec":
				return ec.fieldContext_Feed_spec(ctx, field)
			case "languages":
				return ec.fieldContext_Feed_languages(ctx, field)
			case "tags":
				return ec.fieldContext_Feed_tags(ctx, field)
			case "authorization":
				return ec.fieldContext_Feed_authorization(ctx, field)
			case "urls":
				return ec.fieldContext_Feed_urls(ctx, field)
			case "license":
				return ec.fieldContext_Feed_license(ctx, field)
			case "search_rank":
				return ec.fieldContext_Feed_search_rank(ctx, field)
			case "associated_operators":
				return ec.fieldContext_Feed_associated_operators(ctx, field)
			case "feed_state":
				return ec.fieldContext_Feed_feed_state(ctx, field)
			case "feed_fetches":
				return ec.fieldContext_Feed_feed_fetches(ctx, field)
			case "feed_versions":
				return ec.fieldContext_Feed_feed_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_feed_version_gtfs_import(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().FeedVersionGtfsImport(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionGtfsImport)
	fc.Result = res
	return ec.marshalOFeedVersionGtfsImport2githubcominterlineiotransitlandservermodelFeedVersionGtfsImport(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_feed_version_gtfs_import(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionGtfsImport_id(ctx, field)
			case "in_progress":
				return ec.fieldContext_FeedVersionGtfsImport_in_progress(ctx, field)
			case "success":
				return ec.fieldContext_FeedVersionGtfsImport_success(ctx, field)
			case "schedule_removed":
				return ec.fieldContext_FeedVersionGtfsImport_schedule_removed(ctx, field)
			case "exception_log":
				return ec.fieldContext_FeedVersionGtfsImport_exception_log(ctx, field)
			case "skip_entity_error_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_error_count(ctx, field)
			case "entity_count":
				return ec.fieldContext_FeedVersionGtfsImport_entity_count(ctx, field)
			case "warning_count":
				return ec.fieldContext_FeedVersionGtfsImport_warning_count(ctx, field)
			case "created_at":
				return ec.fieldContext_FeedVersionGtfsImport_created_at(ctx, field)
			case "updated_at":
				return ec.fieldContext_FeedVersionGtfsImport_updated_at(ctx, field)
			case "skip_entity_reference_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_reference_count(ctx, field)
			case "skip_entity_filter_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_filter_count(ctx, field)
			case "skip_entity_marked_count":
				return ec.fieldContext_FeedVersionGtfsImport_skip_entity_marked_count(ctx, field)
			case "interpolated_stop_time_count":
				return ec.fieldContext_FeedVersionGtfsImport_interpolated_stop_time_count(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionGtfsImport", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_files(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Files(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersionFileInfo)
	fc.Result = res
	return ec.marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionFileInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersionFileInfo_name(ctx, field)
			case "rows":
				return ec.fieldContext_FeedVersionFileInfo_rows(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersionFileInfo_sha1(ctx, field)
			case "header":
				return ec.fieldContext_FeedVersionFileInfo_header(ctx, field)
			case "csv_like":
				return ec.fieldContext_FeedVersionFileInfo_csv_like(ctx, field)
			case "size":
				return ec.fieldContext_FeedVersionFileInfo_size(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionFileInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_files_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_service_levels(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_service_levels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().ServiceLevels(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedVersionServiceLevelFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersionServiceLevel)
	fc.Result = res
	return ec.marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_service_levels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionServiceLevel_id(ctx, field)
			case "start_date":
				return ec.fieldContext_FeedVersionServiceLevel_start_date(ctx, field)
			case "end_date":
				return ec.fieldContext_FeedVersionServiceLevel_end_date(ctx, field)
			case "monday":
				return ec.fieldContext_FeedVersionServiceLevel_monday(ctx, field)
			case "tuesday":
				return ec.fieldContext_FeedVersionServiceLevel_tuesday(ctx, field)
			case "wednesday":
				return ec.fieldContext_FeedVersionServiceLevel_wednesday(ctx, field)
			case "thursday":
				return ec.fieldContext_FeedVersionServiceLevel_thursday(ctx, field)
			case "friday":
				return ec.fieldContext_FeedVersionServiceLevel_friday(ctx, field)
			case "saturday":
				return ec.fieldContext_FeedVersionServiceLevel_saturday(ctx, field)
			case "sunday":
				return ec.fieldContext_FeedVersionServiceLevel_sunday(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionServiceLevel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_service_levels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_agencies(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Agencies(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.AgencyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_agencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_agencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_routes(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Routes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.RouteFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_stops(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Stops(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_trips(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().Trips(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.TripFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersion_feed_infos(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersion_feed_infos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersion().FeedInfos(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedInfo)
	fc.Result = res
	return ec.marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersion_feed_infos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersion",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedInfo_id(ctx, field)
			case "feed_publisher_name":
				return ec.fieldContext_FeedInfo_feed_publisher_name(ctx, field)
			case "feed_publisher_url":
				return ec.fieldContext_FeedInfo_feed_publisher_url(ctx, field)
			case "feed_lang":
				return ec.fieldContext_FeedInfo_feed_lang(ctx, field)
			case "default_lang":
				return ec.fieldContext_FeedInfo_default_lang(ctx, field)
			case "feed_version":
				return ec.fieldContext_FeedInfo_feed_version(ctx, field)
			case "feed_start_date":
				return ec.fieldContext_FeedInfo_feed_start_date(ctx, field)
			case "feed_end_date":
				return ec.fieldContext_FeedInfo_feed_end_date(ctx, field)
			case "feed_contact_email":
				return ec.fieldContext_FeedInfo_feed_contact_email(ctx, field)
			case "feed_contact_url":
				return ec.fieldContext_FeedInfo_feed_contact_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_FeedVersion_feed_infos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionDeleteResult_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionDeleteResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionDeleteResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionDeleteResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionDeleteResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalOFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_feed_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_fetch_error(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_fetch_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FetchError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_fetch_error(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_found_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_found_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_found_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFetchResult_found_dir_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFetchResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFetchResult_found_dir_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FoundDirSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFetchResult_found_dir_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFetchResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_rows(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_rows(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_rows(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_sha1(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_header(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_header(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Header, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_header(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_csv_like(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_csv_like(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CSVLike, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_csv_like(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionFileInfo_size(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionFileInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionFileInfo_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionFileInfo_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionFileInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_in_progress(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_in_progress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InProgress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_in_progress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_schedule_removed(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_schedule_removed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduleRemoved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_schedule_removed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_exception_log(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_exception_log(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExceptionLog, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_exception_log(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_error_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_error_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityErrorCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_error_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_entity_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_entity_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().EntityCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_entity_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_warning_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_warning_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().WarningCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_warning_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_created_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_created_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_created_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_updated_at(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_updated_at(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_updated_at(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_reference_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_reference_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityReferenceCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_reference_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_filter_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_filter_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityFilterCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_filter_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_skip_entity_marked_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_skip_entity_marked_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FeedVersionGtfsImport().SkipEntityMarkedCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(interface{})
	fc.Result = res
	return ec.marshalOAny2interface(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_skip_entity_marked_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Any does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionGtfsImport_interpolated_stop_time_count(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionGtfsImport) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionGtfsImport_interpolated_stop_time_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InterpolatedStopTimeCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionGtfsImport_interpolated_stop_time_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionGtfsImport",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionImportResult_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionImportResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionImportResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionImportResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionImportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_id(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_start_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_start_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_end_date(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_end_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_end_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_monday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_monday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Monday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_monday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_tuesday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_tuesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tuesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_tuesday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_wednesday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_wednesday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wednesday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_wednesday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_thursday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_thursday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Thursday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_thursday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_friday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_friday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Friday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_friday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_saturday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_saturday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Saturday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_saturday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionServiceLevel_sunday(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionServiceLevel) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionServiceLevel_sunday(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sunday, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionServiceLevel_sunday(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionServiceLevel",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FeedVersionUnimportResult_success(ctx context.Context, field graphql.CollectedField, obj *model.FeedVersionUnimportResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FeedVersionUnimportResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FeedVersionUnimportResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FeedVersionUnimportResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_id(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.WideTime)
	fc.Result = res
	return ec.marshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.WideTime)
	fc.Result = res
	return ec.marshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_headway_secs(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_headway_secs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadwaySecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_headway_secs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Frequency_exact_times(ctx context.Context, field graphql.CollectedField, obj *model.Frequency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Frequency_exact_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExactTimes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Frequency_exact_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Frequency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsAlertTime_start(ctx context.Context, field graphql.CollectedField, obj *model.GbfsAlertTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsAlertTime_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsAlertTime_start(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsAlertTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsAlertTime_end(ctx context.Context, field graphql.CollectedField, obj *model.GbfsAlertTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsAlertTime_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsAlertTime_end(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsAlertTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_last_modified(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_last_modified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandLastModified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_last_modified(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_terms_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_terms_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandTermsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_terms_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_image_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_image_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandImageURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_image_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_brand_image_url_dark(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_brand_image_url_dark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandImageURLDark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_brand_image_url_dark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsBrandAsset_color(ctx context.Context, field graphql.CollectedField, obj *model.GbfsBrandAsset) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsBrandAsset_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsBrandAsset_color(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsBrandAsset",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_system_information(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_system_information(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemInformation)
	fc.Result = res
	return ec.marshalOGbfsSystemInformation2githubcominterlineiotransitlandservermodelGbfsSystemInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_system_information(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "system_id":
				return ec.fieldContext_GbfsSystemInformation_system_id(ctx, field)
			case "language":
				return ec.fieldContext_GbfsSystemInformation_language(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsSystemInformation_short_name(ctx, field)
			case "operator":
				return ec.fieldContext_GbfsSystemInformation_operator(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemInformation_url(ctx, field)
			case "purchase_url":
				return ec.fieldContext_GbfsSystemInformation_purchase_url(ctx, field)
			case "start_date":
				return ec.fieldContext_GbfsSystemInformation_start_date(ctx, field)
			case "phone_number":
				return ec.fieldContext_GbfsSystemInformation_phone_number(ctx, field)
			case "email":
				return ec.fieldContext_GbfsSystemInformation_email(ctx, field)
			case "feed_contact_email":
				return ec.fieldContext_GbfsSystemInformation_feed_contact_email(ctx, field)
			case "timezone":
				return ec.fieldContext_GbfsSystemInformation_timezone(ctx, field)
			case "license_url":
				return ec.fieldContext_GbfsSystemInformation_license_url(ctx, field)
			case "terms_url":
				return ec.fieldContext_GbfsSystemInformation_terms_url(ctx, field)
			case "terms_last_updated":
				return ec.fieldContext_GbfsSystemInformation_terms_last_updated(ctx, field)
			case "privacy_url":
				return ec.fieldContext_GbfsSystemInformation_privacy_url(ctx, field)
			case "privacy_last_updated":
				return ec.fieldContext_GbfsSystemInformation_privacy_last_updated(ctx, field)
			case "brand_assets":
				return ec.fieldContext_GbfsSystemInformation_brand_assets(ctx, field)
			case "rental_apps":
				return ec.fieldContext_GbfsSystemInformation_rental_apps(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_station_information(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_station_information(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_station_information(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_rental_hours(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_rental_hours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalHours(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemHour)
	fc.Result = res
	return ec.marshalOGbfsSystemHour2githubcominterlineiotransitlandservermodelGbfsSystemHour(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_rental_hours(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "user_types":
				return ec.fieldContext_GbfsSystemHour_user_types(ctx, field)
			case "days":
				return ec.fieldContext_GbfsSystemHour_days(ctx, field)
			case "start_time":
				return ec.fieldContext_GbfsSystemHour_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_GbfsSystemHour_end_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemHour", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_calendars(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_calendars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Calendars(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemCalendar)
	fc.Result = res
	return ec.marshalOGbfsSystemCalendar2githubcominterlineiotransitlandservermodelGbfsSystemCalendar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_calendars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start_month":
				return ec.fieldContext_GbfsSystemCalendar_start_month(ctx, field)
			case "start_day":
				return ec.fieldContext_GbfsSystemCalendar_start_day(ctx, field)
			case "start_year":
				return ec.fieldContext_GbfsSystemCalendar_start_year(ctx, field)
			case "end_month":
				return ec.fieldContext_GbfsSystemCalendar_end_month(ctx, field)
			case "end_day":
				return ec.fieldContext_GbfsSystemCalendar_end_day(ctx, field)
			case "end_year":
				return ec.fieldContext_GbfsSystemCalendar_end_year(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemCalendar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFeed_alerts(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFeed) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFeed_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alerts(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemAlert)
	fc.Result = res
	return ec.marshalOGbfsSystemAlert2githubcominterlineiotransitlandservermodelGbfsSystemAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFeed_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFeed",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alert_id":
				return ec.fieldContext_GbfsSystemAlert_alert_id(ctx, field)
			case "type":
				return ec.fieldContext_GbfsSystemAlert_type(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemAlert_url(ctx, field)
			case "summary":
				return ec.fieldContext_GbfsSystemAlert_summary(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemAlert_description(ctx, field)
			case "last_updated":
				return ec.fieldContext_GbfsSystemAlert_last_updated(ctx, field)
			case "times":
				return ec.fieldContext_GbfsSystemAlert_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemAlert", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_bike_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_bike_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BikeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_bike_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_lat(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_lat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_lon(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_lon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_is_reserved(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_is_reserved(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsReserved, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_is_reserved(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_is_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_is_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_is_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_last_reported(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_last_reported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastReported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_last_reported(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_current_range_meters(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_current_range_meters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentRangeMeters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_current_range_meters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_current_fuel_percent(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_current_fuel_percent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentFuelPercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_current_fuel_percent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_vehicle_equipment(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_vehicle_equipment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleEquipment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibtlttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_vehicle_equipment(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_available_until(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_available_until(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableUntil, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_available_until(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Station(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_station(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_home_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_home_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeStation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_home_station(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_pricing_plan(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_pricing_plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PricingPlan(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemPricingPlan)
	fc.Result = res
	return ec.marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandservermodelGbfsSystemPricingPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_pricing_plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plan_id":
				return ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
			case "currency":
				return ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
			case "price":
				return ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
			case "is_taxable":
				return ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
			case "surge_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
			case "per_km_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
			case "per_min_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemPricingPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_vehicle_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_vehicle_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_vehicle_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_rental_uris(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_rental_uris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalUris(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalUris)
	fc.Result = res
	return ec.marshalOGbfsRentalUris2githubcominterlineiotransitlandservermodelGbfsRentalUris(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_rental_uris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "android":
				return ec.fieldContext_GbfsRentalUris_android(ctx, field)
			case "ios":
				return ec.fieldContext_GbfsRentalUris_ios(ctx, field)
			case "web":
				return ec.fieldContext_GbfsRentalUris_web(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalUris", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsFreeBikeStatus_feed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsFreeBikeStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsFreeBikeStatus_feed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Feed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsFeed)
	fc.Result = res
	return ec.marshalOGbfsFeed2githubcominterlineiotransitlandservermodelGbfsFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsFreeBikeStatus_feed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsFreeBikeStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "system_information":
				return ec.fieldContext_GbfsFeed_system_information(ctx, field)
			case "station_information":
				return ec.fieldContext_GbfsFeed_station_information(ctx, field)
			case "rental_hours":
				return ec.fieldContext_GbfsFeed_rental_hours(ctx, field)
			case "calendars":
				return ec.fieldContext_GbfsFeed_calendars(ctx, field)
			case "alerts":
				return ec.fieldContext_GbfsFeed_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsFeed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceFeature_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceFeature_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceFeature_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceFeature_geometry(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceFeature) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceFeature_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceFeature_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceFeature",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_start(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_start(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_end(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_end(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceProperty_rules(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceProperty) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceProperty_rules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rules(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsGeofenceRule)
	fc.Result = res
	return ec.marshalOGbfsGeofenceRule2githubcominterlineiotransitlandservermodelGbfsGeofenceRule(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceProperty_rules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceProperty",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ride_allowed":
				return ec.fieldContext_GbfsGeofenceRule_ride_allowed(ctx, field)
			case "ride_through_allowed":
				return ec.fieldContext_GbfsGeofenceRule_ride_through_allowed(ctx, field)
			case "maximum_speed_kph":
				return ec.fieldContext_GbfsGeofenceRule_maximum_speed_kph(ctx, field)
			case "station_parking":
				return ec.fieldContext_GbfsGeofenceRule_station_parking(ctx, field)
			case "vehicle_type":
				return ec.fieldContext_GbfsGeofenceRule_vehicle_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsGeofenceRule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_ride_allowed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_ride_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RideAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_ride_allowed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_ride_through_allowed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_ride_through_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RideThroughAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_ride_through_allowed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_maximum_speed_kph(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_maximum_speed_kph(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaximumSpeedKph, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_maximum_speed_kph(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_station_parking(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_station_parking(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationParking, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_station_parking(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceRule_vehicle_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceRule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceRule_vehicle_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceRule_vehicle_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceRule",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceZone_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceZone_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceZone_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceZone",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsGeofenceZone_features(ctx context.Context, field graphql.CollectedField, obj *model.GbfsGeofenceZone) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsGeofenceZone_features(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Features(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsGeofenceFeature)
	fc.Result = res
	return ec.marshalOGbfsGeofenceFeature2githubcominterlineiotransitlandservermodelGbfsGeofenceFeature(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsGeofenceZone_features(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsGeofenceZone",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_GbfsGeofenceFeature_type(ctx, field)
			case "geometry":
				return ec.fieldContext_GbfsGeofenceFeature_geometry(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsGeofenceFeature", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_start(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_start(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_rate(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_rate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_rate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_interval(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_interval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_interval(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsPlanPrice_end(ctx context.Context, field graphql.CollectedField, obj *model.GbfsPlanPrice) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsPlanPrice_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsPlanPrice_end(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsPlanPrice",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApp_store_uri(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApp_store_uri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StoreURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApp_store_uri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApp",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApp_discovery_uri(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApp) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApp_discovery_uri(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiscoveryURI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApp_discovery_uri(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApp",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApps_ios(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApps) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApps_ios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ios(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalApp)
	fc.Result = res
	return ec.marshalOGbfsRentalApp2githubcominterlineiotransitlandservermodelGbfsRentalApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApps_ios(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApps",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "store_uri":
				return ec.fieldContext_GbfsRentalApp_store_uri(ctx, field)
			case "discovery_uri":
				return ec.fieldContext_GbfsRentalApp_discovery_uri(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalApp", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalApps_android(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalApps) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalApps_android(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Android(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalApp)
	fc.Result = res
	return ec.marshalOGbfsRentalApp2githubcominterlineiotransitlandservermodelGbfsRentalApp(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalApps_android(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalApps",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "store_uri":
				return ec.fieldContext_GbfsRentalApp_store_uri(ctx, field)
			case "discovery_uri":
				return ec.fieldContext_GbfsRentalApp_discovery_uri(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalApp", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalUris_android(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalUris) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalUris_android(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Android, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalUris_android(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalUris",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalUris_ios(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalUris) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalUris_ios(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IOS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalUris_ios(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalUris",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsRentalUris_web(ctx context.Context, field graphql.CollectedField, obj *model.GbfsRentalUris) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsRentalUris_web(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Web, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsRentalUris_web(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsRentalUris",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_station_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_station_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_short_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_short_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_lat(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_lat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_lon(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_lon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_address(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_cross_street(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CrossStreet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_cross_street(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_post_code(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_post_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_rental_methods(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalMethods, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibtlttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_rental_methods(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_is_virtual_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualStation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_is_virtual_station(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_station_area(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationArea, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_station_area(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_parking_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParkingType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_parking_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_parking_hoop(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParkingHoop, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_parking_hoop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_contact_phone(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContactPhone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_contact_phone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Capacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_is_valet_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsValetStation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_is_valet_station(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_is_charging_station(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsChargingStation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_is_charging_station(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_feed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_feed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Feed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsFeed)
	fc.Result = res
	return ec.marshalOGbfsFeed2githubcominterlineiotransitlandservermodelGbfsFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_feed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "system_information":
				return ec.fieldContext_GbfsFeed_system_information(ctx, field)
			case "station_information":
				return ec.fieldContext_GbfsFeed_station_information(ctx, field)
			case "rental_hours":
				return ec.fieldContext_GbfsFeed_rental_hours(ctx, field)
			case "calendars":
				return ec.fieldContext_GbfsFeed_calendars(ctx, field)
			case "alerts":
				return ec.fieldContext_GbfsFeed_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsFeed", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_region(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_region(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemRegion)
	fc.Result = res
	return ec.marshalOGbfsSystemRegion2githubcominterlineiotransitlandservermodelGbfsSystemRegion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_region(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "region_id":
				return ec.fieldContext_GbfsSystemRegion_region_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemRegion_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemRegion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationInformation_status(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationInformation_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsStationStatus)
	fc.Result = res
	return ec.marshalOGbfsStationStatus2githubcominterlineiotransitlandservermodelGbfsStationStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationInformation_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationStatus_station_id(ctx, field)
			case "num_bikes_available":
				return ec.fieldContext_GbfsStationStatus_num_bikes_available(ctx, field)
			case "num_bikes_disabled":
				return ec.fieldContext_GbfsStationStatus_num_bikes_disabled(ctx, field)
			case "num_docks_available":
				return ec.fieldContext_GbfsStationStatus_num_docks_available(ctx, field)
			case "num_docks_disabled":
				return ec.fieldContext_GbfsStationStatus_num_docks_disabled(ctx, field)
			case "is_returning":
				return ec.fieldContext_GbfsStationStatus_is_returning(ctx, field)
			case "is_renting":
				return ec.fieldContext_GbfsStationStatus_is_renting(ctx, field)
			case "is_installed":
				return ec.fieldContext_GbfsStationStatus_is_installed(ctx, field)
			case "last_reported":
				return ec.fieldContext_GbfsStationStatus_last_reported(ctx, field)
			case "vehicle_types_available":
				return ec.fieldContext_GbfsStationStatus_vehicle_types_available(ctx, field)
			case "vehicle_docks_available":
				return ec.fieldContext_GbfsStationStatus_vehicle_docks_available(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_station_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_station_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_station_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_bikes_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_bikes_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumBikesAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_bikes_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_bikes_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_bikes_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumBikesDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_bikes_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_docks_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_docks_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocksAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_docks_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_num_docks_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_num_docks_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocksDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_num_docks_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_is_returning(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_is_returning(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsReturning, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_is_returning(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_is_renting(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_is_renting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRenting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_is_renting(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_is_installed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_is_installed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsInstalled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_is_installed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_last_reported(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_last_reported(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastReported, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_last_reported(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_vehicle_types_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_vehicle_types_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleTypesAvailable(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsVehicleTypeAvailable)
	fc.Result = res
	return ec.marshalOGbfsVehicleTypeAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleTypeAvailable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_vehicle_types_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "num_bikes_disabled":
				return ec.fieldContext_GbfsVehicleTypeAvailable_num_bikes_disabled(ctx, field)
			case "num_docks_available":
				return ec.fieldContext_GbfsVehicleTypeAvailable_num_docks_available(ctx, field)
			case "count":
				return ec.fieldContext_GbfsVehicleTypeAvailable_count(ctx, field)
			case "vehicle_type":
				return ec.fieldContext_GbfsVehicleTypeAvailable_vehicle_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleTypeAvailable", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsStationStatus_vehicle_docks_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsStationStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsStationStatus_vehicle_docks_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleDocksAvailable(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsVehicleDockAvailable)
	fc.Result = res
	return ec.marshalOGbfsVehicleDockAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleDockAvailable(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsStationStatus_vehicle_docks_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsStationStatus",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_GbfsVehicleDockAvailable_count(ctx, field)
			case "vehicle_types":
				return ec.fieldContext_GbfsVehicleDockAvailable_vehicle_types(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleDockAvailable", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_alert_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_alert_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_alert_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_summary(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_summary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_description(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_last_updated(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_last_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_last_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemAlert_times(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemAlert) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemAlert_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Times(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsAlertTime)
	fc.Result = res
	return ec.marshalOGbfsAlertTime2githubcominterlineiotransitlandservermodelGbfsAlertTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemAlert_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemAlert",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_GbfsAlertTime_start(ctx, field)
			case "end":
				return ec.fieldContext_GbfsAlertTime_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsAlertTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_start_month(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_start_month(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartMonth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_start_month(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_start_day(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_start_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_start_day(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_start_year(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_start_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_start_year(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_end_month(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_end_month(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndMonth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_end_month(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_end_day(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_end_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndDay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_end_day(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemCalendar_end_year(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemCalendar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemCalendar_end_year(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndYear, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemCalendar_end_year(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemCalendar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_user_types(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_user_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibtlttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_user_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_days(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_days(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Days, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibtlttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_days(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_start_time(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemHour_end_time(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemHour) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemHour_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemHour_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemHour",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_system_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_system_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_system_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_language(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_short_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_short_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_operator(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_operator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Operator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_operator(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_purchase_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_purchase_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PurchaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_purchase_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_start_date(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_start_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_phone_number(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_phone_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PhoneNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_phone_number(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_email(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_feed_contact_email(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_feed_contact_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedContactEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_feed_contact_email(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_timezone(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_timezone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_license_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_license_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicenseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_license_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_terms_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_terms_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TermsURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_terms_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_terms_last_updated(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_terms_last_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TermsLastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_terms_last_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_privacy_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_privacy_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivacyURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_privacy_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_privacy_last_updated(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_privacy_last_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivacyLastUpdated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_privacy_last_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_brand_assets(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_brand_assets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BrandAssets(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsBrandAsset)
	fc.Result = res
	return ec.marshalOGbfsBrandAsset2githubcominterlineiotransitlandservermodelGbfsBrandAsset(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_brand_assets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "brand_last_modified":
				return ec.fieldContext_GbfsBrandAsset_brand_last_modified(ctx, field)
			case "brand_terms_url":
				return ec.fieldContext_GbfsBrandAsset_brand_terms_url(ctx, field)
			case "brand_image_url":
				return ec.fieldContext_GbfsBrandAsset_brand_image_url(ctx, field)
			case "brand_image_url_dark":
				return ec.fieldContext_GbfsBrandAsset_brand_image_url_dark(ctx, field)
			case "color":
				return ec.fieldContext_GbfsBrandAsset_color(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsBrandAsset", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemInformation_rental_apps(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemInformation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemInformation_rental_apps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalApps(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalApps)
	fc.Result = res
	return ec.marshalOGbfsRentalApps2githubcominterlineiotransitlandservermodelGbfsRentalApps(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemInformation_rental_apps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemInformation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ios":
				return ec.fieldContext_GbfsRentalApps_ios(ctx, field)
			case "android":
				return ec.fieldContext_GbfsRentalApps_android(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalApps", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_plan_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_plan_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_currency(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_currency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_price(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_price(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_is_taxable(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsTaxable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_is_taxable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_description(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_surge_pricing(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SurgePricing, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Bool)
	fc.Result = res
	return ec.marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Bool does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_per_km_pricing(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerKmPricing(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsPlanPrice)
	fc.Result = res
	return ec.marshalOGbfsPlanPrice2githubcominterlineiotransitlandservermodelGbfsPlanPrice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_GbfsPlanPrice_start(ctx, field)
			case "rate":
				return ec.fieldContext_GbfsPlanPrice_rate(ctx, field)
			case "interval":
				return ec.fieldContext_GbfsPlanPrice_interval(ctx, field)
			case "end":
				return ec.fieldContext_GbfsPlanPrice_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsPlanPrice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemPricingPlan_per_min_pricing(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemPricingPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerMinPricing(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsPlanPrice)
	fc.Result = res
	return ec.marshalOGbfsPlanPrice2githubcominterlineiotransitlandservermodelGbfsPlanPrice(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemPricingPlan",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "start":
				return ec.fieldContext_GbfsPlanPrice_start(ctx, field)
			case "rate":
				return ec.fieldContext_GbfsPlanPrice_rate(ctx, field)
			case "interval":
				return ec.fieldContext_GbfsPlanPrice_interval(ctx, field)
			case "end":
				return ec.fieldContext_GbfsPlanPrice_end(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsPlanPrice", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemRegion_region_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemRegion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemRegion_region_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemRegion_region_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemRegion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemRegion_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemRegion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemRegion_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemRegion_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemRegion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemVersion_version(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemVersion_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsSystemVersion_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsSystemVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsSystemVersion_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsSystemVersion_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsSystemVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleAssets_icon_url(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleAssets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleAssets_icon_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleAssets_icon_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleAssets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleAssets_icon_url_dark(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleAssets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleAssets_icon_url_dark(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconURLDark, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleAssets_icon_url_dark(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleAssets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleAssets_icon_last_modified(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleAssets) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleAssets_icon_last_modified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IconLastModified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleAssets_icon_last_modified(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleAssets",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleDockAvailable_count(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleDockAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleDockAvailable_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleDockAvailable_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleDockAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleDockAvailable_vehicle_types(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleDockAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleDockAvailable_vehicle_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleDockAvailable_vehicle_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleDockAvailable",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_type_id(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleTypeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_type_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_form_factor(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_form_factor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_rider_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RiderCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_rider_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_cargo_volume_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CargoVolumeCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_cargo_load_capacity(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CargoLoadCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_cargo_load_capacity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_propulsion_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PropulsionType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_propulsion_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_eco_label(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EcoLabel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_eco_label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_country_code(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CountryCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_country_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_eco_sticker(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EcoSticker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_eco_sticker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_max_range_meters(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxRangeMeters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_max_range_meters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_name(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_accessories(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleAccessories, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Strings)
	fc.Result = res
	return ec.marshalOStrings2githubcominterlineiotransitlandlibtlttStrings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_accessories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Strings does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_gco_2_km(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GCO2Km, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_gco_2_km(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_image(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleImage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_make(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_make(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Make, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_make(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_model(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_model(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Model, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_model(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_color(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_color(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_wheel_count(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WheelCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_wheel_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_max_permitted_speed(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPermittedSpeed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_max_permitted_speed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_rated_power(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RatedPower, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_rated_power(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_default_reserve_time(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultReserveTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_default_reserve_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_return_constraint(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReturnConstraint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_return_constraint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_default_pricing_plan(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultPricingPlan(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsSystemPricingPlan)
	fc.Result = res
	return ec.marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandservermodelGbfsSystemPricingPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_default_pricing_plan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plan_id":
				return ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
			case "currency":
				return ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
			case "price":
				return ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
			case "is_taxable":
				return ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
			case "surge_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
			case "per_km_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
			case "per_min_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemPricingPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_pricing_plans(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PricingPlans(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsSystemPricingPlan)
	fc.Result = res
	return ec.marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandservermodelGbfsSystemPricingPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_pricing_plans(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "plan_id":
				return ec.fieldContext_GbfsSystemPricingPlan_plan_id(ctx, field)
			case "url":
				return ec.fieldContext_GbfsSystemPricingPlan_url(ctx, field)
			case "name":
				return ec.fieldContext_GbfsSystemPricingPlan_name(ctx, field)
			case "currency":
				return ec.fieldContext_GbfsSystemPricingPlan_currency(ctx, field)
			case "price":
				return ec.fieldContext_GbfsSystemPricingPlan_price(ctx, field)
			case "is_taxable":
				return ec.fieldContext_GbfsSystemPricingPlan_is_taxable(ctx, field)
			case "description":
				return ec.fieldContext_GbfsSystemPricingPlan_description(ctx, field)
			case "surge_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_surge_pricing(ctx, field)
			case "per_km_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_km_pricing(ctx, field)
			case "per_min_pricing":
				return ec.fieldContext_GbfsSystemPricingPlan_per_min_pricing(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsSystemPricingPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_rental_uris(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RentalUris(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsRentalUris)
	fc.Result = res
	return ec.marshalOGbfsRentalUris2githubcominterlineiotransitlandservermodelGbfsRentalUris(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_rental_uris(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "android":
				return ec.fieldContext_GbfsRentalUris_android(ctx, field)
			case "ios":
				return ec.fieldContext_GbfsRentalUris_ios(ctx, field)
			case "web":
				return ec.fieldContext_GbfsRentalUris_web(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsRentalUris", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleType_vehicle_assets(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleAssets(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleAssets)
	fc.Result = res
	return ec.marshalOGbfsVehicleAssets2githubcominterlineiotransitlandservermodelGbfsVehicleAssets(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleType_vehicle_assets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleType",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "icon_url":
				return ec.fieldContext_GbfsVehicleAssets_icon_url(ctx, field)
			case "icon_url_dark":
				return ec.fieldContext_GbfsVehicleAssets_icon_url_dark(ctx, field)
			case "icon_last_modified":
				return ec.fieldContext_GbfsVehicleAssets_icon_last_modified(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleAssets", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_num_bikes_disabled(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_num_bikes_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumBikesDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_num_bikes_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_num_docks_available(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_num_docks_available(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDocksAvailable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_num_docks_available(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_count(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GbfsVehicleTypeAvailable_vehicle_type(ctx context.Context, field graphql.CollectedField, obj *model.GbfsVehicleTypeAvailable) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GbfsVehicleTypeAvailable_vehicle_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VehicleType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GbfsVehicleType)
	fc.Result = res
	return ec.marshalOGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GbfsVehicleTypeAvailable_vehicle_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GbfsVehicleTypeAvailable",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "vehicle_type_id":
				return ec.fieldContext_GbfsVehicleType_vehicle_type_id(ctx, field)
			case "form_factor":
				return ec.fieldContext_GbfsVehicleType_form_factor(ctx, field)
			case "rider_capacity":
				return ec.fieldContext_GbfsVehicleType_rider_capacity(ctx, field)
			case "cargo_volume_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_volume_capacity(ctx, field)
			case "cargo_load_capacity":
				return ec.fieldContext_GbfsVehicleType_cargo_load_capacity(ctx, field)
			case "propulsion_type":
				return ec.fieldContext_GbfsVehicleType_propulsion_type(ctx, field)
			case "eco_label":
				return ec.fieldContext_GbfsVehicleType_eco_label(ctx, field)
			case "country_code":
				return ec.fieldContext_GbfsVehicleType_country_code(ctx, field)
			case "eco_sticker":
				return ec.fieldContext_GbfsVehicleType_eco_sticker(ctx, field)
			case "max_range_meters":
				return ec.fieldContext_GbfsVehicleType_max_range_meters(ctx, field)
			case "name":
				return ec.fieldContext_GbfsVehicleType_name(ctx, field)
			case "vehicle_accessories":
				return ec.fieldContext_GbfsVehicleType_vehicle_accessories(ctx, field)
			case "gco_2_km":
				return ec.fieldContext_GbfsVehicleType_gco_2_km(ctx, field)
			case "vehicle_image":
				return ec.fieldContext_GbfsVehicleType_vehicle_image(ctx, field)
			case "make":
				return ec.fieldContext_GbfsVehicleType_make(ctx, field)
			case "model":
				return ec.fieldContext_GbfsVehicleType_model(ctx, field)
			case "color":
				return ec.fieldContext_GbfsVehicleType_color(ctx, field)
			case "wheel_count":
				return ec.fieldContext_GbfsVehicleType_wheel_count(ctx, field)
			case "max_permitted_speed":
				return ec.fieldContext_GbfsVehicleType_max_permitted_speed(ctx, field)
			case "rated_power":
				return ec.fieldContext_GbfsVehicleType_rated_power(ctx, field)
			case "default_reserve_time":
				return ec.fieldContext_GbfsVehicleType_default_reserve_time(ctx, field)
			case "return_constraint":
				return ec.fieldContext_GbfsVehicleType_return_constraint(ctx, field)
			case "default_pricing_plan":
				return ec.fieldContext_GbfsVehicleType_default_pricing_plan(ctx, field)
			case "pricing_plans":
				return ec.fieldContext_GbfsVehicleType_pricing_plans(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsVehicleType_rental_uris(ctx, field)
			case "vehicle_assets":
				return ec.fieldContext_GbfsVehicleType_vehicle_assets(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsVehicleType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_duration(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalNDuration2githubcominterlineiotransitlandservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_distance(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalNDistance2githubcominterlineiotransitlandservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_from(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalNWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_from(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_to(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_to(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalNWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_to(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Itinerary_legs(ctx context.Context, field graphql.CollectedField, obj *model.Itinerary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Itinerary_legs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Legs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Leg)
	fc.Result = res
	return ec.marshalOLeg2githubcominterlineiotransitlandservermodelLeg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Itinerary_legs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Itinerary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Leg_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Leg_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Leg_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Leg_end_time(ctx, field)
			case "from":
				return ec.fieldContext_Leg_from(ctx, field)
			case "to":
				return ec.fieldContext_Leg_to(ctx, field)
			case "steps":
				return ec.fieldContext_Leg_steps(ctx, field)
			case "geometry":
				return ec.fieldContext_Leg_geometry(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Leg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_duration(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalNDuration2githubcominterlineiotransitlandservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_distance(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalNDistance2githubcominterlineiotransitlandservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_from(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_from(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_to(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_to(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_to(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_steps(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_steps(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Steps, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Step)
	fc.Result = res
	return ec.marshalOStep2githubcominterlineiotransitlandservermodelStep(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_steps(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Step_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Step_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Step_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Step_end_time(ctx, field)
			case "to":
				return ec.fieldContext_Step_to(ctx, field)
			case "mode":
				return ec.fieldContext_Step_mode(ctx, field)
			case "instruction":
				return ec.fieldContext_Step_instruction(ctx, field)
			case "geometry_offset":
				return ec.fieldContext_Step_geometry_offset(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Step", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Leg_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Leg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Leg_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.LineString)
	fc.Result = res
	return ec.marshalNLineString2githubcominterlineiotransitlandlibtlttLineString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Leg_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Leg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LineString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_id(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_level_id(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_level_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_level_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_level_name(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_level_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_level_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_level_index(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_level_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LevelIndex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_level_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Polygon)
	fc.Result = res
	return ec.marshalNPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Level_stops(ctx context.Context, field graphql.CollectedField, obj *model.Level) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Level_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Level().Stops(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Level_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Level",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_validate_gtfs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_validate_gtfs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().ValidateGtfs(rctx, fc.Args["file"].(*graphql.Upload), fc.Args["url"].(*string), fc.Args["realtime_urls"].([]string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx, "USER")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.ValidationResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/interline-io/transitland-server/model.ValidationResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ValidationResult)
	fc.Result = res
	return ec.marshalOValidationResult2githubcominterlineiotransitlandservermodelValidationResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_validate_gtfs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_ValidationResult_success(ctx, field)
			case "failure_reason":
				return ec.fieldContext_ValidationResult_failure_reason(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResult_errors(ctx, field)
			case "warnings":
				return ec.fieldContext_ValidationResult_warnings(ctx, field)
			case "sha1":
				return ec.fieldContext_ValidationResult_sha1(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_ValidationResult_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_ValidationResult_latest_calendar_date(ctx, field)
			case "files":
				return ec.fieldContext_ValidationResult_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_ValidationResult_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_ValidationResult_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_ValidationResult_routes(ctx, field)
			case "stops":
				return ec.fieldContext_ValidationResult_stops(ctx, field)
			case "feed_infos":
				return ec.fieldContext_ValidationResult_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_validate_gtfs_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_update(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_update(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FeedVersionUpdate(rctx, fc.Args["id"].(int), fc.Args["set"].(model.FeedVersionSetInput))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.FeedVersion); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/interline-io/transitland-server/model.FeedVersion`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalOFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_update(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_update_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_fetch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_fetch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FeedVersionFetch(rctx, fc.Args["file"].(*graphql.Upload), fc.Args["url"].(*string), fc.Args["feed_onestop_id"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.FeedVersionFetchResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/interline-io/transitland-server/model.FeedVersionFetchResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionFetchResult)
	fc.Result = res
	return ec.marshalOFeedVersionFetchResult2githubcominterlineiotransitlandservermodelFeedVersionFetchResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_fetch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "feed_version":
				return ec.fieldContext_FeedVersionFetchResult_feed_version(ctx, field)
			case "fetch_error":
				return ec.fieldContext_FeedVersionFetchResult_fetch_error(ctx, field)
			case "found_sha1":
				return ec.fieldContext_FeedVersionFetchResult_found_sha1(ctx, field)
			case "found_dir_sha1":
				return ec.fieldContext_FeedVersionFetchResult_found_dir_sha1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionFetchResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_fetch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_import(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_import(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FeedVersionImport(rctx, fc.Args["sha1"].(string))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.FeedVersionImportResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/interline-io/transitland-server/model.FeedVersionImportResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionImportResult)
	fc.Result = res
	return ec.marshalNFeedVersionImportResult2githubcominterlineiotransitlandservermodelFeedVersionImportResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_import(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_FeedVersionImportResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionImportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_import_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_unimport(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_unimport(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FeedVersionUnimport(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.FeedVersionUnimportResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/interline-io/transitland-server/model.FeedVersionUnimportResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionUnimportResult)
	fc.Result = res
	return ec.marshalNFeedVersionUnimportResult2githubcominterlineiotransitlandservermodelFeedVersionUnimportResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_unimport(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_FeedVersionUnimportResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionUnimportResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_unimport_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_feed_version_delete(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_feed_version_delete(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().FeedVersionDelete(rctx, fc.Args["id"].(int))
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			role, err := ec.unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx, "ADMIN")
			if err != nil {
				return nil, err
			}
			if ec.directives.HasRole == nil {
				return nil, errors.New("directive hasRole is not implemented")
			}
			return ec.directives.HasRole(ctx, nil, directive0, role)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.FeedVersionDeleteResult); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/interline-io/transitland-server/model.FeedVersionDeleteResult`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersionDeleteResult)
	fc.Result = res
	return ec.marshalNFeedVersionDeleteResult2githubcominterlineiotransitlandservermodelFeedVersionDeleteResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_feed_version_delete(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_FeedVersionDeleteResult_success(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionDeleteResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_feed_version_delete_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Operator_id(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_generated(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_generated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Generated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_generated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_file(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_file(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.File, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_file(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_name(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_short_name(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_short_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_website(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_website(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Website, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_website(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_tags(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Tags)
	fc.Result = res
	return ec.marshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_tags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Tags does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_search_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_agencies(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Operator().Agencies(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Agency)
	fc.Result = res
	return ec.marshalOAgency2githubcominterlineiotransitlandservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_agencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Operator_feeds(ctx context.Context, field graphql.CollectedField, obj *model.Operator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Operator_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Operator().Feeds(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.FeedFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalOFeed2githubcominterlineiotransitlandservermodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Operator_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Operator",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Feed_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "file":
				return ec.fieldContext_Feed_file(ctx, field)
			case "spec":
				return ec.fieldContext_Feed_spec(ctx, field)
			case "languages":
				return ec.fieldContext_Feed_languages(ctx, field)
			case "tags":
				return ec.fieldContext_Feed_tags(ctx, field)
			case "authorization":
				return ec.fieldContext_Feed_authorization(ctx, field)
			case "urls":
				return ec.fieldContext_Feed_urls(ctx, field)
			case "license":
				return ec.fieldContext_Feed_license(ctx, field)
			case "search_rank":
				return ec.fieldContext_Feed_search_rank(ctx, field)
			case "associated_operators":
				return ec.fieldContext_Feed_associated_operators(ctx, field)
			case "feed_state":
				return ec.fieldContext_Feed_feed_state(ctx, field)
			case "feed_fetches":
				return ec.fieldContext_Feed_feed_fetches(ctx, field)
			case "feed_versions":
				return ec.fieldContext_Feed_feed_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Operator_feeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_id(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_pathway_id(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_pathway_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathwayID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_pathway_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_pathway_mode(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_pathway_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PathwayMode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_pathway_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_is_bidirectional(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_is_bidirectional(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsBidirectional, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_is_bidirectional(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_length(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Length, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_length(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_traversal_time(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_traversal_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraversalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_traversal_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_stair_count(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_stair_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StairCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_stair_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_max_slope(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_max_slope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxSlope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_max_slope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_min_width(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_min_width(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinWidth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_min_width(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_signposted_as(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_signposted_as(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SignpostedAs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_signposted_as(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_reverse_signposted_as(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReverseSignpostedAs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_reverse_signposted_as(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_from_stop(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_from_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pathway().FromStop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_from_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pathway_to_stop(ctx context.Context, field graphql.CollectedField, obj *model.Pathway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pathway_to_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pathway().ToStop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pathway_to_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pathway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_adm0_name(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_adm0_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm0Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_adm0_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_adm1_name(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_adm1_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Adm1Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_adm1_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_city_name(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_city_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CityName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_city_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_count(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Place().Count(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Place_operators(ctx context.Context, field graphql.CollectedField, obj *model.Place) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Place_operators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Place().Operators(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Operator)
	fc.Result = res
	return ec.marshalOOperator2githubcominterlineiotransitlandservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Place_operators(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Place",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_feed_versions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_feed_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().FeedVersions(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.FeedVersionFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_feed_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_feed_versions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_feeds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_feeds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Feeds(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.FeedFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Feed)
	fc.Result = res
	return ec.marshalNFeed2githubcominterlineiotransitlandservermodelFeed(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_feeds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Feed_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Feed_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Feed_name(ctx, field)
			case "file":
				return ec.fieldContext_Feed_file(ctx, field)
			case "spec":
				return ec.fieldContext_Feed_spec(ctx, field)
			case "languages":
				return ec.fieldContext_Feed_languages(ctx, field)
			case "tags":
				return ec.fieldContext_Feed_tags(ctx, field)
			case "authorization":
				return ec.fieldContext_Feed_authorization(ctx, field)
			case "urls":
				return ec.fieldContext_Feed_urls(ctx, field)
			case "license":
				return ec.fieldContext_Feed_license(ctx, field)
			case "search_rank":
				return ec.fieldContext_Feed_search_rank(ctx, field)
			case "associated_operators":
				return ec.fieldContext_Feed_associated_operators(ctx, field)
			case "feed_state":
				return ec.fieldContext_Feed_feed_state(ctx, field)
			case "feed_fetches":
				return ec.fieldContext_Feed_feed_fetches(ctx, field)
			case "feed_versions":
				return ec.fieldContext_Feed_feed_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Feed", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_feeds_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_agencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Agencies(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.AgencyFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_agencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_agencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_routes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Routes(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.RouteFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_stops(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Stops(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.StopFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_trips(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Trips(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.TripFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_operators(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_operators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Operators(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["ids"].([]int), fc.Args["where"].(*model.OperatorFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Operator)
	fc.Result = res
	return ec.marshalNOperator2githubcominterlineiotransitlandservermodelOperator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_operators(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Operator_id(ctx, field)
			case "generated":
				return ec.fieldContext_Operator_generated(ctx, field)
			case "file":
				return ec.fieldContext_Operator_file(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Operator_onestop_id(ctx, field)
			case "name":
				return ec.fieldContext_Operator_name(ctx, field)
			case "short_name":
				return ec.fieldContext_Operator_short_name(ctx, field)
			case "website":
				return ec.fieldContext_Operator_website(ctx, field)
			case "tags":
				return ec.fieldContext_Operator_tags(ctx, field)
			case "search_rank":
				return ec.fieldContext_Operator_search_rank(ctx, field)
			case "agencies":
				return ec.fieldContext_Operator_agencies(ctx, field)
			case "feeds":
				return ec.fieldContext_Operator_feeds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Operator", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_operators_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_directions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_directions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Directions(rctx, fc.Args["where"].(model.DirectionRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Directions)
	fc.Result = res
	return ec.marshalNDirections2githubcominterlineiotransitlandservermodelDirections(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_directions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_Directions_success(ctx, field)
			case "exception":
				return ec.fieldContext_Directions_exception(ctx, field)
			case "data_source":
				return ec.fieldContext_Directions_data_source(ctx, field)
			case "origin":
				return ec.fieldContext_Directions_origin(ctx, field)
			case "destination":
				return ec.fieldContext_Directions_destination(ctx, field)
			case "duration":
				return ec.fieldContext_Directions_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Directions_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Directions_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Directions_end_time(ctx, field)
			case "itineraries":
				return ec.fieldContext_Directions_itineraries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Directions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_directions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_bikes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bikes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Bikes(rctx, fc.Args["limit"].(*int), fc.Args["where"].(*model.GbfsBikeRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsFreeBikeStatus)
	fc.Result = res
	return ec.marshalOGbfsFreeBikeStatus2githubcominterlineiotransitlandservermodelGbfsFreeBikeStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bikes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bike_id":
				return ec.fieldContext_GbfsFreeBikeStatus_bike_id(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsFreeBikeStatus_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsFreeBikeStatus_lon(ctx, field)
			case "is_reserved":
				return ec.fieldContext_GbfsFreeBikeStatus_is_reserved(ctx, field)
			case "is_disabled":
				return ec.fieldContext_GbfsFreeBikeStatus_is_disabled(ctx, field)
			case "last_reported":
				return ec.fieldContext_GbfsFreeBikeStatus_last_reported(ctx, field)
			case "current_range_meters":
				return ec.fieldContext_GbfsFreeBikeStatus_current_range_meters(ctx, field)
			case "current_fuel_percent":
				return ec.fieldContext_GbfsFreeBikeStatus_current_fuel_percent(ctx, field)
			case "vehicle_equipment":
				return ec.fieldContext_GbfsFreeBikeStatus_vehicle_equipment(ctx, field)
			case "available_until":
				return ec.fieldContext_GbfsFreeBikeStatus_available_until(ctx, field)
			case "station":
				return ec.fieldContext_GbfsFreeBikeStatus_station(ctx, field)
			case "home_station":
				return ec.fieldContext_GbfsFreeBikeStatus_home_station(ctx, field)
			case "pricing_plan":
				return ec.fieldContext_GbfsFreeBikeStatus_pricing_plan(ctx, field)
			case "vehicle_type":
				return ec.fieldContext_GbfsFreeBikeStatus_vehicle_type(ctx, field)
			case "rental_uris":
				return ec.fieldContext_GbfsFreeBikeStatus_rental_uris(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsFreeBikeStatus_feed(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsFreeBikeStatus", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bikes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_docks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_docks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Docks(rctx, fc.Args["limit"].(*int), fc.Args["where"].(*model.GbfsDockRequest))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.GbfsStationInformation)
	fc.Result = res
	return ec.marshalOGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_docks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "station_id":
				return ec.fieldContext_GbfsStationInformation_station_id(ctx, field)
			case "name":
				return ec.fieldContext_GbfsStationInformation_name(ctx, field)
			case "short_name":
				return ec.fieldContext_GbfsStationInformation_short_name(ctx, field)
			case "lat":
				return ec.fieldContext_GbfsStationInformation_lat(ctx, field)
			case "lon":
				return ec.fieldContext_GbfsStationInformation_lon(ctx, field)
			case "address":
				return ec.fieldContext_GbfsStationInformation_address(ctx, field)
			case "cross_street":
				return ec.fieldContext_GbfsStationInformation_cross_street(ctx, field)
			case "post_code":
				return ec.fieldContext_GbfsStationInformation_post_code(ctx, field)
			case "rental_methods":
				return ec.fieldContext_GbfsStationInformation_rental_methods(ctx, field)
			case "is_virtual_station":
				return ec.fieldContext_GbfsStationInformation_is_virtual_station(ctx, field)
			case "station_area":
				return ec.fieldContext_GbfsStationInformation_station_area(ctx, field)
			case "parking_type":
				return ec.fieldContext_GbfsStationInformation_parking_type(ctx, field)
			case "parking_hoop":
				return ec.fieldContext_GbfsStationInformation_parking_hoop(ctx, field)
			case "contact_phone":
				return ec.fieldContext_GbfsStationInformation_contact_phone(ctx, field)
			case "capacity":
				return ec.fieldContext_GbfsStationInformation_capacity(ctx, field)
			case "is_valet_station":
				return ec.fieldContext_GbfsStationInformation_is_valet_station(ctx, field)
			case "is_charging_station":
				return ec.fieldContext_GbfsStationInformation_is_charging_station(ctx, field)
			case "feed":
				return ec.fieldContext_GbfsStationInformation_feed(ctx, field)
			case "region":
				return ec.fieldContext_GbfsStationInformation_region(ctx, field)
			case "status":
				return ec.fieldContext_GbfsStationInformation_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GbfsStationInformation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_docks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_places(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_places(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Places(rctx, fc.Args["limit"].(*int), fc.Args["after"].(*int), fc.Args["level"].(*model.PlaceAggregationLevel), fc.Args["where"].(*model.PlaceFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Place)
	fc.Result = res
	return ec.marshalOPlace2githubcominterlineiotransitlandservermodelPlace(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_places(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adm0_name":
				return ec.fieldContext_Place_adm0_name(ctx, field)
			case "adm1_name":
				return ec.fieldContext_Place_adm1_name(ctx, field)
			case "city_name":
				return ec.fieldContext_Place_city_name(ctx, field)
			case "count":
				return ec.fieldContext_Place_count(ctx, field)
			case "operators":
				return ec.fieldContext_Place_operators(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Place", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_places_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTimeRange_start(ctx context.Context, field graphql.CollectedField, obj *model.RTTimeRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTimeRange_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTimeRange_start(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTimeRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTimeRange_end(ctx context.Context, field graphql.CollectedField, obj *model.RTTimeRange) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTimeRange_end(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.End, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTimeRange_end(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTimeRange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTranslation_text(ctx context.Context, field graphql.CollectedField, obj *model.RTTranslation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTranslation_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTranslation_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTranslation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTranslation_language(ctx context.Context, field graphql.CollectedField, obj *model.RTTranslation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTranslation_language(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Language, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTranslation_language(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTranslation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_trip_id(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_trip_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_route_id(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_route_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_direction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_start_time(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_start_date(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_start_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTTripDescriptor_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.RTTripDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTTripDescriptor_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduleRelationship, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTTripDescriptor_schedule_relationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTTripDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTVehicleDescriptor_id(ctx context.Context, field graphql.CollectedField, obj *model.RTVehicleDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTVehicleDescriptor_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTVehicleDescriptor_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTVehicleDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTVehicleDescriptor_label(ctx context.Context, field graphql.CollectedField, obj *model.RTVehicleDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTVehicleDescriptor_label(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTVehicleDescriptor_label(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTVehicleDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RTVehicleDescriptor_license_plate(ctx context.Context, field graphql.CollectedField, obj *model.RTVehicleDescriptor) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RTVehicleDescriptor_license_plate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LicensePlate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RTVehicleDescriptor_license_plate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RTVehicleDescriptor",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_short_name(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_short_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_long_name(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_long_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteLongName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_long_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_type(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_color(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_color(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_text_color(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_text_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteTextColor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_text_color(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_sort_order(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_sort_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteSortOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_sort_order(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_url(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_desc(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_continuous_pickup(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_continuous_pickup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousPickup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_continuous_pickup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_continuous_drop_off(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_continuous_drop_off(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousDropOff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_continuous_drop_off(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Geometry(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_agency(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_agency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Agency(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_agency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_feed_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_feed_version_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_feed_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_search_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_attribute(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_attribute(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().RouteAttribute(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RouteAttribute)
	fc.Result = res
	return ec.marshalORouteAttribute2githubcominterlineiotransitlandservermodelRouteAttribute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_attribute(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "category":
				return ec.fieldContext_RouteAttribute_category(ctx, field)
			case "subcategory":
				return ec.fieldContext_RouteAttribute_subcategory(ctx, field)
			case "running_way":
				return ec.fieldContext_RouteAttribute_running_way(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteAttribute", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_trips(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Trips(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.TripFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Route_stops(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Stops(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_stops(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().RouteStops(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteStop)
	fc.Result = res
	return ec.marshalNRouteStop2githubcominterlineiotransitlandservermodelRouteStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RouteStop_id(ctx, field)
			case "stop_id":
				return ec.fieldContext_RouteStop_stop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_RouteStop_route_id(ctx, field)
			case "agency_id":
				return ec.fieldContext_RouteStop_agency_id(ctx, field)
			case "route":
				return ec.fieldContext_RouteStop_route(ctx, field)
			case "stop":
				return ec.fieldContext_RouteStop_stop(ctx, field)
			case "agency":
				return ec.fieldContext_RouteStop_agency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_route_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Route_headways(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_headways(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Headways(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteHeadway)
	fc.Result = res
	return ec.marshalNRouteHeadway2githubcominterlineiotransitlandservermodelRouteHeadway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_headways(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop":
				return ec.fieldContext_RouteHeadway_stop(ctx, field)
			case "dow_category":
				return ec.fieldContext_RouteHeadway_dow_category(ctx, field)
			case "direction_id":
				return ec.fieldContext_RouteHeadway_direction_id(ctx, field)
			case "headway_secs":
				return ec.fieldContext_RouteHeadway_headway_secs(ctx, field)
			case "service_date":
				return ec.fieldContext_RouteHeadway_service_date(ctx, field)
			case "stop_trip_count":
				return ec.fieldContext_RouteHeadway_stop_trip_count(ctx, field)
			case "departures":
				return ec.fieldContext_RouteHeadway_departures(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteHeadway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_headways_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Route_geometries(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_geometries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Geometries(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteGeometry)
	fc.Result = res
	return ec.marshalNRouteGeometry2githubcominterlineiotransitlandservermodelRouteGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_geometries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "generated":
				return ec.fieldContext_RouteGeometry_generated(ctx, field)
			case "geometry":
				return ec.fieldContext_RouteGeometry_geometry(ctx, field)
			case "combined_geometry":
				return ec.fieldContext_RouteGeometry_combined_geometry(ctx, field)
			case "length":
				return ec.fieldContext_RouteGeometry_length(ctx, field)
			case "max_segment_length":
				return ec.fieldContext_RouteGeometry_max_segment_length(ctx, field)
			case "first_point_max_distance":
				return ec.fieldContext_RouteGeometry_first_point_max_distance(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteGeometry", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_geometries_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Route_census_geographies(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_census_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().CensusGeographies(rctx, obj, fc.Args["layer"].(string), fc.Args["radius"].(*float64), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_census_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_census_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Route_route_stop_buffer(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_route_stop_buffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().RouteStopBuffer(rctx, obj, fc.Args["radius"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.RouteStopBuffer)
	fc.Result = res
	return ec.marshalNRouteStopBuffer2githubcominterlineiotransitlandservermodelRouteStopBuffer(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_route_stop_buffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_points":
				return ec.fieldContext_RouteStopBuffer_stop_points(ctx, field)
			case "stop_buffer":
				return ec.fieldContext_RouteStopBuffer_stop_buffer(ctx, field)
			case "stop_convexhull":
				return ec.fieldContext_RouteStopBuffer_stop_convexhull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStopBuffer", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_route_stop_buffer_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Route_patterns(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_patterns(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Patterns(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.RouteStopPattern)
	fc.Result = res
	return ec.marshalORouteStopPattern2githubcominterlineiotransitlandservermodelRouteStopPattern(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_patterns(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_pattern_id":
				return ec.fieldContext_RouteStopPattern_stop_pattern_id(ctx, field)
			case "direction_id":
				return ec.fieldContext_RouteStopPattern_direction_id(ctx, field)
			case "count":
				return ec.fieldContext_RouteStopPattern_count(ctx, field)
			case "trips":
				return ec.fieldContext_RouteStopPattern_trips(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStopPattern", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Route_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Route) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Route_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Route().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Route_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Route",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Route_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _RouteAttribute_category(ctx context.Context, field graphql.CollectedField, obj *model.RouteAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteAttribute_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Category, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteAttribute_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteAttribute_subcategory(ctx context.Context, field graphql.CollectedField, obj *model.RouteAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteAttribute_subcategory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subcategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteAttribute_subcategory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteAttribute_running_way(ctx context.Context, field graphql.CollectedField, obj *model.RouteAttribute) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteAttribute_running_way(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunningWay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteAttribute_running_way(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteAttribute",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_generated(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_generated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Generated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_generated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_geometry(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.LineString)
	fc.Result = res
	return ec.marshalOLineString2githubcominterlineiotransitlandlibtlttLineString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LineString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_combined_geometry(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_combined_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CombinedGeometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_combined_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_length(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Length, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_length(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_max_segment_length(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_max_segment_length(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxSegmentLength, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_max_segment_length(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteGeometry_first_point_max_distance(ctx context.Context, field graphql.CollectedField, obj *model.RouteGeometry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteGeometry_first_point_max_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstPointMaxDistance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteGeometry_first_point_max_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteGeometry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_stop(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteHeadway().Stop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_dow_category(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_dow_category(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DowCategory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_dow_category(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_direction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_headway_secs(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_headway_secs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadwaySecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_headway_secs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_service_date(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_service_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_service_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_stop_trip_count(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_stop_trip_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTripCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_stop_trip_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteHeadway_departures(ctx context.Context, field graphql.CollectedField, obj *model.RouteHeadway) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteHeadway_departures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteHeadway().Departures(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteHeadway_departures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteHeadway",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_stop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_route_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_route_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_agency_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_agency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_route(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStop().Route(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_stop(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStop().Stop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStop_agency(ctx context.Context, field graphql.CollectedField, obj *model.RouteStop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStop_agency(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStop().Agency(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStop_agency(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopBuffer_stop_points(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopBuffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopBuffer_stop_points(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopPoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopBuffer_stop_points(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopBuffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopBuffer_stop_buffer(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopBuffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopBuffer_stop_buffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopBuffer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Geometry)
	fc.Result = res
	return ec.marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopBuffer_stop_buffer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopBuffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Geometry does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopBuffer_stop_convexhull(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopBuffer) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopBuffer_stop_convexhull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopConvexhull, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Polygon)
	fc.Result = res
	return ec.marshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopBuffer_stop_convexhull(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopBuffer",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Polygon does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_stop_pattern_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_stop_pattern_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopPatternID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_stop_pattern_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_direction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_count(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RouteStopPattern_trips(ctx context.Context, field graphql.CollectedField, obj *model.RouteStopPattern) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RouteStopPattern_trips(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RouteStopPattern().Trips(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Trip)
	fc.Result = res
	return ec.marshalOTrip2githubcominterlineiotransitlandservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RouteStopPattern_trips(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RouteStopPattern",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_RouteStopPattern_trips_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Shape_id(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shape_shape_id(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_shape_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShapeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_shape_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shape_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.LineString)
	fc.Result = res
	return ec.marshalNLineString2githubcominterlineiotransitlandlibtlttLineString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type LineString does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Shape_generated(ctx context.Context, field graphql.CollectedField, obj *model.Shape) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Shape_generated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Generated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Shape_generated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Shape",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_duration(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Duration)
	fc.Result = res
	return ec.marshalNDuration2githubcominterlineiotransitlandservermodelDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "duration":
				return ec.fieldContext_Duration_duration(ctx, field)
			case "units":
				return ec.fieldContext_Duration_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Duration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_distance(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_distance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Distance)
	fc.Result = res
	return ec.marshalNDistance2githubcominterlineiotransitlandservermodelDistance(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_distance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distance":
				return ec.fieldContext_Distance_distance(ctx, field)
			case "units":
				return ec.fieldContext_Distance_units(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distance", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_start_time(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_end_time(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_end_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_end_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_to(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_to(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Waypoint)
	fc.Result = res
	return ec.marshalOWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_to(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lon":
				return ec.fieldContext_Waypoint_lon(ctx, field)
			case "lat":
				return ec.fieldContext_Waypoint_lat(ctx, field)
			case "name":
				return ec.fieldContext_Waypoint_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waypoint", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_mode(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_mode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.StepMode)
	fc.Result = res
	return ec.marshalNStepMode2githubcominterlineiotransitlandservermodelStepMode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_mode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StepMode does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_instruction(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_instruction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Instruction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_instruction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Step_geometry_offset(ctx context.Context, field graphql.CollectedField, obj *model.Step) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Step_geometry_offset(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeometryOffset, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Step_geometry_offset(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Step",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_location_type(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_location_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocationType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_location_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_code(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_desc(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_desc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopDesc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_desc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_name(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_timezone(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_timezone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_url(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_wheelchair_boarding(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WheelchairBoarding, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_wheelchair_boarding(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_zone_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_zone_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZoneID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_zone_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_platform_code(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_platform_code(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlatformCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_platform_code(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_tts_stop_name(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_tts_stop_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TtsStopName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_tts_stop_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_geometry(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_geometry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Geometry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.Point)
	fc.Result = res
	return ec.marshalNPoint2githubcominterlineiotransitlandlibtlttPoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_geometry(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Point does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_feed_version_sha1(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_feed_version_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedVersionSHA1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_feed_version_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_feed_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_feed_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_level(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Level(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Level)
	fc.Result = res
	return ec.marshalOLevel2githubcominterlineiotransitlandservermodelLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Level_id(ctx, field)
			case "level_id":
				return ec.fieldContext_Level_level_id(ctx, field)
			case "level_name":
				return ec.fieldContext_Level_level_name(ctx, field)
			case "level_index":
				return ec.fieldContext_Level_level_index(ctx, field)
			case "geometry":
				return ec.fieldContext_Level_geometry(ctx, field)
			case "stops":
				return ec.fieldContext_Level_stops(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Level", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_parent(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_parent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Parent(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_parent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_external_reference(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_external_reference(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().ExternalReference(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StopExternalReference)
	fc.Result = res
	return ec.marshalOStopExternalReference2githubcominterlineiotransitlandservermodelStopExternalReference(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_external_reference(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_StopExternalReference_id(ctx, field)
			case "target_feed_onestop_id":
				return ec.fieldContext_StopExternalReference_target_feed_onestop_id(ctx, field)
			case "target_stop_id":
				return ec.fieldContext_StopExternalReference_target_stop_id(ctx, field)
			case "inactive":
				return ec.fieldContext_StopExternalReference_inactive(ctx, field)
			case "target_active_stop":
				return ec.fieldContext_StopExternalReference_target_active_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopExternalReference", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_observations(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_observations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Observations(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopObservationFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.StopObservation)
	fc.Result = res
	return ec.marshalOStopObservation2githubcominterlineiotransitlandservermodelStopObservation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_observations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "schedule_relationship":
				return ec.fieldContext_StopObservation_schedule_relationship(ctx, field)
			case "trip_start_date":
				return ec.fieldContext_StopObservation_trip_start_date(ctx, field)
			case "trip_start_time":
				return ec.fieldContext_StopObservation_trip_start_time(ctx, field)
			case "from_stop_id":
				return ec.fieldContext_StopObservation_from_stop_id(ctx, field)
			case "to_stop_id":
				return ec.fieldContext_StopObservation_to_stop_id(ctx, field)
			case "agency_id":
				return ec.fieldContext_StopObservation_agency_id(ctx, field)
			case "route_id":
				return ec.fieldContext_StopObservation_route_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_StopObservation_trip_id(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopObservation_stop_sequence(ctx, field)
			case "source":
				return ec.fieldContext_StopObservation_source(ctx, field)
			case "scheduled_arrival_time":
				return ec.fieldContext_StopObservation_scheduled_arrival_time(ctx, field)
			case "scheduled_departure_time":
				return ec.fieldContext_StopObservation_scheduled_departure_time(ctx, field)
			case "observed_arrival_time":
				return ec.fieldContext_StopObservation_observed_arrival_time(ctx, field)
			case "observed_departure_time":
				return ec.fieldContext_StopObservation_observed_departure_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopObservation", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_observations_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_children(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_children(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Children(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_children(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_children_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_route_stops(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_route_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().RouteStops(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RouteStop)
	fc.Result = res
	return ec.marshalNRouteStop2githubcominterlineiotransitlandservermodelRouteStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_route_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RouteStop_id(ctx, field)
			case "stop_id":
				return ec.fieldContext_RouteStop_stop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_RouteStop_route_id(ctx, field)
			case "agency_id":
				return ec.fieldContext_RouteStop_agency_id(ctx, field)
			case "route":
				return ec.fieldContext_RouteStop_route(ctx, field)
			case "stop":
				return ec.fieldContext_RouteStop_stop(ctx, field)
			case "agency":
				return ec.fieldContext_RouteStop_agency(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RouteStop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_route_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_pathways_from_stop(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_pathways_from_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().PathwaysFromStop(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Pathway)
	fc.Result = res
	return ec.marshalNPathway2githubcominterlineiotransitlandservermodelPathway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_pathways_from_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Pathway_id(ctx, field)
			case "pathway_id":
				return ec.fieldContext_Pathway_pathway_id(ctx, field)
			case "pathway_mode":
				return ec.fieldContext_Pathway_pathway_mode(ctx, field)
			case "is_bidirectional":
				return ec.fieldContext_Pathway_is_bidirectional(ctx, field)
			case "length":
				return ec.fieldContext_Pathway_length(ctx, field)
			case "traversal_time":
				return ec.fieldContext_Pathway_traversal_time(ctx, field)
			case "stair_count":
				return ec.fieldContext_Pathway_stair_count(ctx, field)
			case "max_slope":
				return ec.fieldContext_Pathway_max_slope(ctx, field)
			case "min_width":
				return ec.fieldContext_Pathway_min_width(ctx, field)
			case "signposted_as":
				return ec.fieldContext_Pathway_signposted_as(ctx, field)
			case "reverse_signposted_as":
				return ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
			case "from_stop":
				return ec.fieldContext_Pathway_from_stop(ctx, field)
			case "to_stop":
				return ec.fieldContext_Pathway_to_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pathway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_pathways_from_stop_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_pathways_to_stop(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_pathways_to_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().PathwaysToStop(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Pathway)
	fc.Result = res
	return ec.marshalNPathway2githubcominterlineiotransitlandservermodelPathway(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_pathways_to_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Pathway_id(ctx, field)
			case "pathway_id":
				return ec.fieldContext_Pathway_pathway_id(ctx, field)
			case "pathway_mode":
				return ec.fieldContext_Pathway_pathway_mode(ctx, field)
			case "is_bidirectional":
				return ec.fieldContext_Pathway_is_bidirectional(ctx, field)
			case "length":
				return ec.fieldContext_Pathway_length(ctx, field)
			case "traversal_time":
				return ec.fieldContext_Pathway_traversal_time(ctx, field)
			case "stair_count":
				return ec.fieldContext_Pathway_stair_count(ctx, field)
			case "max_slope":
				return ec.fieldContext_Pathway_max_slope(ctx, field)
			case "min_width":
				return ec.fieldContext_Pathway_min_width(ctx, field)
			case "signposted_as":
				return ec.fieldContext_Pathway_signposted_as(ctx, field)
			case "reverse_signposted_as":
				return ec.fieldContext_Pathway_reverse_signposted_as(ctx, field)
			case "from_stop":
				return ec.fieldContext_Pathway_from_stop(ctx, field)
			case "to_stop":
				return ec.fieldContext_Pathway_to_stop(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pathway", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_pathways_to_stop_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_stop_times(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_stop_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().StopTimes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_stop_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_stop_times_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_departures(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_departures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Departures(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_departures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_departures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_arrivals(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_arrivals(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Arrivals(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.StopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_arrivals(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_arrivals_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_search_rank(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_search_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchRank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_search_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Stop_census_geographies(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_census_geographies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().CensusGeographies(rctx, obj, fc.Args["layer"].(string), fc.Args["radius"].(*float64), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CensusGeography)
	fc.Result = res
	return ec.marshalOCensusGeography2githubcominterlineiotransitlandservermodelCensusGeography(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_census_geographies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_CensusGeography_id(ctx, field)
			case "layer_name":
				return ec.fieldContext_CensusGeography_layer_name(ctx, field)
			case "geoid":
				return ec.fieldContext_CensusGeography_geoid(ctx, field)
			case "name":
				return ec.fieldContext_CensusGeography_name(ctx, field)
			case "aland":
				return ec.fieldContext_CensusGeography_aland(ctx, field)
			case "awater":
				return ec.fieldContext_CensusGeography_awater(ctx, field)
			case "geometry":
				return ec.fieldContext_CensusGeography_geometry(ctx, field)
			case "values":
				return ec.fieldContext_CensusGeography_values(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CensusGeography", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_census_geographies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_directions(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_directions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Directions(rctx, obj, fc.Args["to"].(*model.WaypointInput), fc.Args["from"].(*model.WaypointInput), fc.Args["mode"].(*model.StepMode), fc.Args["depart_at"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Directions)
	fc.Result = res
	return ec.marshalNDirections2githubcominterlineiotransitlandservermodelDirections(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_directions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "success":
				return ec.fieldContext_Directions_success(ctx, field)
			case "exception":
				return ec.fieldContext_Directions_exception(ctx, field)
			case "data_source":
				return ec.fieldContext_Directions_data_source(ctx, field)
			case "origin":
				return ec.fieldContext_Directions_origin(ctx, field)
			case "destination":
				return ec.fieldContext_Directions_destination(ctx, field)
			case "duration":
				return ec.fieldContext_Directions_duration(ctx, field)
			case "distance":
				return ec.fieldContext_Directions_distance(ctx, field)
			case "start_time":
				return ec.fieldContext_Directions_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Directions_end_time(ctx, field)
			case "itineraries":
				return ec.fieldContext_Directions_itineraries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Directions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_directions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_nearby_stops(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_nearby_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().NearbyStops(rctx, obj, fc.Args["limit"].(*int), fc.Args["radius"].(*float64))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_nearby_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_nearby_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Stop_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Stop) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Stop_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Stop().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Stop_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Stop",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Stop_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_id(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_target_feed_onestop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_target_feed_onestop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetFeedOnestopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_target_feed_onestop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_target_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_target_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetStopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_target_stop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_inactive(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_inactive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Inactive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_inactive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopExternalReference_target_active_stop(ctx context.Context, field graphql.CollectedField, obj *model.StopExternalReference) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopExternalReference_target_active_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopExternalReference().TargetActiveStop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopExternalReference_target_active_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopExternalReference",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduleRelationship, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_schedule_relationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_trip_start_date(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_trip_start_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripStartDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_trip_start_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_trip_start_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_trip_start_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripStartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_trip_start_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_from_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_from_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromStopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_from_stop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_to_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_to_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToStopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_to_stop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_agency_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_agency_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgencyID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_agency_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_route_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_route_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RouteID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_route_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_trip_id(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_trip_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_stop_sequence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_source(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_scheduled_arrival_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_scheduled_arrival_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledArrivalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_scheduled_arrival_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_scheduled_departure_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_scheduled_departure_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledDepartureTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_scheduled_departure_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_observed_arrival_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_observed_arrival_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ObservedArrivalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_observed_arrival_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopObservation_observed_departure_time(ctx context.Context, field graphql.CollectedField, obj *model.StopObservation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopObservation_observed_departure_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ObservedDepartureTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopObservation_observed_departure_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopObservation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_arrival_time(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_arrival_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ArrivalTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.WideTime)
	fc.Result = res
	return ec.marshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_arrival_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_departure_time(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_departure_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DepartureTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(tt.WideTime)
	fc.Result = res
	return ec.marshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_departure_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_stop_sequence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_stop_headsign(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_stop_headsign(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopHeadsign, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.String)
	fc.Result = res
	return ec.marshalOString2githubcominterlineiotransitlandlibtlttString(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_stop_headsign(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_pickup_type(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_pickup_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PickupType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_pickup_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_drop_off_type(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_drop_off_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DropOffType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_drop_off_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_timepoint(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_timepoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timepoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_timepoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_interpolated(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_interpolated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interpolated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_interpolated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_stop(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_stop(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Stop(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_stop(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_trip(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_trip(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Trip(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Trip)
	fc.Result = res
	return ec.marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_trip(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Trip_id(ctx, field)
			case "trip_id":
				return ec.fieldContext_Trip_trip_id(ctx, field)
			case "trip_headsign":
				return ec.fieldContext_Trip_trip_headsign(ctx, field)
			case "trip_short_name":
				return ec.fieldContext_Trip_trip_short_name(ctx, field)
			case "direction_id":
				return ec.fieldContext_Trip_direction_id(ctx, field)
			case "block_id":
				return ec.fieldContext_Trip_block_id(ctx, field)
			case "wheelchair_accessible":
				return ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
			case "bikes_allowed":
				return ec.fieldContext_Trip_bikes_allowed(ctx, field)
			case "stop_pattern_id":
				return ec.fieldContext_Trip_stop_pattern_id(ctx, field)
			case "calendar":
				return ec.fieldContext_Trip_calendar(ctx, field)
			case "route":
				return ec.fieldContext_Trip_route(ctx, field)
			case "shape":
				return ec.fieldContext_Trip_shape(ctx, field)
			case "feed_version":
				return ec.fieldContext_Trip_feed_version(ctx, field)
			case "stop_times":
				return ec.fieldContext_Trip_stop_times(ctx, field)
			case "frequencies":
				return ec.fieldContext_Trip_frequencies(ctx, field)
			case "schedule_relationship":
				return ec.fieldContext_Trip_schedule_relationship(ctx, field)
			case "timestamp":
				return ec.fieldContext_Trip_timestamp(ctx, field)
			case "alerts":
				return ec.fieldContext_Trip_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Trip", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_arrival(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_arrival(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Arrival(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StopTimeEvent)
	fc.Result = res
	return ec.marshalNStopTimeEvent2githubcominterlineiotransitlandservermodelStopTimeEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_arrival(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_timezone":
				return ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
			case "scheduled":
				return ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
			case "estimated":
				return ec.fieldContext_StopTimeEvent_estimated(ctx, field)
			case "estimated_utc":
				return ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
			case "delay":
				return ec.fieldContext_StopTimeEvent_delay(ctx, field)
			case "uncertainty":
				return ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTimeEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_departure(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_departure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.StopTime().Departure(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.StopTimeEvent)
	fc.Result = res
	return ec.marshalNStopTimeEvent2githubcominterlineiotransitlandservermodelStopTimeEvent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_departure(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "stop_timezone":
				return ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
			case "scheduled":
				return ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
			case "estimated":
				return ec.fieldContext_StopTimeEvent_estimated(ctx, field)
			case "estimated_utc":
				return ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
			case "delay":
				return ec.fieldContext_StopTimeEvent_delay(ctx, field)
			case "uncertainty":
				return ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTimeEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_continuous_drop_off(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousDropOff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_continuous_drop_off(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_continuous_pickup(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_continuous_pickup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContinuousPickup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Int)
	fc.Result = res
	return ec.marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_continuous_pickup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_shape_dist_traveled(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShapeDistTraveled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Float)
	fc.Result = res
	return ec.marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_shape_dist_traveled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTime_service_date(ctx context.Context, field graphql.CollectedField, obj *model.StopTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTime_service_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTime_service_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_stop_timezone(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_stop_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopTimezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_stop_timezone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_scheduled(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_scheduled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scheduled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_scheduled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_estimated(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_estimated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Estimated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.WideTime)
	fc.Result = res
	return ec.marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_estimated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Seconds does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_estimated_utc(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_estimated_utc(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedUtc, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Time)
	fc.Result = res
	return ec.marshalOTime2githubcominterlineiotransitlandlibtlttTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_estimated_utc(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_delay(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_delay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Delay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_delay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StopTimeEvent_uncertainty(ctx context.Context, field graphql.CollectedField, obj *model.StopTimeEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StopTimeEvent_uncertainty(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Uncertainty, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StopTimeEvent_uncertainty(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StopTimeEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_trip_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_trip_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_trip_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_trip_headsign(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_trip_headsign(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripHeadsign, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_trip_headsign(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_trip_short_name(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_trip_short_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TripShortName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_trip_short_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_direction_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_direction_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DirectionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_direction_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_block_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_block_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_block_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_wheelchair_accessible(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_wheelchair_accessible(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WheelchairAccessible, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_wheelchair_accessible(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_bikes_allowed(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_bikes_allowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BikesAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_bikes_allowed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_stop_pattern_id(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_stop_pattern_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopPatternID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_stop_pattern_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_calendar(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_calendar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Calendar(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Calendar)
	fc.Result = res
	return ec.marshalNCalendar2githubcominterlineiotransitlandservermodelCalendar(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_calendar(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Calendar_id(ctx, field)
			case "service_id":
				return ec.fieldContext_Calendar_service_id(ctx, field)
			case "start_date":
				return ec.fieldContext_Calendar_start_date(ctx, field)
			case "end_date":
				return ec.fieldContext_Calendar_end_date(ctx, field)
			case "monday":
				return ec.fieldContext_Calendar_monday(ctx, field)
			case "tuesday":
				return ec.fieldContext_Calendar_tuesday(ctx, field)
			case "wednesday":
				return ec.fieldContext_Calendar_wednesday(ctx, field)
			case "thursday":
				return ec.fieldContext_Calendar_thursday(ctx, field)
			case "friday":
				return ec.fieldContext_Calendar_friday(ctx, field)
			case "saturday":
				return ec.fieldContext_Calendar_saturday(ctx, field)
			case "sunday":
				return ec.fieldContext_Calendar_sunday(ctx, field)
			case "added_dates":
				return ec.fieldContext_Calendar_added_dates(ctx, field)
			case "removed_dates":
				return ec.fieldContext_Calendar_removed_dates(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Calendar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_route(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_route(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Route(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_route(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_shape(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_shape(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Shape(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Shape)
	fc.Result = res
	return ec.marshalOShape2githubcominterlineiotransitlandservermodelShape(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_shape(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Shape_id(ctx, field)
			case "shape_id":
				return ec.fieldContext_Shape_shape_id(ctx, field)
			case "geometry":
				return ec.fieldContext_Shape_geometry(ctx, field)
			case "generated":
				return ec.fieldContext_Shape_generated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Shape", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_feed_version(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_feed_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().FeedVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.FeedVersion)
	fc.Result = res
	return ec.marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_feed_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersion_id(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersion_sha1(ctx, field)
			case "fetched_at":
				return ec.fieldContext_FeedVersion_fetched_at(ctx, field)
			case "url":
				return ec.fieldContext_FeedVersion_url(ctx, field)
			case "earliest_calendar_date":
				return ec.fieldContext_FeedVersion_earliest_calendar_date(ctx, field)
			case "latest_calendar_date":
				return ec.fieldContext_FeedVersion_latest_calendar_date(ctx, field)
			case "created_by":
				return ec.fieldContext_FeedVersion_created_by(ctx, field)
			case "updated_by":
				return ec.fieldContext_FeedVersion_updated_by(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersion_name(ctx, field)
			case "description":
				return ec.fieldContext_FeedVersion_description(ctx, field)
			case "file":
				return ec.fieldContext_FeedVersion_file(ctx, field)
			case "geometry":
				return ec.fieldContext_FeedVersion_geometry(ctx, field)
			case "feed":
				return ec.fieldContext_FeedVersion_feed(ctx, field)
			case "feed_version_gtfs_import":
				return ec.fieldContext_FeedVersion_feed_version_gtfs_import(ctx, field)
			case "files":
				return ec.fieldContext_FeedVersion_files(ctx, field)
			case "service_levels":
				return ec.fieldContext_FeedVersion_service_levels(ctx, field)
			case "agencies":
				return ec.fieldContext_FeedVersion_agencies(ctx, field)
			case "routes":
				return ec.fieldContext_FeedVersion_routes(ctx, field)
			case "stops":
				return ec.fieldContext_FeedVersion_stops(ctx, field)
			case "trips":
				return ec.fieldContext_FeedVersion_trips(ctx, field)
			case "feed_infos":
				return ec.fieldContext_FeedVersion_feed_infos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_stop_times(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_stop_times(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().StopTimes(rctx, obj, fc.Args["limit"].(*int), fc.Args["where"].(*model.TripStopTimeFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StopTime)
	fc.Result = res
	return ec.marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_stop_times(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arrival_time":
				return ec.fieldContext_StopTime_arrival_time(ctx, field)
			case "departure_time":
				return ec.fieldContext_StopTime_departure_time(ctx, field)
			case "stop_sequence":
				return ec.fieldContext_StopTime_stop_sequence(ctx, field)
			case "stop_headsign":
				return ec.fieldContext_StopTime_stop_headsign(ctx, field)
			case "pickup_type":
				return ec.fieldContext_StopTime_pickup_type(ctx, field)
			case "drop_off_type":
				return ec.fieldContext_StopTime_drop_off_type(ctx, field)
			case "timepoint":
				return ec.fieldContext_StopTime_timepoint(ctx, field)
			case "interpolated":
				return ec.fieldContext_StopTime_interpolated(ctx, field)
			case "stop":
				return ec.fieldContext_StopTime_stop(ctx, field)
			case "trip":
				return ec.fieldContext_StopTime_trip(ctx, field)
			case "arrival":
				return ec.fieldContext_StopTime_arrival(ctx, field)
			case "departure":
				return ec.fieldContext_StopTime_departure(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_StopTime_continuous_drop_off(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_StopTime_continuous_pickup(ctx, field)
			case "shape_dist_traveled":
				return ec.fieldContext_StopTime_shape_dist_traveled(ctx, field)
			case "service_date":
				return ec.fieldContext_StopTime_service_date(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StopTime", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trip_stop_times_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Trip_frequencies(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_frequencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Frequencies(rctx, obj, fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Frequency)
	fc.Result = res
	return ec.marshalNFrequency2githubcominterlineiotransitlandservermodelFrequency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_frequencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Frequency_id(ctx, field)
			case "start_time":
				return ec.fieldContext_Frequency_start_time(ctx, field)
			case "end_time":
				return ec.fieldContext_Frequency_end_time(ctx, field)
			case "headway_secs":
				return ec.fieldContext_Frequency_headway_secs(ctx, field)
			case "exact_times":
				return ec.fieldContext_Frequency_exact_times(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Frequency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trip_frequencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Trip_schedule_relationship(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_schedule_relationship(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().ScheduleRelationship(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ScheduleRelationship)
	fc.Result = res
	return ec.marshalOScheduleRelationship2githubcominterlineiotransitlandservermodelScheduleRelationship(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_schedule_relationship(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ScheduleRelationship does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Timestamp(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Trip_alerts(ctx context.Context, field graphql.CollectedField, obj *model.Trip) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Trip_alerts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Trip().Alerts(rctx, obj, fc.Args["active"].(*bool), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Alert)
	fc.Result = res
	return ec.marshalOAlert2githubcominterlineiotransitlandservermodelAlert(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Trip_alerts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Trip",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "active_period":
				return ec.fieldContext_Alert_active_period(ctx, field)
			case "cause":
				return ec.fieldContext_Alert_cause(ctx, field)
			case "effect":
				return ec.fieldContext_Alert_effect(ctx, field)
			case "header_text":
				return ec.fieldContext_Alert_header_text(ctx, field)
			case "description_text":
				return ec.fieldContext_Alert_description_text(ctx, field)
			case "tts_header_text":
				return ec.fieldContext_Alert_tts_header_text(ctx, field)
			case "tts_description_text":
				return ec.fieldContext_Alert_tts_description_text(ctx, field)
			case "url":
				return ec.fieldContext_Alert_url(ctx, field)
			case "severity_level":
				return ec.fieldContext_Alert_severity_level(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Alert", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Trip_alerts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_success(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_success(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Success, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_success(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_failure_reason(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_failure_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureReason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_failure_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_errors(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ValidationResultErrorGroup)
	fc.Result = res
	return ec.marshalNValidationResultErrorGroup2githubcominterlineiotransitlandservermodelValidationResultErrorGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filename":
				return ec.fieldContext_ValidationResultErrorGroup_filename(ctx, field)
			case "error_type":
				return ec.fieldContext_ValidationResultErrorGroup_error_type(ctx, field)
			case "count":
				return ec.fieldContext_ValidationResultErrorGroup_count(ctx, field)
			case "limit":
				return ec.fieldContext_ValidationResultErrorGroup_limit(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResultErrorGroup_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResultErrorGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_warnings(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ValidationResultErrorGroup)
	fc.Result = res
	return ec.marshalNValidationResultErrorGroup2githubcominterlineiotransitlandservermodelValidationResultErrorGroup(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filename":
				return ec.fieldContext_ValidationResultErrorGroup_filename(ctx, field)
			case "error_type":
				return ec.fieldContext_ValidationResultErrorGroup_error_type(ctx, field)
			case "count":
				return ec.fieldContext_ValidationResultErrorGroup_count(ctx, field)
			case "limit":
				return ec.fieldContext_ValidationResultErrorGroup_limit(ctx, field)
			case "errors":
				return ec.fieldContext_ValidationResultErrorGroup_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResultErrorGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_sha1(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_sha1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sha1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_sha1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_earliest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_earliest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EarliestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_earliest_calendar_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_latest_calendar_date(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_latest_calendar_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestCalendarDate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(tt.Date)
	fc.Result = res
	return ec.marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_latest_calendar_date(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Date does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_files(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FeedVersionFileInfo)
	fc.Result = res
	return ec.marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionFileInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_FeedVersionFileInfo_name(ctx, field)
			case "rows":
				return ec.fieldContext_FeedVersionFileInfo_rows(ctx, field)
			case "sha1":
				return ec.fieldContext_FeedVersionFileInfo_sha1(ctx, field)
			case "header":
				return ec.fieldContext_FeedVersionFileInfo_header(ctx, field)
			case "csv_like":
				return ec.fieldContext_FeedVersionFileInfo_csv_like(ctx, field)
			case "size":
				return ec.fieldContext_FeedVersionFileInfo_size(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionFileInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_service_levels(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_service_levels(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceLevels, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FeedVersionServiceLevel)
	fc.Result = res
	return ec.marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_service_levels(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedVersionServiceLevel_id(ctx, field)
			case "start_date":
				return ec.fieldContext_FeedVersionServiceLevel_start_date(ctx, field)
			case "end_date":
				return ec.fieldContext_FeedVersionServiceLevel_end_date(ctx, field)
			case "monday":
				return ec.fieldContext_FeedVersionServiceLevel_monday(ctx, field)
			case "tuesday":
				return ec.fieldContext_FeedVersionServiceLevel_tuesday(ctx, field)
			case "wednesday":
				return ec.fieldContext_FeedVersionServiceLevel_wednesday(ctx, field)
			case "thursday":
				return ec.fieldContext_FeedVersionServiceLevel_thursday(ctx, field)
			case "friday":
				return ec.fieldContext_FeedVersionServiceLevel_friday(ctx, field)
			case "saturday":
				return ec.fieldContext_FeedVersionServiceLevel_saturday(ctx, field)
			case "sunday":
				return ec.fieldContext_FeedVersionServiceLevel_sunday(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedVersionServiceLevel", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationResult_service_levels_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_agencies(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_agencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Agencies, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Agency)
	fc.Result = res
	return ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_agencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Agency_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Agency_onestop_id(ctx, field)
			case "agency_email":
				return ec.fieldContext_Agency_agency_email(ctx, field)
			case "agency_fare_url":
				return ec.fieldContext_Agency_agency_fare_url(ctx, field)
			case "agency_id":
				return ec.fieldContext_Agency_agency_id(ctx, field)
			case "agency_lang":
				return ec.fieldContext_Agency_agency_lang(ctx, field)
			case "agency_name":
				return ec.fieldContext_Agency_agency_name(ctx, field)
			case "agency_phone":
				return ec.fieldContext_Agency_agency_phone(ctx, field)
			case "agency_timezone":
				return ec.fieldContext_Agency_agency_timezone(ctx, field)
			case "agency_url":
				return ec.fieldContext_Agency_agency_url(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Agency_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Agency_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Agency_feed_version(ctx, field)
			case "geometry":
				return ec.fieldContext_Agency_geometry(ctx, field)
			case "search_rank":
				return ec.fieldContext_Agency_search_rank(ctx, field)
			case "operator":
				return ec.fieldContext_Agency_operator(ctx, field)
			case "places":
				return ec.fieldContext_Agency_places(ctx, field)
			case "routes":
				return ec.fieldContext_Agency_routes(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Agency_census_geographies(ctx, field)
			case "alerts":
				return ec.fieldContext_Agency_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Agency", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationResult_agencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_routes(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_routes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Routes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Route)
	fc.Result = res
	return ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_routes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Route_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Route_onestop_id(ctx, field)
			case "route_id":
				return ec.fieldContext_Route_route_id(ctx, field)
			case "route_short_name":
				return ec.fieldContext_Route_route_short_name(ctx, field)
			case "route_long_name":
				return ec.fieldContext_Route_route_long_name(ctx, field)
			case "route_type":
				return ec.fieldContext_Route_route_type(ctx, field)
			case "route_color":
				return ec.fieldContext_Route_route_color(ctx, field)
			case "route_text_color":
				return ec.fieldContext_Route_route_text_color(ctx, field)
			case "route_sort_order":
				return ec.fieldContext_Route_route_sort_order(ctx, field)
			case "route_url":
				return ec.fieldContext_Route_route_url(ctx, field)
			case "route_desc":
				return ec.fieldContext_Route_route_desc(ctx, field)
			case "continuous_pickup":
				return ec.fieldContext_Route_continuous_pickup(ctx, field)
			case "continuous_drop_off":
				return ec.fieldContext_Route_continuous_drop_off(ctx, field)
			case "geometry":
				return ec.fieldContext_Route_geometry(ctx, field)
			case "agency":
				return ec.fieldContext_Route_agency(ctx, field)
			case "feed_version":
				return ec.fieldContext_Route_feed_version(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Route_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Route_feed_onestop_id(ctx, field)
			case "search_rank":
				return ec.fieldContext_Route_search_rank(ctx, field)
			case "route_attribute":
				return ec.fieldContext_Route_route_attribute(ctx, field)
			case "trips":
				return ec.fieldContext_Route_trips(ctx, field)
			case "stops":
				return ec.fieldContext_Route_stops(ctx, field)
			case "route_stops":
				return ec.fieldContext_Route_route_stops(ctx, field)
			case "headways":
				return ec.fieldContext_Route_headways(ctx, field)
			case "geometries":
				return ec.fieldContext_Route_geometries(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Route_census_geographies(ctx, field)
			case "route_stop_buffer":
				return ec.fieldContext_Route_route_stop_buffer(ctx, field)
			case "patterns":
				return ec.fieldContext_Route_patterns(ctx, field)
			case "alerts":
				return ec.fieldContext_Route_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Route", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationResult_routes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_stops(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_stops(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Stops, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.Stop)
	fc.Result = res
	return ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_stops(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationResult_stops_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResult_feed_infos(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResult_feed_infos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedInfos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FeedInfo)
	fc.Result = res
	return ec.marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResult_feed_infos(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_FeedInfo_id(ctx, field)
			case "feed_publisher_name":
				return ec.fieldContext_FeedInfo_feed_publisher_name(ctx, field)
			case "feed_publisher_url":
				return ec.fieldContext_FeedInfo_feed_publisher_url(ctx, field)
			case "feed_lang":
				return ec.fieldContext_FeedInfo_feed_lang(ctx, field)
			case "default_lang":
				return ec.fieldContext_FeedInfo_default_lang(ctx, field)
			case "feed_version":
				return ec.fieldContext_FeedInfo_feed_version(ctx, field)
			case "feed_start_date":
				return ec.fieldContext_FeedInfo_feed_start_date(ctx, field)
			case "feed_end_date":
				return ec.fieldContext_FeedInfo_feed_end_date(ctx, field)
			case "feed_contact_email":
				return ec.fieldContext_FeedInfo_feed_contact_email(ctx, field)
			case "feed_contact_url":
				return ec.fieldContext_FeedInfo_feed_contact_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FeedInfo", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_ValidationResult_feed_infos_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultError_filename(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultError_filename(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filename, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultError_filename(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultError_error_type(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultError_error_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultError_error_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultError_entity_id(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultError_entity_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EntityID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultError_entity_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultError_field(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultError_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultError_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultError_value(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultError_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultError_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultError_message(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultError_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultError_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultErrorGroup_filename(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultErrorGroup_filename(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Filename, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultErrorGroup_filename(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultErrorGroup_error_type(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultErrorGroup_error_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ErrorType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultErrorGroup_error_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultErrorGroup_count(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultErrorGroup_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultErrorGroup_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultErrorGroup_limit(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultErrorGroup_limit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Limit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultErrorGroup_limit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ValidationResultErrorGroup_errors(ctx context.Context, field graphql.CollectedField, obj *model.ValidationResultErrorGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ValidationResultErrorGroup_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ValidationResultError)
	fc.Result = res
	return ec.marshalNValidationResultError2githubcominterlineiotransitlandservermodelValidationResultError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ValidationResultErrorGroup_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ValidationResultErrorGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filename":
				return ec.fieldContext_ValidationResultError_filename(ctx, field)
			case "error_type":
				return ec.fieldContext_ValidationResultError_error_type(ctx, field)
			case "entity_id":
				return ec.fieldContext_ValidationResultError_entity_id(ctx, field)
			case "field":
				return ec.fieldContext_ValidationResultError_field(ctx, field)
			case "value":
				return ec.fieldContext_ValidationResultError_value(ctx, field)
			case "message":
				return ec.fieldContext_ValidationResultError_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ValidationResultError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_vehicle(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_vehicle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vehicle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RTVehicleDescriptor)
	fc.Result = res
	return ec.marshalORTVehicleDescriptor2githubcominterlineiotransitlandservermodelRTVehicleDescriptor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_vehicle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RTVehicleDescriptor_id(ctx, field)
			case "label":
				return ec.fieldContext_RTVehicleDescriptor_label(ctx, field)
			case "license_plate":
				return ec.fieldContext_RTVehicleDescriptor_license_plate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RTVehicleDescriptor", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_position(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_position(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Position, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*tt.Point)
	fc.Result = res
	return ec.marshalOPoint2githubcominterlineiotransitlandlibtlttPoint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_position(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Point does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_current_stop_sequence(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_current_stop_sequence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStopSequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_current_stop_sequence(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_stop_id(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_stop_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StopID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Stop)
	fc.Result = res
	return ec.marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_stop_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Stop_id(ctx, field)
			case "onestop_id":
				return ec.fieldContext_Stop_onestop_id(ctx, field)
			case "location_type":
				return ec.fieldContext_Stop_location_type(ctx, field)
			case "stop_code":
				return ec.fieldContext_Stop_stop_code(ctx, field)
			case "stop_desc":
				return ec.fieldContext_Stop_stop_desc(ctx, field)
			case "stop_id":
				return ec.fieldContext_Stop_stop_id(ctx, field)
			case "stop_name":
				return ec.fieldContext_Stop_stop_name(ctx, field)
			case "stop_timezone":
				return ec.fieldContext_Stop_stop_timezone(ctx, field)
			case "stop_url":
				return ec.fieldContext_Stop_stop_url(ctx, field)
			case "wheelchair_boarding":
				return ec.fieldContext_Stop_wheelchair_boarding(ctx, field)
			case "zone_id":
				return ec.fieldContext_Stop_zone_id(ctx, field)
			case "platform_code":
				return ec.fieldContext_Stop_platform_code(ctx, field)
			case "tts_stop_name":
				return ec.fieldContext_Stop_tts_stop_name(ctx, field)
			case "geometry":
				return ec.fieldContext_Stop_geometry(ctx, field)
			case "feed_version_sha1":
				return ec.fieldContext_Stop_feed_version_sha1(ctx, field)
			case "feed_onestop_id":
				return ec.fieldContext_Stop_feed_onestop_id(ctx, field)
			case "feed_version":
				return ec.fieldContext_Stop_feed_version(ctx, field)
			case "level":
				return ec.fieldContext_Stop_level(ctx, field)
			case "parent":
				return ec.fieldContext_Stop_parent(ctx, field)
			case "external_reference":
				return ec.fieldContext_Stop_external_reference(ctx, field)
			case "observations":
				return ec.fieldContext_Stop_observations(ctx, field)
			case "children":
				return ec.fieldContext_Stop_children(ctx, field)
			case "route_stops":
				return ec.fieldContext_Stop_route_stops(ctx, field)
			case "pathways_from_stop":
				return ec.fieldContext_Stop_pathways_from_stop(ctx, field)
			case "pathways_to_stop":
				return ec.fieldContext_Stop_pathways_to_stop(ctx, field)
			case "stop_times":
				return ec.fieldContext_Stop_stop_times(ctx, field)
			case "departures":
				return ec.fieldContext_Stop_departures(ctx, field)
			case "arrivals":
				return ec.fieldContext_Stop_arrivals(ctx, field)
			case "search_rank":
				return ec.fieldContext_Stop_search_rank(ctx, field)
			case "census_geographies":
				return ec.fieldContext_Stop_census_geographies(ctx, field)
			case "directions":
				return ec.fieldContext_Stop_directions(ctx, field)
			case "nearby_stops":
				return ec.fieldContext_Stop_nearby_stops(ctx, field)
			case "alerts":
				return ec.fieldContext_Stop_alerts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Stop", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_current_status(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_current_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CurrentStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_current_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VehiclePosition_congestion_level(ctx context.Context, field graphql.CollectedField, obj *model.VehiclePosition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VehiclePosition_congestion_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CongestionLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VehiclePosition_congestion_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VehiclePosition",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waypoint_lon(ctx context.Context, field graphql.CollectedField, obj *model.Waypoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waypoint_lon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lon, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waypoint_lon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waypoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waypoint_lat(ctx context.Context, field graphql.CollectedField, obj *model.Waypoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waypoint_lat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waypoint_lat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waypoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waypoint_name(ctx context.Context, field graphql.CollectedField, obj *model.Waypoint) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waypoint_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waypoint_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waypoint",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAgencyFilter(ctx context.Context, obj interface{}) (model.AgencyFilter, error) {
	var it model.AgencyFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "feed_version_sha1", "feed_onestop_id", "agency_id", "agency_name", "within", "near", "search", "city_name", "adm0_name", "adm1_name", "adm0_iso", "adm1_iso", "license"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			it.OnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_version_sha1":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			it.FeedVersionSha1, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			it.FeedOnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agency_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_id"))
			it.AgencyID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agency_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_name"))
			it.AgencyName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "within":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			it.Within, err = ec.unmarshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
		case "near":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			it.Near, err = ec.unmarshalOPointRadius2githubcominterlineiotransitlandservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
		case "search":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			it.Search, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "city_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city_name"))
			it.CityName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm0_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_name"))
			it.Adm0Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm1_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_name"))
			it.Adm1Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm0_iso":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_iso"))
			it.Adm0Iso, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm1_iso":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_iso"))
			it.Adm1Iso, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "license":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			it.License, err = ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAgencyPlaceFilter(ctx context.Context, obj interface{}) (model.AgencyPlaceFilter, error) {
	var it model.AgencyPlaceFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min_rank"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min_rank":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min_rank"))
			it.MinRank, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCalendarDateFilter(ctx context.Context, obj interface{}) (model.CalendarDateFilter, error) {
	var it model.CalendarDateFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"date", "exception_type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			it.Date, err = ec.unmarshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, v)
			if err != nil {
				return it, err
			}
		case "exception_type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exception_type"))
			it.ExceptionType, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDirectionRequest(ctx context.Context, obj interface{}) (model.DirectionRequest, error) {
	var it model.DirectionRequest
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"to", "from", "mode", "depart_at"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "to":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
			it.To, err = ec.unmarshalNWaypointInput2githubcominterlineiotransitlandservermodelWaypointInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			it.From, err = ec.unmarshalNWaypointInput2githubcominterlineiotransitlandservermodelWaypointInput(ctx, v)
			if err != nil {
				return it, err
			}
		case "mode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mode"))
			it.Mode, err = ec.unmarshalNStepMode2githubcominterlineiotransitlandservermodelStepMode(ctx, v)
			if err != nil {
				return it, err
			}
		case "depart_at":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("depart_at"))
			it.DepartAt, err = ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedFetchFilter(ctx context.Context, obj interface{}) (model.FeedFetchFilter, error) {
	var it model.FeedFetchFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"success"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "success":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("success"))
			it.Success, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedFilter(ctx context.Context, obj interface{}) (model.FeedFilter, error) {
	var it model.FeedFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "spec", "fetch_error", "import_status", "search", "tags", "source_url", "license"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			it.OnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "spec":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spec"))
			it.Spec, err = ec.unmarshalOFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx, v)
			if err != nil {
				return it, err
			}
		case "fetch_error":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fetch_error"))
			it.FetchError, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "import_status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("import_status"))
			it.ImportStatus, err = ec.unmarshalOImportStatus2githubcominterlineiotransitlandservermodelImportStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "search":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			it.Search, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx, v)
			if err != nil {
				return it, err
			}
		case "source_url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source_url"))
			it.SourceURL, err = ec.unmarshalOFeedSourceUrl2githubcominterlineiotransitlandservermodelFeedSourceURL(ctx, v)
			if err != nil {
				return it, err
			}
		case "license":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			it.License, err = ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedSourceUrl(ctx context.Context, obj interface{}) (model.FeedSourceURL, error) {
	var it model.FeedSourceURL
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "type", "case_sensitive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			it.URL, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOFeedSourceUrlTypes2githubcominterlineiotransitlandservermodelFeedSourceURLTypes(ctx, v)
			if err != nil {
				return it, err
			}
		case "case_sensitive":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("case_sensitive"))
			it.CaseSensitive, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedVersionFilter(ctx context.Context, obj interface{}) (model.FeedVersionFilter, error) {
	var it model.FeedVersionFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"import_status", "feed_onestop_id", "sha1", "file", "feed_ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "import_status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("import_status"))
			it.ImportStatus, err = ec.unmarshalOImportStatus2githubcominterlineiotransitlandservermodelImportStatus(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			it.FeedOnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "sha1":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sha1"))
			it.Sha1, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "file":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("file"))
			it.File, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_ids"))
			it.FeedIds, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedVersionServiceLevelFilter(ctx context.Context, obj interface{}) (model.FeedVersionServiceLevelFilter, error) {
	var it model.FeedVersionServiceLevelFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start_date", "end_date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start_date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start_date"))
			it.StartDate, err = ec.unmarshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, v)
			if err != nil {
				return it, err
			}
		case "end_date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end_date"))
			it.EndDate, err = ec.unmarshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFeedVersionSetInput(ctx context.Context, obj interface{}) (model.FeedVersionSetInput, error) {
	var it model.FeedVersionSetInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "description"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			it.Description, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGbfsBikeRequest(ctx context.Context, obj interface{}) (model.GbfsBikeRequest, error) {
	var it model.GbfsBikeRequest
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "near":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			it.Near, err = ec.unmarshalOPointRadius2githubcominterlineiotransitlandservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGbfsDockRequest(ctx context.Context, obj interface{}) (model.GbfsDockRequest, error) {
	var it model.GbfsDockRequest
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"near"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "near":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			it.Near, err = ec.unmarshalOPointRadius2githubcominterlineiotransitlandservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLicenseFilter(ctx context.Context, obj interface{}) (model.LicenseFilter, error) {
	var it model.LicenseFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"share_alike_optional", "create_derived_product", "commercial_use_allowed", "use_without_attribution", "redistribution_allowed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "share_alike_optional":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("share_alike_optional"))
			it.ShareAlikeOptional, err = ec.unmarshalOLicenseValue2githubcominterlineiotransitlandservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "create_derived_product":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("create_derived_product"))
			it.CreateDerivedProduct, err = ec.unmarshalOLicenseValue2githubcominterlineiotransitlandservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "commercial_use_allowed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commercial_use_allowed"))
			it.CommercialUseAllowed, err = ec.unmarshalOLicenseValue2githubcominterlineiotransitlandservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "use_without_attribution":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("use_without_attribution"))
			it.UseWithoutAttribution, err = ec.unmarshalOLicenseValue2githubcominterlineiotransitlandservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
		case "redistribution_allowed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redistribution_allowed"))
			it.RedistributionAllowed, err = ec.unmarshalOLicenseValue2githubcominterlineiotransitlandservermodelLicenseValue(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOperatorFilter(ctx context.Context, obj interface{}) (model.OperatorFilter, error) {
	var it model.OperatorFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"merged", "onestop_id", "feed_onestop_id", "agency_id", "search", "tags", "city_name", "adm0_name", "adm1_name", "adm0_iso", "adm1_iso", "license"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "merged":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("merged"))
			it.Merged, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			it.OnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			it.FeedOnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agency_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_id"))
			it.AgencyID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "search":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			it.Search, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "tags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tags"))
			it.Tags, err = ec.unmarshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx, v)
			if err != nil {
				return it, err
			}
		case "city_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city_name"))
			it.CityName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm0_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_name"))
			it.Adm0Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm1_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_name"))
			it.Adm1Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm0_iso":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_iso"))
			it.Adm0Iso, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm1_iso":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_iso"))
			it.Adm1Iso, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "license":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			it.License, err = ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPathwayFilter(ctx context.Context, obj interface{}) (model.PathwayFilter, error) {
	var it model.PathwayFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"pathway_mode"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "pathway_mode":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("pathway_mode"))
			it.PathwayMode, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlaceFilter(ctx context.Context, obj interface{}) (model.PlaceFilter, error) {
	var it model.PlaceFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"min_rank", "adm0_name", "adm1_name", "city_name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "min_rank":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("min_rank"))
			it.MinRank, err = ec.unmarshalOFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm0_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm0_name"))
			it.Adm0Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "adm1_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adm1_name"))
			it.Adm1Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "city_name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("city_name"))
			it.CityName, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPointRadius(ctx context.Context, obj interface{}) (model.PointRadius, error) {
	var it model.PointRadius
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lat", "lon", "radius"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lat":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lat"))
			it.Lat, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lon"))
			it.Lon, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "radius":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("radius"))
			it.Radius, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRouteFilter(ctx context.Context, obj interface{}) (model.RouteFilter, error) {
	var it model.RouteFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "onestop_ids", "allow_previous_onestop_ids", "feed_version_sha1", "feed_onestop_id", "route_id", "route_type", "within", "near", "search", "operator_onestop_id", "license", "agency_ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			it.OnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_ids"))
			it.OnestopIds, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allow_previous_onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allow_previous_onestop_ids"))
			it.AllowPreviousOnestopIds, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_version_sha1":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			it.FeedVersionSha1, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			it.FeedOnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "route_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_id"))
			it.RouteID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "route_type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_type"))
			it.RouteType, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "within":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			it.Within, err = ec.unmarshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
		case "near":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			it.Near, err = ec.unmarshalOPointRadius2githubcominterlineiotransitlandservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
		case "search":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			it.Search, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "operator_onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("operator_onestop_id"))
			it.OperatorOnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "license":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			it.License, err = ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "agency_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_ids"))
			it.AgencyIds, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopFilter(ctx context.Context, obj interface{}) (model.StopFilter, error) {
	var it model.StopFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"onestop_id", "onestop_ids", "allow_previous_onestop_ids", "feed_version_sha1", "feed_onestop_id", "stop_id", "stop_code", "location_type", "within", "near", "search", "license", "served_by_onestop_ids", "agency_ids"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_id"))
			it.OnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onestop_ids"))
			it.OnestopIds, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allow_previous_onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allow_previous_onestop_ids"))
			it.AllowPreviousOnestopIds, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_version_sha1":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			it.FeedVersionSha1, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			it.FeedOnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_id"))
			it.StopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stop_code":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_code"))
			it.StopCode, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "location_type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("location_type"))
			it.LocationType, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "within":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("within"))
			it.Within, err = ec.unmarshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx, v)
			if err != nil {
				return it, err
			}
		case "near":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("near"))
			it.Near, err = ec.unmarshalOPointRadius2githubcominterlineiotransitlandservermodelPointRadius(ctx, v)
			if err != nil {
				return it, err
			}
		case "search":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("search"))
			it.Search, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "license":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			it.License, err = ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "served_by_onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("served_by_onestop_ids"))
			it.ServedByOnestopIds, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "agency_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agency_ids"))
			it.AgencyIds, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopObservationFilter(ctx context.Context, obj interface{}) (model.StopObservationFilter, error) {
	var it model.StopObservationFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"source", "feed_version_id", "trip_start_date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "source":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("source"))
			it.Source, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_version_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_id"))
			it.FeedVersionID, err = ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "trip_start_date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trip_start_date"))
			it.TripStartDate, err = ec.unmarshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputStopTimeFilter(ctx context.Context, obj interface{}) (model.StopTimeFilter, error) {
	var it model.StopTimeFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"service_date", "use_service_window", "start_time", "end_time", "start", "end", "next", "route_onestop_ids", "allow_previous_route_onestop_ids", "exclude_first", "exclude_last"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "service_date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("service_date"))
			it.ServiceDate, err = ec.unmarshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, v)
			if err != nil {
				return it, err
			}
		case "use_service_window":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("use_service_window"))
			it.UseServiceWindow, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "start_time":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start_time"))
			it.StartTime, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "end_time":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end_time"))
			it.EndTime, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "start":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			it.Start, err = ec.unmarshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "end":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			it.End, err = ec.unmarshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "next":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("next"))
			it.Next, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "route_onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_onestop_ids"))
			it.RouteOnestopIds, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "allow_previous_route_onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allow_previous_route_onestop_ids"))
			it.AllowPreviousRouteOnestopIds, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "exclude_first":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exclude_first"))
			it.ExcludeFirst, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		case "exclude_last":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exclude_last"))
			it.ExcludeLast, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTripFilter(ctx context.Context, obj interface{}) (model.TripFilter, error) {
	var it model.TripFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"service_date", "trip_id", "stop_pattern_id", "license", "route_ids", "route_onestop_ids", "feed_version_sha1", "feed_onestop_id"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "service_date":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("service_date"))
			it.ServiceDate, err = ec.unmarshalODate2githubcominterlineiotransitlandlibtlttDate(ctx, v)
			if err != nil {
				return it, err
			}
		case "trip_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trip_id"))
			it.TripID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stop_pattern_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop_pattern_id"))
			it.StopPatternID, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "license":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("license"))
			it.License, err = ec.unmarshalOLicenseFilter2githubcominterlineiotransitlandservermodelLicenseFilter(ctx, v)
			if err != nil {
				return it, err
			}
		case "route_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_ids"))
			it.RouteIds, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "route_onestop_ids":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("route_onestop_ids"))
			it.RouteOnestopIds, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_version_sha1":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_version_sha1"))
			it.FeedVersionSha1, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "feed_onestop_id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feed_onestop_id"))
			it.FeedOnestopID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTripStopTimeFilter(ctx context.Context, obj interface{}) (model.TripStopTimeFilter, error) {
	var it model.TripStopTimeFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"start", "end"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "start":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
			it.Start, err = ec.unmarshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "end":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
			it.End, err = ec.unmarshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWaypointInput(ctx context.Context, obj interface{}) (model.WaypointInput, error) {
	var it model.WaypointInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lon", "lat", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lon":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lon"))
			it.Lon, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "lat":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lat"))
			it.Lat, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			it.Name, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var agencyImplementors = []string{"Agency"}

func (ec *executionContext) _Agency(ctx context.Context, sel ast.SelectionSet, obj *model.Agency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agencyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Agency")
		case "id":

			out.Values[i] = ec._Agency_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "onestop_id":

			out.Values[i] = ec._Agency_onestop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_email":

			out.Values[i] = ec._Agency_agency_email(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_fare_url":

			out.Values[i] = ec._Agency_agency_fare_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_id":

			out.Values[i] = ec._Agency_agency_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_lang":

			out.Values[i] = ec._Agency_agency_lang(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_name":

			out.Values[i] = ec._Agency_agency_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_phone":

			out.Values[i] = ec._Agency_agency_phone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_timezone":

			out.Values[i] = ec._Agency_agency_timezone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_url":

			out.Values[i] = ec._Agency_agency_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "feed_version_sha1":

			out.Values[i] = ec._Agency_feed_version_sha1(ctx, field, obj)

		case "feed_onestop_id":

			out.Values[i] = ec._Agency_feed_onestop_id(ctx, field, obj)

		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "geometry":

			out.Values[i] = ec._Agency_geometry(ctx, field, obj)

		case "search_rank":

			out.Values[i] = ec._Agency_search_rank(ctx, field, obj)

		case "operator":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_operator(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "places":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_places(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "routes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_routes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "census_geographies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_census_geographies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Agency_alerts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var agencyPlaceImplementors = []string{"AgencyPlace"}

func (ec *executionContext) _AgencyPlace(ctx context.Context, sel ast.SelectionSet, obj *model.AgencyPlace) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, agencyPlaceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AgencyPlace")
		case "city_name":

			out.Values[i] = ec._AgencyPlace_city_name(ctx, field, obj)

		case "adm1_name":

			out.Values[i] = ec._AgencyPlace_adm1_name(ctx, field, obj)

		case "adm0_name":

			out.Values[i] = ec._AgencyPlace_adm0_name(ctx, field, obj)

		case "rank":

			out.Values[i] = ec._AgencyPlace_rank(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var alertImplementors = []string{"Alert"}

func (ec *executionContext) _Alert(ctx context.Context, sel ast.SelectionSet, obj *model.Alert) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, alertImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Alert")
		case "active_period":

			out.Values[i] = ec._Alert_active_period(ctx, field, obj)

		case "cause":

			out.Values[i] = ec._Alert_cause(ctx, field, obj)

		case "effect":

			out.Values[i] = ec._Alert_effect(ctx, field, obj)

		case "header_text":

			out.Values[i] = ec._Alert_header_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description_text":

			out.Values[i] = ec._Alert_description_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tts_header_text":

			out.Values[i] = ec._Alert_tts_header_text(ctx, field, obj)

		case "tts_description_text":

			out.Values[i] = ec._Alert_tts_description_text(ctx, field, obj)

		case "url":

			out.Values[i] = ec._Alert_url(ctx, field, obj)

		case "severity_level":

			out.Values[i] = ec._Alert_severity_level(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var calendarImplementors = []string{"Calendar"}

func (ec *executionContext) _Calendar(ctx context.Context, sel ast.SelectionSet, obj *model.Calendar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, calendarImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Calendar")
		case "id":

			out.Values[i] = ec._Calendar_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "service_id":

			out.Values[i] = ec._Calendar_service_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "start_date":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Calendar_start_date(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "end_date":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Calendar_end_date(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "monday":

			out.Values[i] = ec._Calendar_monday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tuesday":

			out.Values[i] = ec._Calendar_tuesday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "wednesday":

			out.Values[i] = ec._Calendar_wednesday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "thursday":

			out.Values[i] = ec._Calendar_thursday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "friday":

			out.Values[i] = ec._Calendar_friday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "saturday":

			out.Values[i] = ec._Calendar_saturday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sunday":

			out.Values[i] = ec._Calendar_sunday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "added_dates":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Calendar_added_dates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "removed_dates":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Calendar_removed_dates(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var censusGeographyImplementors = []string{"CensusGeography"}

func (ec *executionContext) _CensusGeography(ctx context.Context, sel ast.SelectionSet, obj *model.CensusGeography) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusGeographyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusGeography")
		case "id":

			out.Values[i] = ec._CensusGeography_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "layer_name":

			out.Values[i] = ec._CensusGeography_layer_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "geoid":

			out.Values[i] = ec._CensusGeography_geoid(ctx, field, obj)

		case "name":

			out.Values[i] = ec._CensusGeography_name(ctx, field, obj)

		case "aland":

			out.Values[i] = ec._CensusGeography_aland(ctx, field, obj)

		case "awater":

			out.Values[i] = ec._CensusGeography_awater(ctx, field, obj)

		case "geometry":

			out.Values[i] = ec._CensusGeography_geometry(ctx, field, obj)

		case "values":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusGeography_values(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var censusTableImplementors = []string{"CensusTable"}

func (ec *executionContext) _CensusTable(ctx context.Context, sel ast.SelectionSet, obj *model.CensusTable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusTableImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusTable")
		case "id":

			out.Values[i] = ec._CensusTable_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "table_name":

			out.Values[i] = ec._CensusTable_table_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "table_title":

			out.Values[i] = ec._CensusTable_table_title(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "table_group":

			out.Values[i] = ec._CensusTable_table_group(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var censusValueImplementors = []string{"CensusValue"}

func (ec *executionContext) _CensusValue(ctx context.Context, sel ast.SelectionSet, obj *model.CensusValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, censusValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CensusValue")
		case "table":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusValue_table(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "values":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CensusValue_values(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var directionsImplementors = []string{"Directions"}

func (ec *executionContext) _Directions(ctx context.Context, sel ast.SelectionSet, obj *model.Directions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, directionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Directions")
		case "success":

			out.Values[i] = ec._Directions_success(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "exception":

			out.Values[i] = ec._Directions_exception(ctx, field, obj)

		case "data_source":

			out.Values[i] = ec._Directions_data_source(ctx, field, obj)

		case "origin":

			out.Values[i] = ec._Directions_origin(ctx, field, obj)

		case "destination":

			out.Values[i] = ec._Directions_destination(ctx, field, obj)

		case "duration":

			out.Values[i] = ec._Directions_duration(ctx, field, obj)

		case "distance":

			out.Values[i] = ec._Directions_distance(ctx, field, obj)

		case "start_time":

			out.Values[i] = ec._Directions_start_time(ctx, field, obj)

		case "end_time":

			out.Values[i] = ec._Directions_end_time(ctx, field, obj)

		case "itineraries":

			out.Values[i] = ec._Directions_itineraries(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var distanceImplementors = []string{"Distance"}

func (ec *executionContext) _Distance(ctx context.Context, sel ast.SelectionSet, obj *model.Distance) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distanceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Distance")
		case "distance":

			out.Values[i] = ec._Distance_distance(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "units":

			out.Values[i] = ec._Distance_units(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var durationImplementors = []string{"Duration"}

func (ec *executionContext) _Duration(ctx context.Context, sel ast.SelectionSet, obj *model.Duration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, durationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Duration")
		case "duration":

			out.Values[i] = ec._Duration_duration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "units":

			out.Values[i] = ec._Duration_units(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedImplementors = []string{"Feed"}

func (ec *executionContext) _Feed(ctx context.Context, sel ast.SelectionSet, obj *model.Feed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Feed")
		case "id":

			out.Values[i] = ec._Feed_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "onestop_id":

			out.Values[i] = ec._Feed_onestop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Feed_name(ctx, field, obj)

		case "file":

			out.Values[i] = ec._Feed_file(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "spec":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_spec(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "languages":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_languages(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tags":

			out.Values[i] = ec._Feed_tags(ctx, field, obj)

		case "authorization":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_authorization(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "urls":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_urls(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "license":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_license(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "search_rank":

			out.Values[i] = ec._Feed_search_rank(ctx, field, obj)

		case "associated_operators":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_associated_operators(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_state":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_feed_state(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_fetches":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_feed_fetches(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_versions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Feed_feed_versions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedAuthorizationImplementors = []string{"FeedAuthorization"}

func (ec *executionContext) _FeedAuthorization(ctx context.Context, sel ast.SelectionSet, obj *model.FeedAuthorization) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedAuthorizationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedAuthorization")
		case "type":

			out.Values[i] = ec._FeedAuthorization_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "param_name":

			out.Values[i] = ec._FeedAuthorization_param_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "info_url":

			out.Values[i] = ec._FeedAuthorization_info_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedFetchImplementors = []string{"FeedFetch"}

func (ec *executionContext) _FeedFetch(ctx context.Context, sel ast.SelectionSet, obj *model.FeedFetch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedFetchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedFetch")
		case "id":

			out.Values[i] = ec._FeedFetch_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url_type":

			out.Values[i] = ec._FeedFetch_url_type(ctx, field, obj)

		case "url":

			out.Values[i] = ec._FeedFetch_url(ctx, field, obj)

		case "success":

			out.Values[i] = ec._FeedFetch_success(ctx, field, obj)

		case "fetched_at":

			out.Values[i] = ec._FeedFetch_fetched_at(ctx, field, obj)

		case "fetch_error":

			out.Values[i] = ec._FeedFetch_fetch_error(ctx, field, obj)

		case "response_size":

			out.Values[i] = ec._FeedFetch_response_size(ctx, field, obj)

		case "response_code":

			out.Values[i] = ec._FeedFetch_response_code(ctx, field, obj)

		case "response_sha1":

			out.Values[i] = ec._FeedFetch_response_sha1(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedInfoImplementors = []string{"FeedInfo"}

func (ec *executionContext) _FeedInfo(ctx context.Context, sel ast.SelectionSet, obj *model.FeedInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedInfo")
		case "id":

			out.Values[i] = ec._FeedInfo_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feed_publisher_name":

			out.Values[i] = ec._FeedInfo_feed_publisher_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feed_publisher_url":

			out.Values[i] = ec._FeedInfo_feed_publisher_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feed_lang":

			out.Values[i] = ec._FeedInfo_feed_lang(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "default_lang":

			out.Values[i] = ec._FeedInfo_default_lang(ctx, field, obj)

		case "feed_version":

			out.Values[i] = ec._FeedInfo_feed_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feed_start_date":

			out.Values[i] = ec._FeedInfo_feed_start_date(ctx, field, obj)

		case "feed_end_date":

			out.Values[i] = ec._FeedInfo_feed_end_date(ctx, field, obj)

		case "feed_contact_email":

			out.Values[i] = ec._FeedInfo_feed_contact_email(ctx, field, obj)

		case "feed_contact_url":

			out.Values[i] = ec._FeedInfo_feed_contact_url(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedLicenseImplementors = []string{"FeedLicense"}

func (ec *executionContext) _FeedLicense(ctx context.Context, sel ast.SelectionSet, obj *model.FeedLicense) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedLicenseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedLicense")
		case "spdx_identifier":

			out.Values[i] = ec._FeedLicense_spdx_identifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._FeedLicense_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "use_without_attribution":

			out.Values[i] = ec._FeedLicense_use_without_attribution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "create_derived_product":

			out.Values[i] = ec._FeedLicense_create_derived_product(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "redistribution_allowed":

			out.Values[i] = ec._FeedLicense_redistribution_allowed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "commercial_use_allowed":

			out.Values[i] = ec._FeedLicense_commercial_use_allowed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "share_alike_optional":

			out.Values[i] = ec._FeedLicense_share_alike_optional(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attribution_text":

			out.Values[i] = ec._FeedLicense_attribution_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attribution_instructions":

			out.Values[i] = ec._FeedLicense_attribution_instructions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedStateImplementors = []string{"FeedState"}

func (ec *executionContext) _FeedState(ctx context.Context, sel ast.SelectionSet, obj *model.FeedState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedStateImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedState")
		case "id":

			out.Values[i] = ec._FeedState_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedState_feed_version(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedUrlsImplementors = []string{"FeedUrls"}

func (ec *executionContext) _FeedUrls(ctx context.Context, sel ast.SelectionSet, obj *model.FeedUrls) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedUrlsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedUrls")
		case "static_current":

			out.Values[i] = ec._FeedUrls_static_current(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "static_historic":

			out.Values[i] = ec._FeedUrls_static_historic(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "static_planned":

			out.Values[i] = ec._FeedUrls_static_planned(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "realtime_vehicle_positions":

			out.Values[i] = ec._FeedUrls_realtime_vehicle_positions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "realtime_trip_updates":

			out.Values[i] = ec._FeedUrls_realtime_trip_updates(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "realtime_alerts":

			out.Values[i] = ec._FeedUrls_realtime_alerts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "gbfs_auto_discovery":

			out.Values[i] = ec._FeedUrls_gbfs_auto_discovery(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mds_provider":

			out.Values[i] = ec._FeedUrls_mds_provider(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionImplementors = []string{"FeedVersion"}

func (ec *executionContext) _FeedVersion(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersion")
		case "id":

			out.Values[i] = ec._FeedVersion_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sha1":

			out.Values[i] = ec._FeedVersion_sha1(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "fetched_at":

			out.Values[i] = ec._FeedVersion_fetched_at(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "url":

			out.Values[i] = ec._FeedVersion_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "earliest_calendar_date":

			out.Values[i] = ec._FeedVersion_earliest_calendar_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "latest_calendar_date":

			out.Values[i] = ec._FeedVersion_latest_calendar_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "created_by":

			out.Values[i] = ec._FeedVersion_created_by(ctx, field, obj)

		case "updated_by":

			out.Values[i] = ec._FeedVersion_updated_by(ctx, field, obj)

		case "name":

			out.Values[i] = ec._FeedVersion_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec._FeedVersion_description(ctx, field, obj)

		case "file":

			out.Values[i] = ec._FeedVersion_file(ctx, field, obj)

		case "geometry":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_geometry(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_feed(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_version_gtfs_import":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_feed_version_gtfs_import(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "files":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "service_levels":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_service_levels(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "agencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_agencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "routes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_routes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stops":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "trips":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_trips(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_infos":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersion_feed_infos(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionDeleteResultImplementors = []string{"FeedVersionDeleteResult"}

func (ec *executionContext) _FeedVersionDeleteResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionDeleteResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionDeleteResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionDeleteResult")
		case "success":

			out.Values[i] = ec._FeedVersionDeleteResult_success(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionFetchResultImplementors = []string{"FeedVersionFetchResult"}

func (ec *executionContext) _FeedVersionFetchResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionFetchResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionFetchResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionFetchResult")
		case "feed_version":

			out.Values[i] = ec._FeedVersionFetchResult_feed_version(ctx, field, obj)

		case "fetch_error":

			out.Values[i] = ec._FeedVersionFetchResult_fetch_error(ctx, field, obj)

		case "found_sha1":

			out.Values[i] = ec._FeedVersionFetchResult_found_sha1(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "found_dir_sha1":

			out.Values[i] = ec._FeedVersionFetchResult_found_dir_sha1(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionFileInfoImplementors = []string{"FeedVersionFileInfo"}

func (ec *executionContext) _FeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionFileInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionFileInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionFileInfo")
		case "id":

			out.Values[i] = ec._FeedVersionFileInfo_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._FeedVersionFileInfo_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rows":

			out.Values[i] = ec._FeedVersionFileInfo_rows(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sha1":

			out.Values[i] = ec._FeedVersionFileInfo_sha1(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "header":

			out.Values[i] = ec._FeedVersionFileInfo_header(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "csv_like":

			out.Values[i] = ec._FeedVersionFileInfo_csv_like(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "size":

			out.Values[i] = ec._FeedVersionFileInfo_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionGtfsImportImplementors = []string{"FeedVersionGtfsImport"}

func (ec *executionContext) _FeedVersionGtfsImport(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionGtfsImport) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionGtfsImportImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionGtfsImport")
		case "id":

			out.Values[i] = ec._FeedVersionGtfsImport_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "in_progress":

			out.Values[i] = ec._FeedVersionGtfsImport_in_progress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "success":

			out.Values[i] = ec._FeedVersionGtfsImport_success(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "schedule_removed":

			out.Values[i] = ec._FeedVersionGtfsImport_schedule_removed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "exception_log":

			out.Values[i] = ec._FeedVersionGtfsImport_exception_log(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "skip_entity_error_count":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_error_count(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "entity_count":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_entity_count(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "warning_count":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_warning_count(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "created_at":

			out.Values[i] = ec._FeedVersionGtfsImport_created_at(ctx, field, obj)

		case "updated_at":

			out.Values[i] = ec._FeedVersionGtfsImport_updated_at(ctx, field, obj)

		case "skip_entity_reference_count":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_reference_count(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "skip_entity_filter_count":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_filter_count(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "skip_entity_marked_count":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FeedVersionGtfsImport_skip_entity_marked_count(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "interpolated_stop_time_count":

			out.Values[i] = ec._FeedVersionGtfsImport_interpolated_stop_time_count(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionImportResultImplementors = []string{"FeedVersionImportResult"}

func (ec *executionContext) _FeedVersionImportResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionImportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionImportResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionImportResult")
		case "success":

			out.Values[i] = ec._FeedVersionImportResult_success(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionServiceLevelImplementors = []string{"FeedVersionServiceLevel"}

func (ec *executionContext) _FeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionServiceLevel) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionServiceLevelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionServiceLevel")
		case "id":

			out.Values[i] = ec._FeedVersionServiceLevel_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "start_date":

			out.Values[i] = ec._FeedVersionServiceLevel_start_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "end_date":

			out.Values[i] = ec._FeedVersionServiceLevel_end_date(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "monday":

			out.Values[i] = ec._FeedVersionServiceLevel_monday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tuesday":

			out.Values[i] = ec._FeedVersionServiceLevel_tuesday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "wednesday":

			out.Values[i] = ec._FeedVersionServiceLevel_wednesday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "thursday":

			out.Values[i] = ec._FeedVersionServiceLevel_thursday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "friday":

			out.Values[i] = ec._FeedVersionServiceLevel_friday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saturday":

			out.Values[i] = ec._FeedVersionServiceLevel_saturday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sunday":

			out.Values[i] = ec._FeedVersionServiceLevel_sunday(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var feedVersionUnimportResultImplementors = []string{"FeedVersionUnimportResult"}

func (ec *executionContext) _FeedVersionUnimportResult(ctx context.Context, sel ast.SelectionSet, obj *model.FeedVersionUnimportResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, feedVersionUnimportResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeedVersionUnimportResult")
		case "success":

			out.Values[i] = ec._FeedVersionUnimportResult_success(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var frequencyImplementors = []string{"Frequency"}

func (ec *executionContext) _Frequency(ctx context.Context, sel ast.SelectionSet, obj *model.Frequency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, frequencyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Frequency")
		case "id":

			out.Values[i] = ec._Frequency_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "start_time":

			out.Values[i] = ec._Frequency_start_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "end_time":

			out.Values[i] = ec._Frequency_end_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "headway_secs":

			out.Values[i] = ec._Frequency_headway_secs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "exact_times":

			out.Values[i] = ec._Frequency_exact_times(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsAlertTimeImplementors = []string{"GbfsAlertTime"}

func (ec *executionContext) _GbfsAlertTime(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsAlertTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsAlertTimeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsAlertTime")
		case "start":

			out.Values[i] = ec._GbfsAlertTime_start(ctx, field, obj)

		case "end":

			out.Values[i] = ec._GbfsAlertTime_end(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsBrandAssetImplementors = []string{"GbfsBrandAsset"}

func (ec *executionContext) _GbfsBrandAsset(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsBrandAsset) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsBrandAssetImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsBrandAsset")
		case "brand_last_modified":

			out.Values[i] = ec._GbfsBrandAsset_brand_last_modified(ctx, field, obj)

		case "brand_terms_url":

			out.Values[i] = ec._GbfsBrandAsset_brand_terms_url(ctx, field, obj)

		case "brand_image_url":

			out.Values[i] = ec._GbfsBrandAsset_brand_image_url(ctx, field, obj)

		case "brand_image_url_dark":

			out.Values[i] = ec._GbfsBrandAsset_brand_image_url_dark(ctx, field, obj)

		case "color":

			out.Values[i] = ec._GbfsBrandAsset_color(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsFeedImplementors = []string{"GbfsFeed"}

func (ec *executionContext) _GbfsFeed(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsFeed) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsFeedImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsFeed")
		case "system_information":

			out.Values[i] = ec._GbfsFeed_system_information(ctx, field, obj)

		case "station_information":

			out.Values[i] = ec._GbfsFeed_station_information(ctx, field, obj)

		case "rental_hours":

			out.Values[i] = ec._GbfsFeed_rental_hours(ctx, field, obj)

		case "calendars":

			out.Values[i] = ec._GbfsFeed_calendars(ctx, field, obj)

		case "alerts":

			out.Values[i] = ec._GbfsFeed_alerts(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsFreeBikeStatusImplementors = []string{"GbfsFreeBikeStatus"}

func (ec *executionContext) _GbfsFreeBikeStatus(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsFreeBikeStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsFreeBikeStatusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsFreeBikeStatus")
		case "bike_id":

			out.Values[i] = ec._GbfsFreeBikeStatus_bike_id(ctx, field, obj)

		case "lat":

			out.Values[i] = ec._GbfsFreeBikeStatus_lat(ctx, field, obj)

		case "lon":

			out.Values[i] = ec._GbfsFreeBikeStatus_lon(ctx, field, obj)

		case "is_reserved":

			out.Values[i] = ec._GbfsFreeBikeStatus_is_reserved(ctx, field, obj)

		case "is_disabled":

			out.Values[i] = ec._GbfsFreeBikeStatus_is_disabled(ctx, field, obj)

		case "last_reported":

			out.Values[i] = ec._GbfsFreeBikeStatus_last_reported(ctx, field, obj)

		case "current_range_meters":

			out.Values[i] = ec._GbfsFreeBikeStatus_current_range_meters(ctx, field, obj)

		case "current_fuel_percent":

			out.Values[i] = ec._GbfsFreeBikeStatus_current_fuel_percent(ctx, field, obj)

		case "vehicle_equipment":

			out.Values[i] = ec._GbfsFreeBikeStatus_vehicle_equipment(ctx, field, obj)

		case "available_until":

			out.Values[i] = ec._GbfsFreeBikeStatus_available_until(ctx, field, obj)

		case "station":

			out.Values[i] = ec._GbfsFreeBikeStatus_station(ctx, field, obj)

		case "home_station":

			out.Values[i] = ec._GbfsFreeBikeStatus_home_station(ctx, field, obj)

		case "pricing_plan":

			out.Values[i] = ec._GbfsFreeBikeStatus_pricing_plan(ctx, field, obj)

		case "vehicle_type":

			out.Values[i] = ec._GbfsFreeBikeStatus_vehicle_type(ctx, field, obj)

		case "rental_uris":

			out.Values[i] = ec._GbfsFreeBikeStatus_rental_uris(ctx, field, obj)

		case "feed":

			out.Values[i] = ec._GbfsFreeBikeStatus_feed(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsGeofenceFeatureImplementors = []string{"GbfsGeofenceFeature"}

func (ec *executionContext) _GbfsGeofenceFeature(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceFeature) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofenceFeatureImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceFeature")
		case "type":

			out.Values[i] = ec._GbfsGeofenceFeature_type(ctx, field, obj)

		case "geometry":

			out.Values[i] = ec._GbfsGeofenceFeature_geometry(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsGeofencePropertyImplementors = []string{"GbfsGeofenceProperty"}

func (ec *executionContext) _GbfsGeofenceProperty(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceProperty) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofencePropertyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceProperty")
		case "name":

			out.Values[i] = ec._GbfsGeofenceProperty_name(ctx, field, obj)

		case "start":

			out.Values[i] = ec._GbfsGeofenceProperty_start(ctx, field, obj)

		case "end":

			out.Values[i] = ec._GbfsGeofenceProperty_end(ctx, field, obj)

		case "rules":

			out.Values[i] = ec._GbfsGeofenceProperty_rules(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsGeofenceRuleImplementors = []string{"GbfsGeofenceRule"}

func (ec *executionContext) _GbfsGeofenceRule(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofenceRuleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceRule")
		case "ride_allowed":

			out.Values[i] = ec._GbfsGeofenceRule_ride_allowed(ctx, field, obj)

		case "ride_through_allowed":

			out.Values[i] = ec._GbfsGeofenceRule_ride_through_allowed(ctx, field, obj)

		case "maximum_speed_kph":

			out.Values[i] = ec._GbfsGeofenceRule_maximum_speed_kph(ctx, field, obj)

		case "station_parking":

			out.Values[i] = ec._GbfsGeofenceRule_station_parking(ctx, field, obj)

		case "vehicle_type":

			out.Values[i] = ec._GbfsGeofenceRule_vehicle_type(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsGeofenceZoneImplementors = []string{"GbfsGeofenceZone"}

func (ec *executionContext) _GbfsGeofenceZone(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsGeofenceZone) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsGeofenceZoneImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsGeofenceZone")
		case "type":

			out.Values[i] = ec._GbfsGeofenceZone_type(ctx, field, obj)

		case "features":

			out.Values[i] = ec._GbfsGeofenceZone_features(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsPlanPriceImplementors = []string{"GbfsPlanPrice"}

func (ec *executionContext) _GbfsPlanPrice(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsPlanPrice) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsPlanPriceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsPlanPrice")
		case "start":

			out.Values[i] = ec._GbfsPlanPrice_start(ctx, field, obj)

		case "rate":

			out.Values[i] = ec._GbfsPlanPrice_rate(ctx, field, obj)

		case "interval":

			out.Values[i] = ec._GbfsPlanPrice_interval(ctx, field, obj)

		case "end":

			out.Values[i] = ec._GbfsPlanPrice_end(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsRentalAppImplementors = []string{"GbfsRentalApp"}

func (ec *executionContext) _GbfsRentalApp(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsRentalApp) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsRentalAppImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsRentalApp")
		case "store_uri":

			out.Values[i] = ec._GbfsRentalApp_store_uri(ctx, field, obj)

		case "discovery_uri":

			out.Values[i] = ec._GbfsRentalApp_discovery_uri(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsRentalAppsImplementors = []string{"GbfsRentalApps"}

func (ec *executionContext) _GbfsRentalApps(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsRentalApps) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsRentalAppsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsRentalApps")
		case "ios":

			out.Values[i] = ec._GbfsRentalApps_ios(ctx, field, obj)

		case "android":

			out.Values[i] = ec._GbfsRentalApps_android(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsRentalUrisImplementors = []string{"GbfsRentalUris"}

func (ec *executionContext) _GbfsRentalUris(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsRentalUris) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsRentalUrisImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsRentalUris")
		case "android":

			out.Values[i] = ec._GbfsRentalUris_android(ctx, field, obj)

		case "ios":

			out.Values[i] = ec._GbfsRentalUris_ios(ctx, field, obj)

		case "web":

			out.Values[i] = ec._GbfsRentalUris_web(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsStationInformationImplementors = []string{"GbfsStationInformation"}

func (ec *executionContext) _GbfsStationInformation(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsStationInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsStationInformationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsStationInformation")
		case "station_id":

			out.Values[i] = ec._GbfsStationInformation_station_id(ctx, field, obj)

		case "name":

			out.Values[i] = ec._GbfsStationInformation_name(ctx, field, obj)

		case "short_name":

			out.Values[i] = ec._GbfsStationInformation_short_name(ctx, field, obj)

		case "lat":

			out.Values[i] = ec._GbfsStationInformation_lat(ctx, field, obj)

		case "lon":

			out.Values[i] = ec._GbfsStationInformation_lon(ctx, field, obj)

		case "address":

			out.Values[i] = ec._GbfsStationInformation_address(ctx, field, obj)

		case "cross_street":

			out.Values[i] = ec._GbfsStationInformation_cross_street(ctx, field, obj)

		case "post_code":

			out.Values[i] = ec._GbfsStationInformation_post_code(ctx, field, obj)

		case "rental_methods":

			out.Values[i] = ec._GbfsStationInformation_rental_methods(ctx, field, obj)

		case "is_virtual_station":

			out.Values[i] = ec._GbfsStationInformation_is_virtual_station(ctx, field, obj)

		case "station_area":

			out.Values[i] = ec._GbfsStationInformation_station_area(ctx, field, obj)

		case "parking_type":

			out.Values[i] = ec._GbfsStationInformation_parking_type(ctx, field, obj)

		case "parking_hoop":

			out.Values[i] = ec._GbfsStationInformation_parking_hoop(ctx, field, obj)

		case "contact_phone":

			out.Values[i] = ec._GbfsStationInformation_contact_phone(ctx, field, obj)

		case "capacity":

			out.Values[i] = ec._GbfsStationInformation_capacity(ctx, field, obj)

		case "is_valet_station":

			out.Values[i] = ec._GbfsStationInformation_is_valet_station(ctx, field, obj)

		case "is_charging_station":

			out.Values[i] = ec._GbfsStationInformation_is_charging_station(ctx, field, obj)

		case "feed":

			out.Values[i] = ec._GbfsStationInformation_feed(ctx, field, obj)

		case "region":

			out.Values[i] = ec._GbfsStationInformation_region(ctx, field, obj)

		case "status":

			out.Values[i] = ec._GbfsStationInformation_status(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsStationStatusImplementors = []string{"GbfsStationStatus"}

func (ec *executionContext) _GbfsStationStatus(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsStationStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsStationStatusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsStationStatus")
		case "station_id":

			out.Values[i] = ec._GbfsStationStatus_station_id(ctx, field, obj)

		case "num_bikes_available":

			out.Values[i] = ec._GbfsStationStatus_num_bikes_available(ctx, field, obj)

		case "num_bikes_disabled":

			out.Values[i] = ec._GbfsStationStatus_num_bikes_disabled(ctx, field, obj)

		case "num_docks_available":

			out.Values[i] = ec._GbfsStationStatus_num_docks_available(ctx, field, obj)

		case "num_docks_disabled":

			out.Values[i] = ec._GbfsStationStatus_num_docks_disabled(ctx, field, obj)

		case "is_returning":

			out.Values[i] = ec._GbfsStationStatus_is_returning(ctx, field, obj)

		case "is_renting":

			out.Values[i] = ec._GbfsStationStatus_is_renting(ctx, field, obj)

		case "is_installed":

			out.Values[i] = ec._GbfsStationStatus_is_installed(ctx, field, obj)

		case "last_reported":

			out.Values[i] = ec._GbfsStationStatus_last_reported(ctx, field, obj)

		case "vehicle_types_available":

			out.Values[i] = ec._GbfsStationStatus_vehicle_types_available(ctx, field, obj)

		case "vehicle_docks_available":

			out.Values[i] = ec._GbfsStationStatus_vehicle_docks_available(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsSystemAlertImplementors = []string{"GbfsSystemAlert"}

func (ec *executionContext) _GbfsSystemAlert(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemAlert) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemAlertImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemAlert")
		case "alert_id":

			out.Values[i] = ec._GbfsSystemAlert_alert_id(ctx, field, obj)

		case "type":

			out.Values[i] = ec._GbfsSystemAlert_type(ctx, field, obj)

		case "url":

			out.Values[i] = ec._GbfsSystemAlert_url(ctx, field, obj)

		case "summary":

			out.Values[i] = ec._GbfsSystemAlert_summary(ctx, field, obj)

		case "description":

			out.Values[i] = ec._GbfsSystemAlert_description(ctx, field, obj)

		case "last_updated":

			out.Values[i] = ec._GbfsSystemAlert_last_updated(ctx, field, obj)

		case "times":

			out.Values[i] = ec._GbfsSystemAlert_times(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsSystemCalendarImplementors = []string{"GbfsSystemCalendar"}

func (ec *executionContext) _GbfsSystemCalendar(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemCalendar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemCalendarImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemCalendar")
		case "start_month":

			out.Values[i] = ec._GbfsSystemCalendar_start_month(ctx, field, obj)

		case "start_day":

			out.Values[i] = ec._GbfsSystemCalendar_start_day(ctx, field, obj)

		case "start_year":

			out.Values[i] = ec._GbfsSystemCalendar_start_year(ctx, field, obj)

		case "end_month":

			out.Values[i] = ec._GbfsSystemCalendar_end_month(ctx, field, obj)

		case "end_day":

			out.Values[i] = ec._GbfsSystemCalendar_end_day(ctx, field, obj)

		case "end_year":

			out.Values[i] = ec._GbfsSystemCalendar_end_year(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsSystemHourImplementors = []string{"GbfsSystemHour"}

func (ec *executionContext) _GbfsSystemHour(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemHour) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemHourImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemHour")
		case "user_types":

			out.Values[i] = ec._GbfsSystemHour_user_types(ctx, field, obj)

		case "days":

			out.Values[i] = ec._GbfsSystemHour_days(ctx, field, obj)

		case "start_time":

			out.Values[i] = ec._GbfsSystemHour_start_time(ctx, field, obj)

		case "end_time":

			out.Values[i] = ec._GbfsSystemHour_end_time(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsSystemInformationImplementors = []string{"GbfsSystemInformation"}

func (ec *executionContext) _GbfsSystemInformation(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemInformationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemInformation")
		case "system_id":

			out.Values[i] = ec._GbfsSystemInformation_system_id(ctx, field, obj)

		case "language":

			out.Values[i] = ec._GbfsSystemInformation_language(ctx, field, obj)

		case "name":

			out.Values[i] = ec._GbfsSystemInformation_name(ctx, field, obj)

		case "short_name":

			out.Values[i] = ec._GbfsSystemInformation_short_name(ctx, field, obj)

		case "operator":

			out.Values[i] = ec._GbfsSystemInformation_operator(ctx, field, obj)

		case "url":

			out.Values[i] = ec._GbfsSystemInformation_url(ctx, field, obj)

		case "purchase_url":

			out.Values[i] = ec._GbfsSystemInformation_purchase_url(ctx, field, obj)

		case "start_date":

			out.Values[i] = ec._GbfsSystemInformation_start_date(ctx, field, obj)

		case "phone_number":

			out.Values[i] = ec._GbfsSystemInformation_phone_number(ctx, field, obj)

		case "email":

			out.Values[i] = ec._GbfsSystemInformation_email(ctx, field, obj)

		case "feed_contact_email":

			out.Values[i] = ec._GbfsSystemInformation_feed_contact_email(ctx, field, obj)

		case "timezone":

			out.Values[i] = ec._GbfsSystemInformation_timezone(ctx, field, obj)

		case "license_url":

			out.Values[i] = ec._GbfsSystemInformation_license_url(ctx, field, obj)

		case "terms_url":

			out.Values[i] = ec._GbfsSystemInformation_terms_url(ctx, field, obj)

		case "terms_last_updated":

			out.Values[i] = ec._GbfsSystemInformation_terms_last_updated(ctx, field, obj)

		case "privacy_url":

			out.Values[i] = ec._GbfsSystemInformation_privacy_url(ctx, field, obj)

		case "privacy_last_updated":

			out.Values[i] = ec._GbfsSystemInformation_privacy_last_updated(ctx, field, obj)

		case "brand_assets":

			out.Values[i] = ec._GbfsSystemInformation_brand_assets(ctx, field, obj)

		case "rental_apps":

			out.Values[i] = ec._GbfsSystemInformation_rental_apps(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsSystemPricingPlanImplementors = []string{"GbfsSystemPricingPlan"}

func (ec *executionContext) _GbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemPricingPlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemPricingPlanImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemPricingPlan")
		case "plan_id":

			out.Values[i] = ec._GbfsSystemPricingPlan_plan_id(ctx, field, obj)

		case "url":

			out.Values[i] = ec._GbfsSystemPricingPlan_url(ctx, field, obj)

		case "name":

			out.Values[i] = ec._GbfsSystemPricingPlan_name(ctx, field, obj)

		case "currency":

			out.Values[i] = ec._GbfsSystemPricingPlan_currency(ctx, field, obj)

		case "price":

			out.Values[i] = ec._GbfsSystemPricingPlan_price(ctx, field, obj)

		case "is_taxable":

			out.Values[i] = ec._GbfsSystemPricingPlan_is_taxable(ctx, field, obj)

		case "description":

			out.Values[i] = ec._GbfsSystemPricingPlan_description(ctx, field, obj)

		case "surge_pricing":

			out.Values[i] = ec._GbfsSystemPricingPlan_surge_pricing(ctx, field, obj)

		case "per_km_pricing":

			out.Values[i] = ec._GbfsSystemPricingPlan_per_km_pricing(ctx, field, obj)

		case "per_min_pricing":

			out.Values[i] = ec._GbfsSystemPricingPlan_per_min_pricing(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsSystemRegionImplementors = []string{"GbfsSystemRegion"}

func (ec *executionContext) _GbfsSystemRegion(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemRegion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemRegionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemRegion")
		case "region_id":

			out.Values[i] = ec._GbfsSystemRegion_region_id(ctx, field, obj)

		case "name":

			out.Values[i] = ec._GbfsSystemRegion_name(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsSystemVersionImplementors = []string{"GbfsSystemVersion"}

func (ec *executionContext) _GbfsSystemVersion(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsSystemVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsSystemVersionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsSystemVersion")
		case "version":

			out.Values[i] = ec._GbfsSystemVersion_version(ctx, field, obj)

		case "url":

			out.Values[i] = ec._GbfsSystemVersion_url(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsVehicleAssetsImplementors = []string{"GbfsVehicleAssets"}

func (ec *executionContext) _GbfsVehicleAssets(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleAssets) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleAssetsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleAssets")
		case "icon_url":

			out.Values[i] = ec._GbfsVehicleAssets_icon_url(ctx, field, obj)

		case "icon_url_dark":

			out.Values[i] = ec._GbfsVehicleAssets_icon_url_dark(ctx, field, obj)

		case "icon_last_modified":

			out.Values[i] = ec._GbfsVehicleAssets_icon_last_modified(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsVehicleDockAvailableImplementors = []string{"GbfsVehicleDockAvailable"}

func (ec *executionContext) _GbfsVehicleDockAvailable(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleDockAvailable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleDockAvailableImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleDockAvailable")
		case "count":

			out.Values[i] = ec._GbfsVehicleDockAvailable_count(ctx, field, obj)

		case "vehicle_types":

			out.Values[i] = ec._GbfsVehicleDockAvailable_vehicle_types(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsVehicleTypeImplementors = []string{"GbfsVehicleType"}

func (ec *executionContext) _GbfsVehicleType(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleTypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleType")
		case "vehicle_type_id":

			out.Values[i] = ec._GbfsVehicleType_vehicle_type_id(ctx, field, obj)

		case "form_factor":

			out.Values[i] = ec._GbfsVehicleType_form_factor(ctx, field, obj)

		case "rider_capacity":

			out.Values[i] = ec._GbfsVehicleType_rider_capacity(ctx, field, obj)

		case "cargo_volume_capacity":

			out.Values[i] = ec._GbfsVehicleType_cargo_volume_capacity(ctx, field, obj)

		case "cargo_load_capacity":

			out.Values[i] = ec._GbfsVehicleType_cargo_load_capacity(ctx, field, obj)

		case "propulsion_type":

			out.Values[i] = ec._GbfsVehicleType_propulsion_type(ctx, field, obj)

		case "eco_label":

			out.Values[i] = ec._GbfsVehicleType_eco_label(ctx, field, obj)

		case "country_code":

			out.Values[i] = ec._GbfsVehicleType_country_code(ctx, field, obj)

		case "eco_sticker":

			out.Values[i] = ec._GbfsVehicleType_eco_sticker(ctx, field, obj)

		case "max_range_meters":

			out.Values[i] = ec._GbfsVehicleType_max_range_meters(ctx, field, obj)

		case "name":

			out.Values[i] = ec._GbfsVehicleType_name(ctx, field, obj)

		case "vehicle_accessories":

			out.Values[i] = ec._GbfsVehicleType_vehicle_accessories(ctx, field, obj)

		case "gco_2_km":

			out.Values[i] = ec._GbfsVehicleType_gco_2_km(ctx, field, obj)

		case "vehicle_image":

			out.Values[i] = ec._GbfsVehicleType_vehicle_image(ctx, field, obj)

		case "make":

			out.Values[i] = ec._GbfsVehicleType_make(ctx, field, obj)

		case "model":

			out.Values[i] = ec._GbfsVehicleType_model(ctx, field, obj)

		case "color":

			out.Values[i] = ec._GbfsVehicleType_color(ctx, field, obj)

		case "wheel_count":

			out.Values[i] = ec._GbfsVehicleType_wheel_count(ctx, field, obj)

		case "max_permitted_speed":

			out.Values[i] = ec._GbfsVehicleType_max_permitted_speed(ctx, field, obj)

		case "rated_power":

			out.Values[i] = ec._GbfsVehicleType_rated_power(ctx, field, obj)

		case "default_reserve_time":

			out.Values[i] = ec._GbfsVehicleType_default_reserve_time(ctx, field, obj)

		case "return_constraint":

			out.Values[i] = ec._GbfsVehicleType_return_constraint(ctx, field, obj)

		case "default_pricing_plan":

			out.Values[i] = ec._GbfsVehicleType_default_pricing_plan(ctx, field, obj)

		case "pricing_plans":

			out.Values[i] = ec._GbfsVehicleType_pricing_plans(ctx, field, obj)

		case "rental_uris":

			out.Values[i] = ec._GbfsVehicleType_rental_uris(ctx, field, obj)

		case "vehicle_assets":

			out.Values[i] = ec._GbfsVehicleType_vehicle_assets(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gbfsVehicleTypeAvailableImplementors = []string{"GbfsVehicleTypeAvailable"}

func (ec *executionContext) _GbfsVehicleTypeAvailable(ctx context.Context, sel ast.SelectionSet, obj *model.GbfsVehicleTypeAvailable) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gbfsVehicleTypeAvailableImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GbfsVehicleTypeAvailable")
		case "num_bikes_disabled":

			out.Values[i] = ec._GbfsVehicleTypeAvailable_num_bikes_disabled(ctx, field, obj)

		case "num_docks_available":

			out.Values[i] = ec._GbfsVehicleTypeAvailable_num_docks_available(ctx, field, obj)

		case "count":

			out.Values[i] = ec._GbfsVehicleTypeAvailable_count(ctx, field, obj)

		case "vehicle_type":

			out.Values[i] = ec._GbfsVehicleTypeAvailable_vehicle_type(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var itineraryImplementors = []string{"Itinerary"}

func (ec *executionContext) _Itinerary(ctx context.Context, sel ast.SelectionSet, obj *model.Itinerary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itineraryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Itinerary")
		case "duration":

			out.Values[i] = ec._Itinerary_duration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distance":

			out.Values[i] = ec._Itinerary_distance(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "start_time":

			out.Values[i] = ec._Itinerary_start_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "end_time":

			out.Values[i] = ec._Itinerary_end_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "from":

			out.Values[i] = ec._Itinerary_from(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "to":

			out.Values[i] = ec._Itinerary_to(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "legs":

			out.Values[i] = ec._Itinerary_legs(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var legImplementors = []string{"Leg"}

func (ec *executionContext) _Leg(ctx context.Context, sel ast.SelectionSet, obj *model.Leg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, legImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Leg")
		case "duration":

			out.Values[i] = ec._Leg_duration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distance":

			out.Values[i] = ec._Leg_distance(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "start_time":

			out.Values[i] = ec._Leg_start_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "end_time":

			out.Values[i] = ec._Leg_end_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "from":

			out.Values[i] = ec._Leg_from(ctx, field, obj)

		case "to":

			out.Values[i] = ec._Leg_to(ctx, field, obj)

		case "steps":

			out.Values[i] = ec._Leg_steps(ctx, field, obj)

		case "geometry":

			out.Values[i] = ec._Leg_geometry(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var levelImplementors = []string{"Level"}

func (ec *executionContext) _Level(ctx context.Context, sel ast.SelectionSet, obj *model.Level) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, levelImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Level")
		case "id":

			out.Values[i] = ec._Level_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "level_id":

			out.Values[i] = ec._Level_level_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "level_name":

			out.Values[i] = ec._Level_level_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "level_index":

			out.Values[i] = ec._Level_level_index(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "geometry":

			out.Values[i] = ec._Level_geometry(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stops":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Level_stops(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "validate_gtfs":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_validate_gtfs(ctx, field)
			})

		case "feed_version_update":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_update(ctx, field)
			})

		case "feed_version_fetch":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_fetch(ctx, field)
			})

		case "feed_version_import":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_import(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feed_version_unimport":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_unimport(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feed_version_delete":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_feed_version_delete(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var operatorImplementors = []string{"Operator"}

func (ec *executionContext) _Operator(ctx context.Context, sel ast.SelectionSet, obj *model.Operator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, operatorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Operator")
		case "id":

			out.Values[i] = ec._Operator_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "generated":

			out.Values[i] = ec._Operator_generated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "file":

			out.Values[i] = ec._Operator_file(ctx, field, obj)

		case "onestop_id":

			out.Values[i] = ec._Operator_onestop_id(ctx, field, obj)

		case "name":

			out.Values[i] = ec._Operator_name(ctx, field, obj)

		case "short_name":

			out.Values[i] = ec._Operator_short_name(ctx, field, obj)

		case "website":

			out.Values[i] = ec._Operator_website(ctx, field, obj)

		case "tags":

			out.Values[i] = ec._Operator_tags(ctx, field, obj)

		case "search_rank":

			out.Values[i] = ec._Operator_search_rank(ctx, field, obj)

		case "agencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Operator_agencies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feeds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Operator_feeds(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var pathwayImplementors = []string{"Pathway"}

func (ec *executionContext) _Pathway(ctx context.Context, sel ast.SelectionSet, obj *model.Pathway) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pathwayImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pathway")
		case "id":

			out.Values[i] = ec._Pathway_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pathway_id":

			out.Values[i] = ec._Pathway_pathway_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "pathway_mode":

			out.Values[i] = ec._Pathway_pathway_mode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "is_bidirectional":

			out.Values[i] = ec._Pathway_is_bidirectional(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "length":

			out.Values[i] = ec._Pathway_length(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "traversal_time":

			out.Values[i] = ec._Pathway_traversal_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stair_count":

			out.Values[i] = ec._Pathway_stair_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "max_slope":

			out.Values[i] = ec._Pathway_max_slope(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "min_width":

			out.Values[i] = ec._Pathway_min_width(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "signposted_as":

			out.Values[i] = ec._Pathway_signposted_as(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "reverse_signposted_as":

			out.Values[i] = ec._Pathway_reverse_signposted_as(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "from_stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pathway_from_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "to_stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pathway_to_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var placeImplementors = []string{"Place"}

func (ec *executionContext) _Place(ctx context.Context, sel ast.SelectionSet, obj *model.Place) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, placeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Place")
		case "adm0_name":

			out.Values[i] = ec._Place_adm0_name(ctx, field, obj)

		case "adm1_name":

			out.Values[i] = ec._Place_adm1_name(ctx, field, obj)

		case "city_name":

			out.Values[i] = ec._Place_city_name(ctx, field, obj)

		case "count":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Place_count(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "operators":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Place_operators(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "feed_versions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_feed_versions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "feeds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_feeds(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "agencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_agencies(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "routes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_routes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "stops":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_stops(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "trips":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_trips(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "operators":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_operators(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "directions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_directions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "bikes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bikes(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "docks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_docks(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "places":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_places(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var rTTimeRangeImplementors = []string{"RTTimeRange"}

func (ec *executionContext) _RTTimeRange(ctx context.Context, sel ast.SelectionSet, obj *model.RTTimeRange) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTTimeRangeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTTimeRange")
		case "start":

			out.Values[i] = ec._RTTimeRange_start(ctx, field, obj)

		case "end":

			out.Values[i] = ec._RTTimeRange_end(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var rTTranslationImplementors = []string{"RTTranslation"}

func (ec *executionContext) _RTTranslation(ctx context.Context, sel ast.SelectionSet, obj *model.RTTranslation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTTranslationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTTranslation")
		case "text":

			out.Values[i] = ec._RTTranslation_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "language":

			out.Values[i] = ec._RTTranslation_language(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var rTTripDescriptorImplementors = []string{"RTTripDescriptor"}

func (ec *executionContext) _RTTripDescriptor(ctx context.Context, sel ast.SelectionSet, obj *model.RTTripDescriptor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTTripDescriptorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTTripDescriptor")
		case "trip_id":

			out.Values[i] = ec._RTTripDescriptor_trip_id(ctx, field, obj)

		case "route_id":

			out.Values[i] = ec._RTTripDescriptor_route_id(ctx, field, obj)

		case "direction_id":

			out.Values[i] = ec._RTTripDescriptor_direction_id(ctx, field, obj)

		case "start_time":

			out.Values[i] = ec._RTTripDescriptor_start_time(ctx, field, obj)

		case "start_date":

			out.Values[i] = ec._RTTripDescriptor_start_date(ctx, field, obj)

		case "schedule_relationship":

			out.Values[i] = ec._RTTripDescriptor_schedule_relationship(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var rTVehicleDescriptorImplementors = []string{"RTVehicleDescriptor"}

func (ec *executionContext) _RTVehicleDescriptor(ctx context.Context, sel ast.SelectionSet, obj *model.RTVehicleDescriptor) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, rTVehicleDescriptorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RTVehicleDescriptor")
		case "id":

			out.Values[i] = ec._RTVehicleDescriptor_id(ctx, field, obj)

		case "label":

			out.Values[i] = ec._RTVehicleDescriptor_label(ctx, field, obj)

		case "license_plate":

			out.Values[i] = ec._RTVehicleDescriptor_license_plate(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var routeImplementors = []string{"Route"}

func (ec *executionContext) _Route(ctx context.Context, sel ast.SelectionSet, obj *model.Route) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Route")
		case "id":

			out.Values[i] = ec._Route_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "onestop_id":

			out.Values[i] = ec._Route_onestop_id(ctx, field, obj)

		case "route_id":

			out.Values[i] = ec._Route_route_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_short_name":

			out.Values[i] = ec._Route_route_short_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_long_name":

			out.Values[i] = ec._Route_route_long_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_type":

			out.Values[i] = ec._Route_route_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_color":

			out.Values[i] = ec._Route_route_color(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_text_color":

			out.Values[i] = ec._Route_route_text_color(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_sort_order":

			out.Values[i] = ec._Route_route_sort_order(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_url":

			out.Values[i] = ec._Route_route_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_desc":

			out.Values[i] = ec._Route_route_desc(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "continuous_pickup":

			out.Values[i] = ec._Route_continuous_pickup(ctx, field, obj)

		case "continuous_drop_off":

			out.Values[i] = ec._Route_continuous_drop_off(ctx, field, obj)

		case "geometry":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_geometry(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "agency":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_agency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_version_sha1":

			out.Values[i] = ec._Route_feed_version_sha1(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "feed_onestop_id":

			out.Values[i] = ec._Route_feed_onestop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "search_rank":

			out.Values[i] = ec._Route_search_rank(ctx, field, obj)

		case "route_attribute":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_route_attribute(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "trips":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_trips(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stops":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "route_stops":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_route_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "headways":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_headways(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "geometries":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_geometries(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "census_geographies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_census_geographies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "route_stop_buffer":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_route_stop_buffer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "patterns":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_patterns(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Route_alerts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var routeAttributeImplementors = []string{"RouteAttribute"}

func (ec *executionContext) _RouteAttribute(ctx context.Context, sel ast.SelectionSet, obj *model.RouteAttribute) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeAttributeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteAttribute")
		case "category":

			out.Values[i] = ec._RouteAttribute_category(ctx, field, obj)

		case "subcategory":

			out.Values[i] = ec._RouteAttribute_subcategory(ctx, field, obj)

		case "running_way":

			out.Values[i] = ec._RouteAttribute_running_way(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var routeGeometryImplementors = []string{"RouteGeometry"}

func (ec *executionContext) _RouteGeometry(ctx context.Context, sel ast.SelectionSet, obj *model.RouteGeometry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeGeometryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteGeometry")
		case "generated":

			out.Values[i] = ec._RouteGeometry_generated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "geometry":

			out.Values[i] = ec._RouteGeometry_geometry(ctx, field, obj)

		case "combined_geometry":

			out.Values[i] = ec._RouteGeometry_combined_geometry(ctx, field, obj)

		case "length":

			out.Values[i] = ec._RouteGeometry_length(ctx, field, obj)

		case "max_segment_length":

			out.Values[i] = ec._RouteGeometry_max_segment_length(ctx, field, obj)

		case "first_point_max_distance":

			out.Values[i] = ec._RouteGeometry_first_point_max_distance(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var routeHeadwayImplementors = []string{"RouteHeadway"}

func (ec *executionContext) _RouteHeadway(ctx context.Context, sel ast.SelectionSet, obj *model.RouteHeadway) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeHeadwayImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteHeadway")
		case "stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteHeadway_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "dow_category":

			out.Values[i] = ec._RouteHeadway_dow_category(ctx, field, obj)

		case "direction_id":

			out.Values[i] = ec._RouteHeadway_direction_id(ctx, field, obj)

		case "headway_secs":

			out.Values[i] = ec._RouteHeadway_headway_secs(ctx, field, obj)

		case "service_date":

			out.Values[i] = ec._RouteHeadway_service_date(ctx, field, obj)

		case "stop_trip_count":

			out.Values[i] = ec._RouteHeadway_stop_trip_count(ctx, field, obj)

		case "departures":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteHeadway_departures(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var routeStopImplementors = []string{"RouteStop"}

func (ec *executionContext) _RouteStop(ctx context.Context, sel ast.SelectionSet, obj *model.RouteStop) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeStopImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteStop")
		case "id":

			out.Values[i] = ec._RouteStop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_id":

			out.Values[i] = ec._RouteStop_stop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route_id":

			out.Values[i] = ec._RouteStop_route_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "agency_id":

			out.Values[i] = ec._RouteStop_agency_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "route":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStop_route(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStop_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "agency":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStop_agency(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var routeStopBufferImplementors = []string{"RouteStopBuffer"}

func (ec *executionContext) _RouteStopBuffer(ctx context.Context, sel ast.SelectionSet, obj *model.RouteStopBuffer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeStopBufferImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteStopBuffer")
		case "stop_points":

			out.Values[i] = ec._RouteStopBuffer_stop_points(ctx, field, obj)

		case "stop_buffer":

			out.Values[i] = ec._RouteStopBuffer_stop_buffer(ctx, field, obj)

		case "stop_convexhull":

			out.Values[i] = ec._RouteStopBuffer_stop_convexhull(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var routeStopPatternImplementors = []string{"RouteStopPattern"}

func (ec *executionContext) _RouteStopPattern(ctx context.Context, sel ast.SelectionSet, obj *model.RouteStopPattern) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, routeStopPatternImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RouteStopPattern")
		case "stop_pattern_id":

			out.Values[i] = ec._RouteStopPattern_stop_pattern_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "direction_id":

			out.Values[i] = ec._RouteStopPattern_direction_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "count":

			out.Values[i] = ec._RouteStopPattern_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "trips":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RouteStopPattern_trips(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var shapeImplementors = []string{"Shape"}

func (ec *executionContext) _Shape(ctx context.Context, sel ast.SelectionSet, obj *model.Shape) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, shapeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Shape")
		case "id":

			out.Values[i] = ec._Shape_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "shape_id":

			out.Values[i] = ec._Shape_shape_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "geometry":

			out.Values[i] = ec._Shape_geometry(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "generated":

			out.Values[i] = ec._Shape_generated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stepImplementors = []string{"Step"}

func (ec *executionContext) _Step(ctx context.Context, sel ast.SelectionSet, obj *model.Step) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Step")
		case "duration":

			out.Values[i] = ec._Step_duration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "distance":

			out.Values[i] = ec._Step_distance(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "start_time":

			out.Values[i] = ec._Step_start_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "end_time":

			out.Values[i] = ec._Step_end_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "to":

			out.Values[i] = ec._Step_to(ctx, field, obj)

		case "mode":

			out.Values[i] = ec._Step_mode(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "instruction":

			out.Values[i] = ec._Step_instruction(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "geometry_offset":

			out.Values[i] = ec._Step_geometry_offset(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stopImplementors = []string{"Stop"}

func (ec *executionContext) _Stop(ctx context.Context, sel ast.SelectionSet, obj *model.Stop) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Stop")
		case "id":

			out.Values[i] = ec._Stop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "onestop_id":

			out.Values[i] = ec._Stop_onestop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "location_type":

			out.Values[i] = ec._Stop_location_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_code":

			out.Values[i] = ec._Stop_stop_code(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_desc":

			out.Values[i] = ec._Stop_stop_desc(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_id":

			out.Values[i] = ec._Stop_stop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_name":

			out.Values[i] = ec._Stop_stop_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_timezone":

			out.Values[i] = ec._Stop_stop_timezone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_url":

			out.Values[i] = ec._Stop_stop_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "wheelchair_boarding":

			out.Values[i] = ec._Stop_wheelchair_boarding(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "zone_id":

			out.Values[i] = ec._Stop_zone_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "platform_code":

			out.Values[i] = ec._Stop_platform_code(ctx, field, obj)

		case "tts_stop_name":

			out.Values[i] = ec._Stop_tts_stop_name(ctx, field, obj)

		case "geometry":

			out.Values[i] = ec._Stop_geometry(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "feed_version_sha1":

			out.Values[i] = ec._Stop_feed_version_sha1(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "feed_onestop_id":

			out.Values[i] = ec._Stop_feed_onestop_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "level":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_level(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "parent":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_parent(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "external_reference":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_external_reference(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "observations":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_observations(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "children":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_children(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "route_stops":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_route_stops(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pathways_from_stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_pathways_from_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pathways_to_stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_pathways_to_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stop_times":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_stop_times(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "departures":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_departures(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "arrivals":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_arrivals(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "search_rank":

			out.Values[i] = ec._Stop_search_rank(ctx, field, obj)

		case "census_geographies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_census_geographies(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "directions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_directions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "nearby_stops":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_nearby_stops(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Stop_alerts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stopExternalReferenceImplementors = []string{"StopExternalReference"}

func (ec *executionContext) _StopExternalReference(ctx context.Context, sel ast.SelectionSet, obj *model.StopExternalReference) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopExternalReferenceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopExternalReference")
		case "id":

			out.Values[i] = ec._StopExternalReference_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "target_feed_onestop_id":

			out.Values[i] = ec._StopExternalReference_target_feed_onestop_id(ctx, field, obj)

		case "target_stop_id":

			out.Values[i] = ec._StopExternalReference_target_stop_id(ctx, field, obj)

		case "inactive":

			out.Values[i] = ec._StopExternalReference_inactive(ctx, field, obj)

		case "target_active_stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopExternalReference_target_active_stop(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stopObservationImplementors = []string{"StopObservation"}

func (ec *executionContext) _StopObservation(ctx context.Context, sel ast.SelectionSet, obj *model.StopObservation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopObservationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopObservation")
		case "schedule_relationship":

			out.Values[i] = ec._StopObservation_schedule_relationship(ctx, field, obj)

		case "trip_start_date":

			out.Values[i] = ec._StopObservation_trip_start_date(ctx, field, obj)

		case "trip_start_time":

			out.Values[i] = ec._StopObservation_trip_start_time(ctx, field, obj)

		case "from_stop_id":

			out.Values[i] = ec._StopObservation_from_stop_id(ctx, field, obj)

		case "to_stop_id":

			out.Values[i] = ec._StopObservation_to_stop_id(ctx, field, obj)

		case "agency_id":

			out.Values[i] = ec._StopObservation_agency_id(ctx, field, obj)

		case "route_id":

			out.Values[i] = ec._StopObservation_route_id(ctx, field, obj)

		case "trip_id":

			out.Values[i] = ec._StopObservation_trip_id(ctx, field, obj)

		case "stop_sequence":

			out.Values[i] = ec._StopObservation_stop_sequence(ctx, field, obj)

		case "source":

			out.Values[i] = ec._StopObservation_source(ctx, field, obj)

		case "scheduled_arrival_time":

			out.Values[i] = ec._StopObservation_scheduled_arrival_time(ctx, field, obj)

		case "scheduled_departure_time":

			out.Values[i] = ec._StopObservation_scheduled_departure_time(ctx, field, obj)

		case "observed_arrival_time":

			out.Values[i] = ec._StopObservation_observed_arrival_time(ctx, field, obj)

		case "observed_departure_time":

			out.Values[i] = ec._StopObservation_observed_departure_time(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stopTimeImplementors = []string{"StopTime"}

func (ec *executionContext) _StopTime(ctx context.Context, sel ast.SelectionSet, obj *model.StopTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopTimeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopTime")
		case "arrival_time":

			out.Values[i] = ec._StopTime_arrival_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "departure_time":

			out.Values[i] = ec._StopTime_departure_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_sequence":

			out.Values[i] = ec._StopTime_stop_sequence(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_headsign":

			out.Values[i] = ec._StopTime_stop_headsign(ctx, field, obj)

		case "pickup_type":

			out.Values[i] = ec._StopTime_pickup_type(ctx, field, obj)

		case "drop_off_type":

			out.Values[i] = ec._StopTime_drop_off_type(ctx, field, obj)

		case "timepoint":

			out.Values[i] = ec._StopTime_timepoint(ctx, field, obj)

		case "interpolated":

			out.Values[i] = ec._StopTime_interpolated(ctx, field, obj)

		case "stop":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_stop(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "trip":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_trip(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "arrival":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_arrival(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "departure":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._StopTime_departure(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "continuous_drop_off":

			out.Values[i] = ec._StopTime_continuous_drop_off(ctx, field, obj)

		case "continuous_pickup":

			out.Values[i] = ec._StopTime_continuous_pickup(ctx, field, obj)

		case "shape_dist_traveled":

			out.Values[i] = ec._StopTime_shape_dist_traveled(ctx, field, obj)

		case "service_date":

			out.Values[i] = ec._StopTime_service_date(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var stopTimeEventImplementors = []string{"StopTimeEvent"}

func (ec *executionContext) _StopTimeEvent(ctx context.Context, sel ast.SelectionSet, obj *model.StopTimeEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stopTimeEventImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StopTimeEvent")
		case "stop_timezone":

			out.Values[i] = ec._StopTimeEvent_stop_timezone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "scheduled":

			out.Values[i] = ec._StopTimeEvent_scheduled(ctx, field, obj)

		case "estimated":

			out.Values[i] = ec._StopTimeEvent_estimated(ctx, field, obj)

		case "estimated_utc":

			out.Values[i] = ec._StopTimeEvent_estimated_utc(ctx, field, obj)

		case "delay":

			out.Values[i] = ec._StopTimeEvent_delay(ctx, field, obj)

		case "uncertainty":

			out.Values[i] = ec._StopTimeEvent_uncertainty(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var tripImplementors = []string{"Trip"}

func (ec *executionContext) _Trip(ctx context.Context, sel ast.SelectionSet, obj *model.Trip) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, tripImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Trip")
		case "id":

			out.Values[i] = ec._Trip_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "trip_id":

			out.Values[i] = ec._Trip_trip_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "trip_headsign":

			out.Values[i] = ec._Trip_trip_headsign(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "trip_short_name":

			out.Values[i] = ec._Trip_trip_short_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "direction_id":

			out.Values[i] = ec._Trip_direction_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "block_id":

			out.Values[i] = ec._Trip_block_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "wheelchair_accessible":

			out.Values[i] = ec._Trip_wheelchair_accessible(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "bikes_allowed":

			out.Values[i] = ec._Trip_bikes_allowed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stop_pattern_id":

			out.Values[i] = ec._Trip_stop_pattern_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "calendar":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_calendar(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "route":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_route(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "shape":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_shape(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "feed_version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_feed_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "stop_times":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_stop_times(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "frequencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_frequencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "schedule_relationship":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_schedule_relationship(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "timestamp":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_timestamp(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "alerts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Trip_alerts(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var validationResultImplementors = []string{"ValidationResult"}

func (ec *executionContext) _ValidationResult(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationResult")
		case "success":

			out.Values[i] = ec._ValidationResult_success(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "failure_reason":

			out.Values[i] = ec._ValidationResult_failure_reason(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._ValidationResult_errors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "warnings":

			out.Values[i] = ec._ValidationResult_warnings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "sha1":

			out.Values[i] = ec._ValidationResult_sha1(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "earliest_calendar_date":

			out.Values[i] = ec._ValidationResult_earliest_calendar_date(ctx, field, obj)

		case "latest_calendar_date":

			out.Values[i] = ec._ValidationResult_latest_calendar_date(ctx, field, obj)

		case "files":

			out.Values[i] = ec._ValidationResult_files(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "service_levels":

			out.Values[i] = ec._ValidationResult_service_levels(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agencies":

			out.Values[i] = ec._ValidationResult_agencies(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "routes":

			out.Values[i] = ec._ValidationResult_routes(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "stops":

			out.Values[i] = ec._ValidationResult_stops(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feed_infos":

			out.Values[i] = ec._ValidationResult_feed_infos(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var validationResultErrorImplementors = []string{"ValidationResultError"}

func (ec *executionContext) _ValidationResultError(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationResultError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationResultErrorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationResultError")
		case "filename":

			out.Values[i] = ec._ValidationResultError_filename(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "error_type":

			out.Values[i] = ec._ValidationResultError_error_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "entity_id":

			out.Values[i] = ec._ValidationResultError_entity_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "field":

			out.Values[i] = ec._ValidationResultError_field(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._ValidationResultError_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "message":

			out.Values[i] = ec._ValidationResultError_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var validationResultErrorGroupImplementors = []string{"ValidationResultErrorGroup"}

func (ec *executionContext) _ValidationResultErrorGroup(ctx context.Context, sel ast.SelectionSet, obj *model.ValidationResultErrorGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, validationResultErrorGroupImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ValidationResultErrorGroup")
		case "filename":

			out.Values[i] = ec._ValidationResultErrorGroup_filename(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "error_type":

			out.Values[i] = ec._ValidationResultErrorGroup_error_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "count":

			out.Values[i] = ec._ValidationResultErrorGroup_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "limit":

			out.Values[i] = ec._ValidationResultErrorGroup_limit(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "errors":

			out.Values[i] = ec._ValidationResultErrorGroup_errors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var vehiclePositionImplementors = []string{"VehiclePosition"}

func (ec *executionContext) _VehiclePosition(ctx context.Context, sel ast.SelectionSet, obj *model.VehiclePosition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, vehiclePositionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VehiclePosition")
		case "vehicle":

			out.Values[i] = ec._VehiclePosition_vehicle(ctx, field, obj)

		case "position":

			out.Values[i] = ec._VehiclePosition_position(ctx, field, obj)

		case "current_stop_sequence":

			out.Values[i] = ec._VehiclePosition_current_stop_sequence(ctx, field, obj)

		case "stop_id":

			out.Values[i] = ec._VehiclePosition_stop_id(ctx, field, obj)

		case "current_status":

			out.Values[i] = ec._VehiclePosition_current_status(ctx, field, obj)

		case "timestamp":

			out.Values[i] = ec._VehiclePosition_timestamp(ctx, field, obj)

		case "congestion_level":

			out.Values[i] = ec._VehiclePosition_congestion_level(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var waypointImplementors = []string{"Waypoint"}

func (ec *executionContext) _Waypoint(ctx context.Context, sel ast.SelectionSet, obj *model.Waypoint) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waypointImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Waypoint")
		case "lon":

			out.Values[i] = ec._Waypoint_lon(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "lat":

			out.Values[i] = ec._Waypoint_lat(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Waypoint_name(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx context.Context, sel ast.SelectionSet, v model.Agency) graphql.Marshaler {
	return ec._Agency(ctx, sel, &v)
}

func (ec *executionContext) marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx context.Context, sel ast.SelectionSet, v []model.Agency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx context.Context, sel ast.SelectionSet, v []*model.Agency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx context.Context, sel ast.SelectionSet, v *model.Agency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Agency(ctx, sel, v)
}

func (ec *executionContext) marshalNAgencyPlace2githubcominterlineiotransitlandservermodelAgencyPlace(ctx context.Context, sel ast.SelectionSet, v *model.AgencyPlace) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AgencyPlace(ctx, sel, v)
}

func (ec *executionContext) marshalNAlert2githubcominterlineiotransitlandservermodelAlert(ctx context.Context, sel ast.SelectionSet, v *model.Alert) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Alert(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNCalendar2githubcominterlineiotransitlandservermodelCalendar(ctx context.Context, sel ast.SelectionSet, v model.Calendar) graphql.Marshaler {
	return ec._Calendar(ctx, sel, &v)
}

func (ec *executionContext) marshalNCalendar2githubcominterlineiotransitlandservermodelCalendar(ctx context.Context, sel ast.SelectionSet, v *model.Calendar) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Calendar(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusGeography2githubcominterlineiotransitlandservermodelCensusGeography(ctx context.Context, sel ast.SelectionSet, v *model.CensusGeography) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusGeography(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusTable2githubcominterlineiotransitlandservermodelCensusTable(ctx context.Context, sel ast.SelectionSet, v model.CensusTable) graphql.Marshaler {
	return ec._CensusTable(ctx, sel, &v)
}

func (ec *executionContext) marshalNCensusTable2githubcominterlineiotransitlandservermodelCensusTable(ctx context.Context, sel ast.SelectionSet, v *model.CensusTable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CensusTable(ctx, sel, v)
}

func (ec *executionContext) marshalNCensusValue2githubcominterlineiotransitlandservermodelCensusValue(ctx context.Context, sel ast.SelectionSet, v []*model.CensusValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCensusValue2githubcominterlineiotransitlandservermodelCensusValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, v interface{}) (tt.Date, error) {
	var res tt.Date
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, sel ast.SelectionSet, v tt.Date) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, v interface{}) ([]*tt.Date, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*tt.Date, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, sel ast.SelectionSet, v []*tt.Date) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, v interface{}) (*tt.Date, error) {
	var res = new(tt.Date)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, sel ast.SelectionSet, v *tt.Date) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNDirectionRequest2githubcominterlineiotransitlandservermodelDirectionRequest(ctx context.Context, v interface{}) (model.DirectionRequest, error) {
	res, err := ec.unmarshalInputDirectionRequest(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDirections2githubcominterlineiotransitlandservermodelDirections(ctx context.Context, sel ast.SelectionSet, v model.Directions) graphql.Marshaler {
	return ec._Directions(ctx, sel, &v)
}

func (ec *executionContext) marshalNDirections2githubcominterlineiotransitlandservermodelDirections(ctx context.Context, sel ast.SelectionSet, v *model.Directions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Directions(ctx, sel, v)
}

func (ec *executionContext) marshalNDistance2githubcominterlineiotransitlandservermodelDistance(ctx context.Context, sel ast.SelectionSet, v *model.Distance) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Distance(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistanceUnit2githubcominterlineiotransitlandservermodelDistanceUnit(ctx context.Context, v interface{}) (model.DistanceUnit, error) {
	var res model.DistanceUnit
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistanceUnit2githubcominterlineiotransitlandservermodelDistanceUnit(ctx context.Context, sel ast.SelectionSet, v model.DistanceUnit) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDuration2githubcominterlineiotransitlandservermodelDuration(ctx context.Context, sel ast.SelectionSet, v *model.Duration) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Duration(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDurationUnit2githubcominterlineiotransitlandservermodelDurationUnit(ctx context.Context, v interface{}) (model.DurationUnit, error) {
	var res model.DurationUnit
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDurationUnit2githubcominterlineiotransitlandservermodelDurationUnit(ctx context.Context, sel ast.SelectionSet, v model.DurationUnit) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFeed2githubcominterlineiotransitlandservermodelFeed(ctx context.Context, sel ast.SelectionSet, v model.Feed) graphql.Marshaler {
	return ec._Feed(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeed2githubcominterlineiotransitlandservermodelFeed(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2githubcominterlineiotransitlandservermodelFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeed2githubcominterlineiotransitlandservermodelFeed(ctx context.Context, sel ast.SelectionSet, v *model.Feed) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Feed(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedFetch2githubcominterlineiotransitlandservermodelFeedFetch(ctx context.Context, sel ast.SelectionSet, v *model.FeedFetch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedFetch(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx context.Context, sel ast.SelectionSet, v model.FeedInfo) graphql.Marshaler {
	return ec._FeedInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx context.Context, sel ast.SelectionSet, v []model.FeedInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx context.Context, sel ast.SelectionSet, v []*model.FeedInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedInfo2githubcominterlineiotransitlandservermodelFeedInfo(ctx context.Context, sel ast.SelectionSet, v *model.FeedInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx context.Context, v interface{}) (model.FeedSpecTypes, error) {
	var res model.FeedSpecTypes
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx context.Context, sel ast.SelectionSet, v model.FeedSpecTypes) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v model.FeedVersion) graphql.Marshaler {
	return ec._FeedVersion(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v []*model.FeedVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersion(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionDeleteResult2githubcominterlineiotransitlandservermodelFeedVersionDeleteResult(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionDeleteResult) graphql.Marshaler {
	return ec._FeedVersionDeleteResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionDeleteResult2githubcominterlineiotransitlandservermodelFeedVersionDeleteResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionDeleteResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionDeleteResult(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionFileInfo) graphql.Marshaler {
	return ec._FeedVersionFileInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, v []model.FeedVersionFileInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, v []*model.FeedVersionFileInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersionFileInfo2githubcominterlineiotransitlandservermodelFeedVersionFileInfo(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionFileInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionFileInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionImportResult2githubcominterlineiotransitlandservermodelFeedVersionImportResult(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionImportResult) graphql.Marshaler {
	return ec._FeedVersionImportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionImportResult2githubcominterlineiotransitlandservermodelFeedVersionImportResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionImportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionImportResult(ctx, sel, v)
}

func (ec *executionContext) marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionServiceLevel) graphql.Marshaler {
	return ec._FeedVersionServiceLevel(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, v []model.FeedVersionServiceLevel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, v []*model.FeedVersionServiceLevel) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFeedVersionServiceLevel2githubcominterlineiotransitlandservermodelFeedVersionServiceLevel(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionServiceLevel) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionServiceLevel(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFeedVersionSetInput2githubcominterlineiotransitlandservermodelFeedVersionSetInput(ctx context.Context, v interface{}) (model.FeedVersionSetInput, error) {
	res, err := ec.unmarshalInputFeedVersionSetInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedVersionUnimportResult2githubcominterlineiotransitlandservermodelFeedVersionUnimportResult(ctx context.Context, sel ast.SelectionSet, v model.FeedVersionUnimportResult) graphql.Marshaler {
	return ec._FeedVersionUnimportResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNFeedVersionUnimportResult2githubcominterlineiotransitlandservermodelFeedVersionUnimportResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionUnimportResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FeedVersionUnimportResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNFrequency2githubcominterlineiotransitlandservermodelFrequency(ctx context.Context, sel ast.SelectionSet, v []*model.Frequency) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFrequency2githubcominterlineiotransitlandservermodelFrequency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFrequency2githubcominterlineiotransitlandservermodelFrequency(ctx context.Context, sel ast.SelectionSet, v *model.Frequency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Frequency(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsAlertTime2githubcominterlineiotransitlandservermodelGbfsAlertTime(ctx context.Context, sel ast.SelectionSet, v *model.GbfsAlertTime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsAlertTime(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsFreeBikeStatus2githubcominterlineiotransitlandservermodelGbfsFreeBikeStatus(ctx context.Context, sel ast.SelectionSet, v *model.GbfsFreeBikeStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsFreeBikeStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsGeofenceFeature2githubcominterlineiotransitlandservermodelGbfsGeofenceFeature(ctx context.Context, sel ast.SelectionSet, v *model.GbfsGeofenceFeature) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsGeofenceFeature(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsPlanPrice2githubcominterlineiotransitlandservermodelGbfsPlanPrice(ctx context.Context, sel ast.SelectionSet, v *model.GbfsPlanPrice) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsPlanPrice(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx context.Context, sel ast.SelectionSet, v *model.GbfsStationInformation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsStationInformation(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemAlert2githubcominterlineiotransitlandservermodelGbfsSystemAlert(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemAlert) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemAlert(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemCalendar2githubcominterlineiotransitlandservermodelGbfsSystemCalendar(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemCalendar) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemCalendar(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemHour2githubcominterlineiotransitlandservermodelGbfsSystemHour(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemHour) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemHour(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsSystemPricingPlan2githubcominterlineiotransitlandservermodelGbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemPricingPlan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsSystemPricingPlan(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsVehicleDockAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleDockAvailable(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleDockAvailable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsVehicleDockAvailable(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsVehicleType(ctx, sel, v)
}

func (ec *executionContext) marshalNGbfsVehicleTypeAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleTypeAvailable(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleTypeAvailable) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GbfsVehicleTypeAvailable(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNItinerary2githubcominterlineiotransitlandservermodelItinerary(ctx context.Context, sel ast.SelectionSet, v *model.Itinerary) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Itinerary(ctx, sel, v)
}

func (ec *executionContext) marshalNLeg2githubcominterlineiotransitlandservermodelLeg(ctx context.Context, sel ast.SelectionSet, v *model.Leg) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Leg(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLineString2githubcominterlineiotransitlandlibtlttLineString(ctx context.Context, v interface{}) (tt.LineString, error) {
	var res tt.LineString
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLineString2githubcominterlineiotransitlandlibtlttLineString(ctx context.Context, sel ast.SelectionSet, v tt.LineString) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNOperator2githubcominterlineiotransitlandservermodelOperator(ctx context.Context, sel ast.SelectionSet, v []*model.Operator) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOperator2githubcominterlineiotransitlandservermodelOperator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOperator2githubcominterlineiotransitlandservermodelOperator(ctx context.Context, sel ast.SelectionSet, v *model.Operator) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Operator(ctx, sel, v)
}

func (ec *executionContext) marshalNPathway2githubcominterlineiotransitlandservermodelPathway(ctx context.Context, sel ast.SelectionSet, v []*model.Pathway) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPathway2githubcominterlineiotransitlandservermodelPathway(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPathway2githubcominterlineiotransitlandservermodelPathway(ctx context.Context, sel ast.SelectionSet, v *model.Pathway) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Pathway(ctx, sel, v)
}

func (ec *executionContext) marshalNPlace2githubcominterlineiotransitlandservermodelPlace(ctx context.Context, sel ast.SelectionSet, v *model.Place) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Place(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPoint2githubcominterlineiotransitlandlibtlttPoint(ctx context.Context, v interface{}) (tt.Point, error) {
	var res tt.Point
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPoint2githubcominterlineiotransitlandlibtlttPoint(ctx context.Context, sel ast.SelectionSet, v tt.Point) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx context.Context, v interface{}) (tt.Polygon, error) {
	var res tt.Polygon
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx context.Context, sel ast.SelectionSet, v tt.Polygon) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRTTimeRange2githubcominterlineiotransitlandservermodelRTTimeRange(ctx context.Context, sel ast.SelectionSet, v *model.RTTimeRange) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RTTimeRange(ctx, sel, v)
}

func (ec *executionContext) marshalNRTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx context.Context, sel ast.SelectionSet, v []*model.RTTranslation) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx context.Context, sel ast.SelectionSet, v *model.RTTranslation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RTTranslation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRole2githubcominterlineiotransitlandservermodelRole(ctx context.Context, v interface{}) (model.Role, error) {
	var res model.Role
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRole2githubcominterlineiotransitlandservermodelRole(ctx context.Context, sel ast.SelectionSet, v model.Role) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx context.Context, sel ast.SelectionSet, v model.Route) graphql.Marshaler {
	return ec._Route(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx context.Context, sel ast.SelectionSet, v []model.Route) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx context.Context, sel ast.SelectionSet, v []*model.Route) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoute2githubcominterlineiotransitlandservermodelRoute(ctx context.Context, sel ast.SelectionSet, v *model.Route) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Route(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteGeometry2githubcominterlineiotransitlandservermodelRouteGeometry(ctx context.Context, sel ast.SelectionSet, v []*model.RouteGeometry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteGeometry2githubcominterlineiotransitlandservermodelRouteGeometry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouteGeometry2githubcominterlineiotransitlandservermodelRouteGeometry(ctx context.Context, sel ast.SelectionSet, v *model.RouteGeometry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteGeometry(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteHeadway2githubcominterlineiotransitlandservermodelRouteHeadway(ctx context.Context, sel ast.SelectionSet, v []*model.RouteHeadway) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteHeadway2githubcominterlineiotransitlandservermodelRouteHeadway(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouteHeadway2githubcominterlineiotransitlandservermodelRouteHeadway(ctx context.Context, sel ast.SelectionSet, v *model.RouteHeadway) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteHeadway(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteStop2githubcominterlineiotransitlandservermodelRouteStop(ctx context.Context, sel ast.SelectionSet, v []*model.RouteStop) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteStop2githubcominterlineiotransitlandservermodelRouteStop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRouteStop2githubcominterlineiotransitlandservermodelRouteStop(ctx context.Context, sel ast.SelectionSet, v *model.RouteStop) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteStop(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteStopBuffer2githubcominterlineiotransitlandservermodelRouteStopBuffer(ctx context.Context, sel ast.SelectionSet, v model.RouteStopBuffer) graphql.Marshaler {
	return ec._RouteStopBuffer(ctx, sel, &v)
}

func (ec *executionContext) marshalNRouteStopBuffer2githubcominterlineiotransitlandservermodelRouteStopBuffer(ctx context.Context, sel ast.SelectionSet, v *model.RouteStopBuffer) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteStopBuffer(ctx, sel, v)
}

func (ec *executionContext) marshalNRouteStopPattern2githubcominterlineiotransitlandservermodelRouteStopPattern(ctx context.Context, sel ast.SelectionSet, v *model.RouteStopPattern) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RouteStopPattern(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, v interface{}) (tt.WideTime, error) {
	var res tt.WideTime
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, sel ast.SelectionSet, v tt.WideTime) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, v interface{}) (*tt.WideTime, error) {
	var res = new(tt.WideTime)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, sel ast.SelectionSet, v *tt.WideTime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNStep2githubcominterlineiotransitlandservermodelStep(ctx context.Context, sel ast.SelectionSet, v *model.Step) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Step(ctx, sel, v)
}

func (ec *executionContext) unmarshalNStepMode2githubcominterlineiotransitlandservermodelStepMode(ctx context.Context, v interface{}) (model.StepMode, error) {
	var res model.StepMode
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStepMode2githubcominterlineiotransitlandservermodelStepMode(ctx context.Context, sel ast.SelectionSet, v model.StepMode) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx context.Context, sel ast.SelectionSet, v model.Stop) graphql.Marshaler {
	return ec._Stop(ctx, sel, &v)
}

func (ec *executionContext) marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx context.Context, sel ast.SelectionSet, v []model.Stop) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx context.Context, sel ast.SelectionSet, v []*model.Stop) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx context.Context, sel ast.SelectionSet, v *model.Stop) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Stop(ctx, sel, v)
}

func (ec *executionContext) marshalNStopObservation2githubcominterlineiotransitlandservermodelStopObservation(ctx context.Context, sel ast.SelectionSet, v *model.StopObservation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StopObservation(ctx, sel, v)
}

func (ec *executionContext) marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v []*model.StopTime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v []*model.StopTime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v *model.StopTime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StopTime(ctx, sel, v)
}

func (ec *executionContext) marshalNStopTimeEvent2githubcominterlineiotransitlandservermodelStopTimeEvent(ctx context.Context, sel ast.SelectionSet, v model.StopTimeEvent) graphql.Marshaler {
	return ec._StopTimeEvent(ctx, sel, &v)
}

func (ec *executionContext) marshalNStopTimeEvent2githubcominterlineiotransitlandservermodelStopTimeEvent(ctx context.Context, sel ast.SelectionSet, v *model.StopTimeEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StopTimeEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx context.Context, sel ast.SelectionSet, v model.Trip) graphql.Marshaler {
	return ec._Trip(ctx, sel, &v)
}

func (ec *executionContext) marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx context.Context, sel ast.SelectionSet, v []*model.Trip) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx context.Context, sel ast.SelectionSet, v *model.Trip) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Trip(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationResultError2githubcominterlineiotransitlandservermodelValidationResultError(ctx context.Context, sel ast.SelectionSet, v []*model.ValidationResultError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationResultError2githubcominterlineiotransitlandservermodelValidationResultError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNValidationResultError2githubcominterlineiotransitlandservermodelValidationResultError(ctx context.Context, sel ast.SelectionSet, v *model.ValidationResultError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ValidationResultError(ctx, sel, v)
}

func (ec *executionContext) marshalNValidationResultErrorGroup2githubcominterlineiotransitlandservermodelValidationResultErrorGroup(ctx context.Context, sel ast.SelectionSet, v model.ValidationResultErrorGroup) graphql.Marshaler {
	return ec._ValidationResultErrorGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNValidationResultErrorGroup2githubcominterlineiotransitlandservermodelValidationResultErrorGroup(ctx context.Context, sel ast.SelectionSet, v []model.ValidationResultErrorGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNValidationResultErrorGroup2githubcominterlineiotransitlandservermodelValidationResultErrorGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx context.Context, sel ast.SelectionSet, v *model.Waypoint) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Waypoint(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWaypointInput2githubcominterlineiotransitlandservermodelWaypointInput(ctx context.Context, v interface{}) (*model.WaypointInput, error) {
	res, err := ec.unmarshalInputWaypointInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAgency2githubcominterlineiotransitlandservermodelAgency(ctx context.Context, sel ast.SelectionSet, v []*model.Agency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAgency2githubcominterlineiotransitlandservermodelAgency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAgencyFilter2githubcominterlineiotransitlandservermodelAgencyFilter(ctx context.Context, v interface{}) (*model.AgencyFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAgencyFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAgencyPlace2githubcominterlineiotransitlandservermodelAgencyPlace(ctx context.Context, sel ast.SelectionSet, v []*model.AgencyPlace) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAgencyPlace2githubcominterlineiotransitlandservermodelAgencyPlace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAgencyPlaceFilter2githubcominterlineiotransitlandservermodelAgencyPlaceFilter(ctx context.Context, v interface{}) (*model.AgencyPlaceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAgencyPlaceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAlert2githubcominterlineiotransitlandservermodelAlert(ctx context.Context, sel ast.SelectionSet, v []*model.Alert) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAlert2githubcominterlineiotransitlandservermodelAlert(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOAny2interface(ctx context.Context, v interface{}) (interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalAny(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAny2interface(ctx context.Context, sel ast.SelectionSet, v interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalAny(v)
	return res
}

func (ec *executionContext) unmarshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx context.Context, v interface{}) (tt.Bool, error) {
	var res tt.Bool
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBool2githubcominterlineiotransitlandlibtlttBool(ctx context.Context, sel ast.SelectionSet, v tt.Bool) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOCensusGeography2githubcominterlineiotransitlandservermodelCensusGeography(ctx context.Context, sel ast.SelectionSet, v []*model.CensusGeography) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCensusGeography2githubcominterlineiotransitlandservermodelCensusGeography(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCensusValue2githubcominterlineiotransitlandservermodelCensusValue(ctx context.Context, sel ast.SelectionSet, v *model.CensusValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CensusValue(ctx, sel, v)
}

func (ec *executionContext) unmarshalODate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, v interface{}) (tt.Date, error) {
	var res tt.Date
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, sel ast.SelectionSet, v tt.Date) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalODate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, v interface{}) (*tt.Date, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Date)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODate2githubcominterlineiotransitlandlibtlttDate(ctx context.Context, sel ast.SelectionSet, v *tt.Date) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODistance2githubcominterlineiotransitlandservermodelDistance(ctx context.Context, sel ast.SelectionSet, v *model.Distance) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Distance(ctx, sel, v)
}

func (ec *executionContext) marshalODuration2githubcominterlineiotransitlandservermodelDuration(ctx context.Context, sel ast.SelectionSet, v *model.Duration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Duration(ctx, sel, v)
}

func (ec *executionContext) marshalOFeed2githubcominterlineiotransitlandservermodelFeed(ctx context.Context, sel ast.SelectionSet, v []*model.Feed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeed2githubcominterlineiotransitlandservermodelFeed(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOFeedAuthorization2githubcominterlineiotransitlandservermodelFeedAuthorization(ctx context.Context, sel ast.SelectionSet, v *model.FeedAuthorization) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedAuthorization(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedFetch2githubcominterlineiotransitlandservermodelFeedFetch(ctx context.Context, sel ast.SelectionSet, v []*model.FeedFetch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedFetch2githubcominterlineiotransitlandservermodelFeedFetch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFeedFetchFilter2githubcominterlineiotransitlandservermodelFeedFetchFilter(ctx context.Context, v interface{}) (*model.FeedFetchFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedFetchFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeedFilter2githubcominterlineiotransitlandservermodelFeedFilter(ctx context.Context, v interface{}) (*model.FeedFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedLicense2githubcominterlineiotransitlandservermodelFeedLicense(ctx context.Context, sel ast.SelectionSet, v *model.FeedLicense) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedLicense(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFeedSourceUrl2githubcominterlineiotransitlandservermodelFeedSourceURL(ctx context.Context, v interface{}) (*model.FeedSourceURL, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedSourceUrl(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeedSourceUrlTypes2githubcominterlineiotransitlandservermodelFeedSourceURLTypes(ctx context.Context, v interface{}) (*model.FeedSourceURLTypes, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FeedSourceURLTypes)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedSourceUrlTypes2githubcominterlineiotransitlandservermodelFeedSourceURLTypes(ctx context.Context, sel ast.SelectionSet, v *model.FeedSourceURLTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx context.Context, v interface{}) ([]model.FeedSpecTypes, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.FeedSpecTypes, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx context.Context, sel ast.SelectionSet, v []model.FeedSpecTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx context.Context, v interface{}) (*model.FeedSpecTypes, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.FeedSpecTypes)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedSpecTypes2githubcominterlineiotransitlandservermodelFeedSpecTypes(ctx context.Context, sel ast.SelectionSet, v *model.FeedSpecTypes) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOFeedState2githubcominterlineiotransitlandservermodelFeedState(ctx context.Context, sel ast.SelectionSet, v *model.FeedState) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedState(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedUrls2githubcominterlineiotransitlandservermodelFeedUrls(ctx context.Context, sel ast.SelectionSet, v *model.FeedUrls) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedUrls(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedVersion2githubcominterlineiotransitlandservermodelFeedVersion(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedVersion(ctx, sel, v)
}

func (ec *executionContext) marshalOFeedVersionFetchResult2githubcominterlineiotransitlandservermodelFeedVersionFetchResult(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionFetchResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedVersionFetchResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFeedVersionFilter2githubcominterlineiotransitlandservermodelFeedVersionFilter(ctx context.Context, v interface{}) (*model.FeedVersionFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedVersionFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedVersionGtfsImport2githubcominterlineiotransitlandservermodelFeedVersionGtfsImport(ctx context.Context, sel ast.SelectionSet, v *model.FeedVersionGtfsImport) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FeedVersionGtfsImport(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFeedVersionServiceLevelFilter2githubcominterlineiotransitlandservermodelFeedVersionServiceLevelFilter(ctx context.Context, v interface{}) (*model.FeedVersionServiceLevelFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFeedVersionServiceLevelFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx context.Context, v interface{}) (tt.Float, error) {
	var res tt.Float
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2githubcominterlineiotransitlandlibtlttFloat(ctx context.Context, sel ast.SelectionSet, v tt.Float) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloat(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloat(*v)
	return res
}

func (ec *executionContext) marshalOGbfsAlertTime2githubcominterlineiotransitlandservermodelGbfsAlertTime(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsAlertTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsAlertTime2githubcominterlineiotransitlandservermodelGbfsAlertTime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGbfsBikeRequest2githubcominterlineiotransitlandservermodelGbfsBikeRequest(ctx context.Context, v interface{}) (*model.GbfsBikeRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGbfsBikeRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGbfsBrandAsset2githubcominterlineiotransitlandservermodelGbfsBrandAsset(ctx context.Context, sel ast.SelectionSet, v *model.GbfsBrandAsset) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsBrandAsset(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGbfsDockRequest2githubcominterlineiotransitlandservermodelGbfsDockRequest(ctx context.Context, v interface{}) (*model.GbfsDockRequest, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGbfsDockRequest(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGbfsFeed2githubcominterlineiotransitlandservermodelGbfsFeed(ctx context.Context, sel ast.SelectionSet, v *model.GbfsFeed) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsFeed(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsFreeBikeStatus2githubcominterlineiotransitlandservermodelGbfsFreeBikeStatus(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsFreeBikeStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsFreeBikeStatus2githubcominterlineiotransitlandservermodelGbfsFreeBikeStatus(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsGeofenceFeature2githubcominterlineiotransitlandservermodelGbfsGeofenceFeature(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsGeofenceFeature) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsGeofenceFeature2githubcominterlineiotransitlandservermodelGbfsGeofenceFeature(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsGeofenceRule2githubcominterlineiotransitlandservermodelGbfsGeofenceRule(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsGeofenceRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGbfsGeofenceRule2githubcominterlineiotransitlandservermodelGbfsGeofenceRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGbfsGeofenceRule2githubcominterlineiotransitlandservermodelGbfsGeofenceRule(ctx context.Context, sel ast.SelectionSet, v *model.GbfsGeofenceRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsGeofenceRule(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsPlanPrice2githubcominterlineiotransitlandservermodelGbfsPlanPrice(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsPlanPrice) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsPlanPrice2githubcominterlineiotransitlandservermodelGbfsPlanPrice(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsRentalApp2githubcominterlineiotransitlandservermodelGbfsRentalApp(ctx context.Context, sel ast.SelectionSet, v *model.GbfsRentalApp) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsRentalApp(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsRentalApps2githubcominterlineiotransitlandservermodelGbfsRentalApps(ctx context.Context, sel ast.SelectionSet, v *model.GbfsRentalApps) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsRentalApps(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsRentalUris2githubcominterlineiotransitlandservermodelGbfsRentalUris(ctx context.Context, sel ast.SelectionSet, v *model.GbfsRentalUris) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsRentalUris(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsStationInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsStationInformation2githubcominterlineiotransitlandservermodelGbfsStationInformation(ctx context.Context, sel ast.SelectionSet, v *model.GbfsStationInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsStationInformation(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsStationStatus2githubcominterlineiotransitlandservermodelGbfsStationStatus(ctx context.Context, sel ast.SelectionSet, v *model.GbfsStationStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsStationStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsSystemAlert2githubcominterlineiotransitlandservermodelGbfsSystemAlert(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemAlert) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemAlert2githubcominterlineiotransitlandservermodelGbfsSystemAlert(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemCalendar2githubcominterlineiotransitlandservermodelGbfsSystemCalendar(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemCalendar) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemCalendar2githubcominterlineiotransitlandservermodelGbfsSystemCalendar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemHour2githubcominterlineiotransitlandservermodelGbfsSystemHour(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemHour) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemHour2githubcominterlineiotransitlandservermodelGbfsSystemHour(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemInformation2githubcominterlineiotransitlandservermodelGbfsSystemInformation(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsSystemInformation(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandservermodelGbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsSystemPricingPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsSystemPricingPlan2githubcominterlineiotransitlandservermodelGbfsSystemPricingPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsSystemPricingPlan2githubcominterlineiotransitlandservermodelGbfsSystemPricingPlan(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemPricingPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsSystemPricingPlan(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsSystemRegion2githubcominterlineiotransitlandservermodelGbfsSystemRegion(ctx context.Context, sel ast.SelectionSet, v *model.GbfsSystemRegion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsSystemRegion(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsVehicleAssets2githubcominterlineiotransitlandservermodelGbfsVehicleAssets(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleAssets) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsVehicleAssets(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsVehicleDockAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleDockAvailable(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsVehicleDockAvailable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsVehicleDockAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleDockAvailable(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsVehicleType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGbfsVehicleType2githubcominterlineiotransitlandservermodelGbfsVehicleType(ctx context.Context, sel ast.SelectionSet, v *model.GbfsVehicleType) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GbfsVehicleType(ctx, sel, v)
}

func (ec *executionContext) marshalOGbfsVehicleTypeAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleTypeAvailable(ctx context.Context, sel ast.SelectionSet, v []*model.GbfsVehicleTypeAvailable) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGbfsVehicleTypeAvailable2githubcominterlineiotransitlandservermodelGbfsVehicleTypeAvailable(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx context.Context, v interface{}) (tt.Geometry, error) {
	var res tt.Geometry
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx context.Context, sel ast.SelectionSet, v tt.Geometry) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx context.Context, v interface{}) (*tt.Geometry, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Geometry)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGeometry2githubcominterlineiotransitlandlibtlttGeometry(ctx context.Context, sel ast.SelectionSet, v *tt.Geometry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOImportStatus2githubcominterlineiotransitlandservermodelImportStatus(ctx context.Context, v interface{}) (*model.ImportStatus, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ImportStatus)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOImportStatus2githubcominterlineiotransitlandservermodelImportStatus(ctx context.Context, sel ast.SelectionSet, v *model.ImportStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx context.Context, v interface{}) (tt.Int, error) {
	var res tt.Int
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2githubcominterlineiotransitlandlibtlttInt(ctx context.Context, sel ast.SelectionSet, v tt.Int) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOItinerary2githubcominterlineiotransitlandservermodelItinerary(ctx context.Context, sel ast.SelectionSet, v []*model.Itinerary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItinerary2githubcominterlineiotransitlandservermodelItinerary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLeg2githubcominterlineiotransitlandservermodelLeg(ctx context.Context, sel ast.SelectionSet, v []*model.Leg) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLeg2githubcominterlineiotransitlandservermodelLeg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOLevel2githubcominterlineiotransitlandservermodelLevel(ctx context.Context, sel ast.SelectionSet, v *model.Level) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Level(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLicenseFilter2githubcominterlineiotransitlandservermodelLicenseFilter(ctx context.Context, v interface{}) (*model.LicenseFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLicenseFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOLicenseValue2githubcominterlineiotransitlandservermodelLicenseValue(ctx context.Context, v interface{}) (*model.LicenseValue, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.LicenseValue)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLicenseValue2githubcominterlineiotransitlandservermodelLicenseValue(ctx context.Context, sel ast.SelectionSet, v *model.LicenseValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOLineString2githubcominterlineiotransitlandlibtlttLineString(ctx context.Context, v interface{}) (tt.LineString, error) {
	var res tt.LineString
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLineString2githubcominterlineiotransitlandlibtlttLineString(ctx context.Context, sel ast.SelectionSet, v tt.LineString) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalOOperator2githubcominterlineiotransitlandservermodelOperator(ctx context.Context, sel ast.SelectionSet, v []*model.Operator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOperator2githubcominterlineiotransitlandservermodelOperator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOOperator2githubcominterlineiotransitlandservermodelOperator(ctx context.Context, sel ast.SelectionSet, v *model.Operator) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Operator(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOperatorFilter2githubcominterlineiotransitlandservermodelOperatorFilter(ctx context.Context, v interface{}) (*model.OperatorFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOperatorFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlace2githubcominterlineiotransitlandservermodelPlace(ctx context.Context, sel ast.SelectionSet, v []*model.Place) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlace2githubcominterlineiotransitlandservermodelPlace(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPlaceAggregationLevel2githubcominterlineiotransitlandservermodelPlaceAggregationLevel(ctx context.Context, v interface{}) (*model.PlaceAggregationLevel, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.PlaceAggregationLevel)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPlaceAggregationLevel2githubcominterlineiotransitlandservermodelPlaceAggregationLevel(ctx context.Context, sel ast.SelectionSet, v *model.PlaceAggregationLevel) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPlaceFilter2githubcominterlineiotransitlandservermodelPlaceFilter(ctx context.Context, v interface{}) (*model.PlaceFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPlaceFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPoint2githubcominterlineiotransitlandlibtlttPoint(ctx context.Context, v interface{}) (*tt.Point, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Point)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPoint2githubcominterlineiotransitlandlibtlttPoint(ctx context.Context, sel ast.SelectionSet, v *tt.Point) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOPointRadius2githubcominterlineiotransitlandservermodelPointRadius(ctx context.Context, v interface{}) (*model.PointRadius, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPointRadius(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx context.Context, v interface{}) (*tt.Polygon, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Polygon)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPolygon2githubcominterlineiotransitlandlibtlttPolygon(ctx context.Context, sel ast.SelectionSet, v *tt.Polygon) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalORTTimeRange2githubcominterlineiotransitlandservermodelRTTimeRange(ctx context.Context, sel ast.SelectionSet, v []*model.RTTimeRange) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRTTimeRange2githubcominterlineiotransitlandservermodelRTTimeRange(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx context.Context, sel ast.SelectionSet, v []*model.RTTranslation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRTTranslation2githubcominterlineiotransitlandservermodelRTTranslation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalORTVehicleDescriptor2githubcominterlineiotransitlandservermodelRTVehicleDescriptor(ctx context.Context, sel ast.SelectionSet, v *model.RTVehicleDescriptor) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RTVehicleDescriptor(ctx, sel, v)
}

func (ec *executionContext) marshalORouteAttribute2githubcominterlineiotransitlandservermodelRouteAttribute(ctx context.Context, sel ast.SelectionSet, v *model.RouteAttribute) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RouteAttribute(ctx, sel, v)
}

func (ec *executionContext) unmarshalORouteFilter2githubcominterlineiotransitlandservermodelRouteFilter(ctx context.Context, v interface{}) (*model.RouteFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRouteFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORouteStopPattern2githubcominterlineiotransitlandservermodelRouteStopPattern(ctx context.Context, sel ast.SelectionSet, v []*model.RouteStopPattern) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRouteStopPattern2githubcominterlineiotransitlandservermodelRouteStopPattern(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOScheduleRelationship2githubcominterlineiotransitlandservermodelScheduleRelationship(ctx context.Context, v interface{}) (*model.ScheduleRelationship, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.ScheduleRelationship)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOScheduleRelationship2githubcominterlineiotransitlandservermodelScheduleRelationship(ctx context.Context, sel ast.SelectionSet, v *model.ScheduleRelationship) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, v interface{}) (tt.WideTime, error) {
	var res tt.WideTime
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, sel ast.SelectionSet, v tt.WideTime) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, v interface{}) ([]*tt.WideTime, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*tt.WideTime, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, sel ast.SelectionSet, v []*tt.WideTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, v interface{}) (*tt.WideTime, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.WideTime)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSeconds2githubcominterlineiotransitlandlibtlttWideTime(ctx context.Context, sel ast.SelectionSet, v *tt.WideTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOShape2githubcominterlineiotransitlandservermodelShape(ctx context.Context, sel ast.SelectionSet, v *model.Shape) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Shape(ctx, sel, v)
}

func (ec *executionContext) marshalOStep2githubcominterlineiotransitlandservermodelStep(ctx context.Context, sel ast.SelectionSet, v []*model.Step) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStep2githubcominterlineiotransitlandservermodelStep(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOStepMode2githubcominterlineiotransitlandservermodelStepMode(ctx context.Context, v interface{}) (*model.StepMode, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(model.StepMode)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStepMode2githubcominterlineiotransitlandservermodelStepMode(ctx context.Context, sel ast.SelectionSet, v *model.StepMode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx context.Context, sel ast.SelectionSet, v []*model.Stop) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStop2githubcominterlineiotransitlandservermodelStop(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStop2githubcominterlineiotransitlandservermodelStop(ctx context.Context, sel ast.SelectionSet, v *model.Stop) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Stop(ctx, sel, v)
}

func (ec *executionContext) marshalOStopExternalReference2githubcominterlineiotransitlandservermodelStopExternalReference(ctx context.Context, sel ast.SelectionSet, v *model.StopExternalReference) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StopExternalReference(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStopFilter2githubcominterlineiotransitlandservermodelStopFilter(ctx context.Context, v interface{}) (*model.StopFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStopObservation2githubcominterlineiotransitlandservermodelStopObservation(ctx context.Context, sel ast.SelectionSet, v []*model.StopObservation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStopObservation2githubcominterlineiotransitlandservermodelStopObservation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOStopObservationFilter2githubcominterlineiotransitlandservermodelStopObservationFilter(ctx context.Context, v interface{}) (*model.StopObservationFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopObservationFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStopTime2githubcominterlineiotransitlandservermodelStopTime(ctx context.Context, sel ast.SelectionSet, v *model.StopTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StopTime(ctx, sel, v)
}

func (ec *executionContext) unmarshalOStopTimeFilter2githubcominterlineiotransitlandservermodelStopTimeFilter(ctx context.Context, v interface{}) (*model.StopTimeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputStopTimeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOString2githubcominterlineiotransitlandlibtlttString(ctx context.Context, v interface{}) (tt.String, error) {
	var res tt.String
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2githubcominterlineiotransitlandlibtlttString(ctx context.Context, sel ast.SelectionSet, v tt.String) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStrings2githubcominterlineiotransitlandlibtlttStrings(ctx context.Context, v interface{}) (tt.Strings, error) {
	if v == nil {
		return nil, nil
	}
	var res tt.Strings
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStrings2githubcominterlineiotransitlandlibtlttStrings(ctx context.Context, sel ast.SelectionSet, v tt.Strings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx context.Context, v interface{}) (tt.Tags, error) {
	var res tt.Tags
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx context.Context, sel ast.SelectionSet, v tt.Tags) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx context.Context, v interface{}) (*tt.Tags, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(tt.Tags)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTags2githubcominterlineiotransitlandlibtlttTags(ctx context.Context, sel ast.SelectionSet, v *tt.Tags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOTime2githubcominterlineiotransitlandlibtlttTime(ctx context.Context, v interface{}) (tt.Time, error) {
	var res tt.Time
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2githubcominterlineiotransitlandlibtlttTime(ctx context.Context, sel ast.SelectionSet, v tt.Time) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTrip2githubcominterlineiotransitlandservermodelTrip(ctx context.Context, sel ast.SelectionSet, v []*model.Trip) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTrip2githubcominterlineiotransitlandservermodelTrip(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTripFilter2githubcominterlineiotransitlandservermodelTripFilter(ctx context.Context, v interface{}) (*model.TripFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTripFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTripStopTimeFilter2githubcominterlineiotransitlandservermodelTripStopTimeFilter(ctx context.Context, v interface{}) (*model.TripStopTimeFilter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTripStopTimeFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, v interface{}) (*graphql.Upload, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalUpload(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpload2githubcom99designsgqlgengraphqlUpload(ctx context.Context, sel ast.SelectionSet, v *graphql.Upload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalUpload(*v)
	return res
}

func (ec *executionContext) marshalOValidationResult2githubcominterlineiotransitlandservermodelValidationResult(ctx context.Context, sel ast.SelectionSet, v *model.ValidationResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ValidationResult(ctx, sel, v)
}

func (ec *executionContext) marshalOWaypoint2githubcominterlineiotransitlandservermodelWaypoint(ctx context.Context, sel ast.SelectionSet, v *model.Waypoint) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Waypoint(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWaypointInput2githubcominterlineiotransitlandservermodelWaypointInput(ctx context.Context, v interface{}) (*model.WaypointInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWaypointInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
