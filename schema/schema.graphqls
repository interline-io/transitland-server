# Scalar types
scalar Counts
scalar Tags
scalar Geometry
scalar Time
scalar Date
scalar Point
scalar LineString
scalar Seconds
scalar Polygon
scalar Map
scalar Any
scalar Upload
scalar Key
scalar Bool
scalar Strings

# Force resolver
directive @goField(forceResolver: Boolean, name: String) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Root query
type Query {
  "Feeds"
  feeds(limit: Int, after: Int, ids: [Int!], where: FeedFilter): [Feed!]!
  "Operators"
  operators(limit: Int, after: Int, ids: [Int!], where: OperatorFilter): [Operator!]!
  "Feed versions"
  feed_versions(limit: Int, after: Int, ids: [Int!], where: FeedVersionFilter): [FeedVersion!]!
  "Currently imported agencies. If no feed version is specified, defaults to active feed versions."
  agencies(limit: Int, after: Int, ids: [Int!], where: AgencyFilter): [Agency!]!
  "Currently imported routes. If no feed version is specified, defaults to active feed versions."
  routes(limit: Int, after: Int, ids: [Int!], where: RouteFilter): [Route!]!
  "Currently imported stops. If no feed version is specified, defaults to active feed versions."
  stops(limit: Int, after: Int, ids: [Int!], where: StopFilter): [Stop!]!
  "Currently imported trips. If no feed version is specified, defaults to active feed versions."
  trips(limit: Int, after: Int, ids: [Int!], where: TripFilter): [Trip!]!
  "Operator counts by administrative place"
  places(limit: Int,after: Int, level: PlaceAggregationLevel, where: PlaceFilter): [Place!]
  "Directions requests API"
  directions(where: DirectionRequest!): Directions!
  "Current GBFS floating bike data"
  bikes(limit: Int, where: GbfsBikeRequest): [GbfsFreeBikeStatus!]
  "Current GBFS dock data"
  docks(limit: Int, where: GbfsDockRequest): [GbfsStationInformation!]
  "Current user metadata"
  me: Me!
}

# Root mutation
type Mutation {
  # Feed version mutations
  "Validate GTFS"
  validate_gtfs(file: Upload, url: String, realtime_urls: [String!]): ValidationReport
  "Update a feed version"
  feed_version_update(set: FeedVersionSetInput!): FeedVersion
  "Fetch a feed version"
  feed_version_fetch(file: Upload, url: String, feed_onestop_id: String!): FeedVersionFetchResult
  "Import a feed version"
  feed_version_import(id: Int!): FeedVersionImportResult!
  "Unimport a feed version"
  feed_version_unimport(id: Int!): FeedVersionUnimportResult!
  "Delete a feed version"
  feed_version_delete(id: Int!): FeedVersionDeleteResult!
  
  # Entity editing
  "Create a stop"
  stop_create(set: StopSetInput!): Stop!
  "Update a stop"
  stop_update(set: StopSetInput!): Stop!
  "Delete a stop"
  stop_delete(id: Int!): EntityDeleteResult!
  
  # levels
  "Create a level"
  level_create(set: LevelSetInput!): Level!
  "Update a level"
  level_update(set: LevelSetInput!): Level!
  "Delete a level"
  level_delete(id: Int!): EntityDeleteResult!
  
  # pathways
  "Create a pathway"
  pathway_create(set: PathwaySetInput!): Pathway!
  "Update a pathway"
  pathway_update(set: PathwaySetInput!): Pathway!
  "Delete a pathway"
  pathway_delete(id: Int!): EntityDeleteResult!
}

"""
Result of entity delete operation
"""
type EntityDeleteResult {
  "ID of deleted entity"
  id: Int!
}

"""
Current user metadata
"""
type Me {
  "Internal identifier"
  id: String!
  "User name"
  name: String
  "User email"
  email: String
  "User associated roles"
  roles: [String!]
  "User associated external data, e.g. metering service identifiers"
  external_data: Map!
}

"""
Feeds contain details on how to access transit information, including URLs to data sources in various formats (GTFS, GTFS-RT, GBFS, etc), license information, related feeds, details on how to make authorized requests, and feed version archives. Feed versions are archived (as `.zip` files) and imported into the Transitland database for querying agencies, stops, routes, trips, etc.
"""
type Feed {
  "Unique integer ID"
  id: Int!
  "Onestop ID for this feed"
  onestop_id: String!
  "A common name for this feed. Optional. Alternatively use `associated_operators[].name`"
  name: String
  "Source DMFR file for this feed"
  file: String!
  "Type of feed"
  spec: FeedSpecTypes
  "Language(s) included in this feed"
  languages: [String!]
  "Source DMFR tags for this feed"
  tags: Tags
  "Authorization metadata for fetching data from this feed"
  authorization: FeedAuthorization
  "URLs associated with this feed"
  urls: FeedUrls
  "Feed license metadata"
  license: FeedLicense
  "Search rank: internal"
  search_rank: String # only for search results
  "Operators associated with this feed"
  associated_operators: [Operator!]
  "Current feed state"
  feed_state: FeedState
  "Fetch attempts for this feed"
  feed_fetches(limit: Int, where: FeedFetchFilter): [FeedFetch!]
  "Versions of this feed that have been fetched, archived, and imported"
  feed_versions(limit: Int, where: FeedVersionFilter): [FeedVersion!]!
}

"""
Details on the current state of this feed, such as active version, last fetch time, etc.
"""
type FeedState {
  "Internal integer ID"
  id: Int!
  "The active feed version for this feed"
  feed_version: FeedVersion
}

"""
Record of a feed fetch operation
"""
type FeedFetch {
  "Internal integer ID"
  id: Int!
  "URL type, e.g. static_current, realtime_alerts..."
  url_type: String
  "URL fetched"
  url: String
  "Was the request successful?"
  success: Boolean
  "Fetched at"
  fetched_at: Time
  "Exception log if the fetch did not succeed"
  fetch_error: String
  "Server response size, in bytes"
  response_size: Int
  "Server response code (if HTTP)"
  response_code: Int
  "SHA1 sum of the server response"
  response_sha1: String
}

"""
Details on how to construct an HTTP request to access a protected resource
"""
type FeedAuthorization {
  "Method for inserting authorization secret into request"
  type: String!
  "When `type=query_param`, this specifies the name of the query parameter. When `type=header`, this specifies the name of the header"
  param_name: String!
  "Website to visit to sign up for an account"
  info_url: String!
}

"""
License information for this feed, curated by Interline and contributors to the Transitland Atlas feed registry. Note that this does not constitute legal advice. Users are advised to review and confirm any terms and conditions attached to a source feed.
"""
type FeedLicense {
  "SPDX identifier for a common license. See https://spdx.org/licenses/"
  spdx_identifier: String!
  "URL for a custom license"
  url: String!
  "Are feed consumers allowed to use the feed contents without including attribution text in their app or map?"
  use_without_attribution: String!
  "Are feed consumers allowed to create and share derived products from the feed?"
  create_derived_product: String!
  "Are feed consumers allowed to redistribute the feed in its entirety?"
  redistribution_allowed: String!
  "Are feed consumers allowed to use the feed for commercial purposes?"
  commercial_use_allowed: String!
  "Are feed consumers allowed to keep their modifications of this feed private?"
  share_alike_optional: String!
  "Feed consumers must include this particular text when using this feed"
  attribution_text: String!
  "Feed consumers must follow these instructions for how to provide attribution"
  attribution_instructions: String!
}

"""
URL(s) from which Transitland sources a feed
"""
type FeedUrls {
  "URL for the static feed that represents today's service"
  static_current: String!
  "URLs for static feeds that represent past service that is no longer in effect "
  static_historic: [String!]!
  "URLs for static feeds that represent service planned for upcoming dates. Typically used to represent calendar/service changes that will take effect few weeks or months in the future"
  static_planned: String!
  "URL for GTFS Realtime VehiclePosition messages"
  realtime_vehicle_positions: String!
  "URL for GTFS Realtime TripUpdate messages"
  realtime_trip_updates: String!
  "URL for GTFS Realtime Alert messages"
  realtime_alerts: String!
  "URL for GBFS feed `gbfs.json` auto-discovery file"
  gbfs_auto_discovery: String!
  "URL for MDS feed provider endpoint"
  mds_provider: String!
}

"""
Feed versions represent a specific static GTFS file that was published at a particular point in time, and are generally accessed and referenced using the [SHA1 checksum](https://en.wikipedia.org/wiki/SHA-1) of the GTFS archive.
"""
type FeedVersion {
  "Internal integer ID"
  id: Int!
  "SHA1 hash of the zip file [example:ab5bdc8b6cedd06792d42186a9b542504c5eef9a]"
  sha1: String!
  "Time when the file was fetched from the url [example:2021-07-09T05:11:00Z]"
  fetched_at: Time!
  "URL used to fetch the file"
  url: String!
  "The earliest date with scheduled service [example:2020-01-01]"
  earliest_calendar_date: Date!
  "The latest date with scheduled service [example:2020-12-31]"
  latest_calendar_date: Date!
  "Record created by user"
  created_by: String
  "Record updated by user"
  updated_by: String
  "An optional name for this feed version"
  name: String
  "An optional description for this feed version"
  description: String
  "Reference to file storage location"
  file: String  
  "Convex hull around all active stops in the feed version"
  geometry: Polygon
  "Feed associated with this feed version"
  feed: Feed!
  "Current database import status of this feed version"
  feed_version_gtfs_import: FeedVersionGtfsImport
  "Metadata for each text file present in the main directory of the zip archive "
  files(limit: Int): [FeedVersionFileInfo!]!
  "Service levels (in seconds per day) for this feed version"
  service_levels(limit: Int, where: FeedVersionServiceLevelFilter): [FeedVersionServiceLevel!]!
  "Agencies associated with this feed version, if imported"
  agencies(limit: Int, where: AgencyFilter): [Agency!]!
  "Routes associated with this feed version, if imported"
  routes(limit: Int, where: RouteFilter): [Route!]!
  "Stops associated with this feed version, if imported"
  stops(limit: Int, where: StopFilter): [Stop!]!
  "Trips associated with this feed version, if imported"
  trips(limit: Int, where: TripFilter): [Trip!]!
  "Feed infos associated with this feed version, if imported"
  feed_infos(limit: Int): [FeedInfo!]!
  "Validation reports associated with this feed version"
  validation_reports(limit: Int, where: ValidationReportFilter): [ValidationReport!]
  "Normalized route segment data associated with this feed version, if available"
  segments(limit: Int): [Segment!]
}

"""
Metadata for each file contained within a GTFS archive
"""
type FeedVersionFileInfo {
  "Internal integer ID"
  id: Int!
  "Name of the file"
  name: String!
  "Number of rows in the file"
  rows: Int!
  "SHA1 hash of the file"
  sha1: String!
  "Normalized header row of the file, if CSV-like"
  header: String!
  "Is the file CSV-like?"
  csv_like: Boolean!
  "File size, in bytes"
  size: Int!
  "Counts of values for each column"
  values_count: Counts!
  "Counts of number of unique values for each column"
  values_unique: Counts!
}

"""
Current database import status for a feed version
"""
type FeedVersionGtfsImport {
  "Internal integer ID"
  id: Int!
  "Is the import currently in-progress"
  in_progress: Boolean!
  "Did the import complete successfully"
  success: Boolean!
  "Has the schedule (stop times, trips) been archived"
  schedule_removed: Boolean!
  "Exception log if any errors occurred during import"
  exception_log: String!
  "Counts of entities skipped due to errors"
  skip_entity_error_count: Any
  "Counts of successfully imported entities by file name"
  entity_count: Any
  "Counts of warnings by file name"
  warning_count: Any
  "Counts of entities skipped due to reference errors"
  skip_entity_reference_count: Any
  "Counts of entities skipped due to import filters"
  skip_entity_filter_count: Any
  "Counts of entities skipped due to marker filters"
  skip_entity_marked_count: Any
  "Number of stop times with arrival/departure times set by interpolation during import process"
  interpolated_stop_time_count: Int
  "Created at"
  created_at: Time
  "Updated at"
  updated_at: Time
}

"""
Number of seconds of service scheduled for each day in a feed version
"""
type FeedVersionServiceLevel {
  "Internal integer ID"
  id: Int!
  "Start date of this week"
  start_date: Date!
  "End date of this week"
  end_date: Date!
  "Number of seconds of service scheduled on the Monday of this week"
  monday: Int!
  "Number of seconds of service scheduled on the Tuesday of this week"
  tuesday: Int!
  "Number of seconds of service scheduled on the Wednesday of this week"
  wednesday: Int!
  "Number of seconds of service scheduled on the Thursday of this week"
  thursday: Int!
  "Number of seconds of service scheduled on the Friday of this week"
  friday: Int!
  "Number of seconds of service scheduled on the Saturday of this week"
  saturday: Int!
  "Number of seconds of service scheduled on the Sunday of this week"
  sunday: Int!
}

# Operator
"""
An agency represents a single GTFS `agencies.txt` entity that was imported from a single feed version. The metadata, routes, etc., for an agency include only the data for that specific agency in that specific feed version. 

Operators are a higher-level abstraction over agencies, with each operator defined by an entry in the [Transitland Atlas](/documentation/atlas). Operators provide a method for enriching the basic GTFS agency data, as well as grouping agencies that span across multiple source feeds. Operators are matched with GTFS agencies using `associated_feeds`, a simple list of Feed OnestopIDs and GTFS `agency_id`s. For instance, the [Atlas operator record](https://github.com/transitland/transitland-atlas/blob/master/operators/o-dr5r-nyct.json) for the [New York City MTA](/operators/o-dr5r-nyct) has `associated_feeds` values for 8 different GTFS feeds. A query for this operator OnestopID thus represents the union of data from all 8 feeds, and includes routes for the subway, bus service for all 5 boroughs, commuter rail agencies, etc., operated by the MTA. This record also includes additional metadata about the MTA, such as the United States National Transit Database ID, Wikidata IDs, and alternate names for the agency. Operator records are created and maintained through pull requests to the Atlas json files and synchronized with the Transitland database on each commit.
"""
type Operator {
  "Internal integer ID"
  id: Int!
  "Was this operator generated automatically from GTFS data"
  generated: Boolean!
  "Source DMFR file for this operator"
  file: String
  "OnestopID for this operator"
  onestop_id: String
  "Operator name"
  name: String
  "Operator short name, if available"
  short_name: String
  "Operator website, if available"
  website: String
  "Source DMFR tag data"
  tags: Tags
  "Search rank: internal"
  search_rank: String
  "Currently imported and active agencies associated with this operator"
  agencies: [Agency!]
  "Feeds associated with this operator"
  feeds(limit: Int, where: FeedFilter): [Feed!]
}

# GTFS Entities

"""
See https://gtfs.org/schedule/reference/#agencytxt
"""
type Agency {
  "Internal integer ID"
  id: Int!
  "OnestopID for this agency (or its associated operator)"
  onestop_id: String!
  "GTFS agency.agency_email"
  agency_email: String!
  "GTFS agency.agency_fare_url"
  agency_fare_url: String!
  "GTFS agency.agency_id"
  agency_id: String!
  "GTFS agency.agency_lang"
  agency_lang: String!
  "GTFS agency.agency_name"
  agency_name: String!
  "GTFS agency.agency_phone"
  agency_phone: String!
  "GTFS agency.agency_timezone"
  agency_timezone: String!
  "GTFS agency.agency_url"
  agency_url: String!
  "Feed version SHA1 associated with this entity"
  feed_version_sha1: String
  "Feed Onestop ID associated with this entity"
  feed_onestop_id: String
  "Source feed version for this entity"
  feed_version: FeedVersion!
  "Geometry for this agency, generated as the convex hull of all stops"
  geometry: Polygon
  "Search rank: internal"
  search_rank: String
  "Operator associated with this agency"
  operator: Operator
  "Places associated with this agency through a matching process"
  places(limit: Int, where: AgencyPlaceFilter): [AgencyPlace!]
  "Routes associated with this agency"
  routes(limit: Int, where: RouteFilter): [Route!]!
  "Census geographies associated with this agency"
  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]
  "GTFS-RT alerts for this agency"
  alerts(active: Boolean, limit: Int): [Alert!]
}

"""
See https://gtfs.org/schedule/reference/#routestxt
"""
type Route {
  "Internal integer ID"
  id: Int!
  "OnestopID for this route"
  onestop_id: String
  "GTFS routes.route_id"
  route_id: String!
  "GTFS routes.route_short_name"
  route_short_name: String!
  "GTFS routes.route_long_name"
  route_long_name: String!
  "GTFS routes.route_type"
  route_type: Int!
  "GTFS routes.route_color"
  route_color: String!
  "GTFS routes.route_text_color"
  route_text_color: String!
  "GTFS routes.route_sort_order"
  route_sort_order: Int!
  "GTFS routes.route_url"
  route_url: String!
  "GTFS routes.route_desc"
  route_desc: String!
  "GTFS routes.continuous_pickup"
  continuous_pickup: Int
  "GTFS routes.continuous_drop_off"
  continuous_drop_off: Int
  "Representative geometry for this route"
  geometry: Geometry @goField(forceResolver: true)
  "Agency associated with this route"
  agency: Agency!
  "Feed version SHA1 associated with this entity"
  feed_version_sha1: String
  "Feed Onestop ID associated with this entity"
  feed_onestop_id: String
  "Source feed version for this entity"
  feed_version: FeedVersion!
  "Search rank: internal"
  search_rank: String
  "Extended route attributes, based on MTC GTFS+ extension"
  route_attribute: RouteAttribute
  "Trips associated with this route"
  trips(limit: Int, where: TripFilter): [Trip!]!
  "Stops associated with this route"
  stops(limit: Int, where: StopFilter): [Stop!]!
  "Stops associated with this route"
  route_stops(limit: Int): [RouteStop!]!
  "Calculated headways for this route"
  headways(limit: Int): [RouteHeadway!]!
  "Representative geometries for this route"
  geometries(limit: Int): [RouteGeometry!]!
  "Census geographies associated with this route"
  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]
  "Calculated spatial buffer geometry around this route"
  route_stop_buffer(radius: Float): RouteStopBuffer!
  "Stop patterns for this route"
  patterns: [RouteStopPattern!]
  "GTFS-RT alerts for this route"
  alerts(active: Boolean, limit: Int): [Alert!]
  "Normalized route segment data for this route, if available"
  segments(limit: Int, where: SegmentFilter): [Segment!]
  "Normalized route segment patterns for this route, if available"
  segment_patterns(limit: Int, where: SegmentPatternFilter): [SegmentPattern!]
}

"""
See https://gtfs.org/reference/static/#stopstxt
"""
type Stop {
  "Internal integer ID"
  id: Int!
  "Onestop ID for this stop, if available [example:s-dr5ruvgnyk-madisonav~e69st]"
  onestop_id: String!
  "GTFS stops.location_type [enum:0,1,2,3,4]"
  location_type: Int!
  "GTFS stops.stop_code"
  stop_code: String!
  "GTFS stops.stop_desc [example:NW Corner of Broadway and 14th]"
  stop_desc: String!
  "GTFS stops.stop_id [example:400029]"
  stop_id: String!
  "GTFS stops.stop_name [example:MADISON AV/E 68 ST]"
  stop_name: String!
  "GTFS stops.stop_timezone; if overriding agency/route timezone [example:America/Los_Angeles]"
  stop_timezone: String!
  "GTFS stops.stop_url [example:https://www.bart.gov/stations/ftvl]"
  stop_url: String!
  "GTFS stops.wheelchair_boarding [enum:0,1,2]"
  wheelchair_boarding: Int!
  "GTFS stops.zone_id"
  zone_id: String!
  "GTFS stops.platform_code"
  platform_code: String
  "GTFS stops.tts_stop_name"
  tts_stop_name: String
  "Stop geometry"
  geometry: Point!
  "Feed Version SHA1 identifier"
  feed_version_sha1: String!
  "Feed Onestop ID"
  feed_onestop_id: String!
  "Feed Version"
  feed_version: FeedVersion!
  "Stop Level"
  level: Level
  "Stop Parent Station"
  parent: Stop
  "Stop External Reference"
  external_reference: StopExternalReference  
  "Stop Observations"
  observations(limit: Int, where: StopObservationFilter): [StopObservation!]
  "Stop Children"
  children(limit: Int): [Stop!]
  "Associated Routes"
  route_stops(limit: Int): [RouteStop!]!
  "Dependent Levels"
  child_levels(limit: Int): [Level!]!
  "Pathways from this stop"
  pathways_from_stop(limit: Int): [Pathway!]!
  "Pathways to this stop"
  pathways_to_stop(limit: Int): [Pathway!]!
  "Stop times for this stop"
  stop_times(limit: Int, where: StopTimeFilter): [StopTime!]!
  "Departures from this stop for a given date and time"
  departures(limit: Int, where: StopTimeFilter): [StopTime!]!
  "Arrivals from this stop for a given date and time"
  arrivals(limit: Int, where: StopTimeFilter): [StopTime!]!
  "Search Rank: Internal"
  search_rank: String
  "State/Province associated with this stop"
  place: StopPlace
  "Census geographies associated with this stop"
  census_geographies(layer: String!, radius: Float, limit: Int): [CensusGeography!]
  "Directions from this stop"
  directions(to:WaypointInput, from: WaypointInput, mode: StepMode, depart_at: Time): Directions!
  "Stops within a specified radius of this stop"
  nearby_stops(limit: Int, radius: Float): [Stop!]
  "GTFS-RT Alerts for this stop"
  alerts(active: Boolean, limit: Int): [Alert!]
}

"""
The GTFS-Pathways extension uses a graph representation to describe subway or train, with nodes (the locations) and edges (the pathways). See https://gtfs.org/reference/static/#pathwaystxt
"""
type Pathway {
  "Internal integer ID"
  id: Int!
  "GTFS pathways.pathway_id"
  pathway_id: String!
  "GTFS pathways.pathway_mode"
  pathway_mode: Int!
  "GTFS pathways.is_bidirectional"
  is_bidirectional: Int!
  "GTFS pathways.length"
  length: Float!
  "GTFS pathways.traversal_time"
  traversal_time: Int!
  "GTFS pathways.stair_count"
  stair_count: Int!
  "GTFS pathways.max_slope"
  max_slope: Float!
  "GTFS pathways.min_width"
  min_width: Float!
  "GTFS pathways.signposted_ss"
  signposted_as: String!
  "GTFS pathways.reverse_signposted_as"
  reverse_signposted_as: String!
  "Pathway begins at this stop"
  from_stop: Stop!
  "Pathway ends at this stop"
  to_stop: Stop!
}

"""
Describe the different levels of a station. Is mostly useful when used in conjunction with pathways. See https://gtfs.org/reference/static/#levelstxt
"""
type Level {
  "Internal integer ID"
  id: Int!
  "GTFS levels.level_id"
  level_id: String!
  "GTFS levels.level_name"
  level_name: String!
  "GTFS levels.level_index"
  level_index: Float!
  "An optional geometry describing the footprint of this level"
  geometry: Polygon!
  "Stops associated with this level"
  stops: [Stop!]
}

"""
Record from a static GTFS [trips.txt](https://gtfs.org/schedule/reference/#tripstxt) file optionally enriched with by GTFS Realtime [TripUpdate](https://gtfs.org/reference/realtime/v2/#message-tripupdate) and [Alert](https://gtfs.org/reference/realtime/v2/#message-alert) messages.
"""
type Trip {
  "Internal integer ID"
  id: Int!
  "GTFS trips.trip_id"
  trip_id: String!
  "GTFS trips.trip_headsign"
  trip_headsign: String!
  "GTFS trips.trip_short_name"
  trip_short_name: String!
  "GTFS trips.direction_id"
  direction_id: Int!
  "GTFS trips.block_id"
  block_id: String!
  "GTFS trips.wheelchair_accessible"
  wheelchair_accessible: Int!
  "GTFS trips.bikes_allowed"
  bikes_allowed: Int!
  "Calculated stop pattern ID; an integer scoped to the feed version"
  stop_pattern_id: Int!
  "Calendar for this trip"
  calendar: Calendar!
  "Route for this trip"
  route: Route!
  "Shape for this trip"
  shape: Shape
  "Feed version for this entity"
  feed_version: FeedVersion!
  "Stop times for this trip"
  stop_times(limit: Int, where: TripStopTimeFilter): [StopTime]!
  "Frequencies for this trip"
  frequencies(limit: Int): [Frequency!]!
  "GTFS-RT alerts for this trip"
  alerts(active: Boolean, limit: Int): [Alert!]
  "GTFS-RT ScheduleRelationship"
  schedule_relationship: ScheduleRelationship
  "GTFS-RT TripUpdate timestamp"
  timestamp: Time
}

"""
Record from a static GTFS [calendars.txt](https://gtfs.org/schedule/reference/#calendarstxt) file.
"""
type Calendar {
  "Internal integer ID"
  id: Int!
  "GTFS calendar.service_id"
  service_id: String!
  "GTFS calendar.start_date"
  start_date: Date!
  "GTFS calendar.end_date"
  end_date: Date!
  "GTFS calendar.monday"
  monday: Int!
  "GTFS calendar.tuesday"
  tuesday: Int!
  "GTFS calendar.wednesday"
  wednesday: Int!
  "GTFS calendar.thursday"
  thursday: Int!
  "GTFS calendar.friday"
  friday: Int!
  "GTFS calendar.saturday"
  saturday: Int!
  "GTFS calendar.sunday"
  sunday: Int!
  "Added dates, derived from GTFS calendar_dates"
  added_dates(limit: Int): [Date!]!
  "Removed dates, derived from GTFS calendar_dates"
  removed_dates(limit: Int): [Date!]!
}

"""
Record from a static GTFS [shapes.txt](https://gtfs.org/schedule/reference/#shapestxt) file.
"""
type Shape {
  "Internal integer ID"
  id: Int!
  "GTFS shapes.shape_id"
  shape_id: String!
  "Geometry for this shape"
  geometry: LineString!
  "Was this geometry automatically generated from stop locations?"
  generated: Boolean!
}

"""
Record from a static GTFS [frequencies.txt](https://gtfs.org/schedule/reference/#frequenciestxt) file.
"""
type Frequency {
  "Internal integer ID"
  id: Int!
  "GTFS frequencies.start_time"
  start_time: Seconds!
  "GTFS frequencies.end_time"
  end_time: Seconds!
  "GTFS frequencies.headway_secs"
  headway_secs: Int!
  "GTFS frequencies.exact_times"
  exact_times: Int!
}

"""
Record from a static GTFS [stop_times.txt](https://gtfs.org/schedule/reference/#stop_timestxt) file.
"""
type StopTime {
  "GTFS stop_times.arrival_time"
  arrival_time: Seconds!
  "GTFS stop_times.departure_time"
  departure_time: Seconds!
  "GTFS stop_times.stop_sequence"
  stop_sequence: Int!
  "GTFS stop_times.stop_headsign"
  stop_headsign: String
  "GTFS stop_times.pickup_type"
  pickup_type: Int
  "GTFS stop_times.drop_off_type"
  drop_off_type: Int
  "GTFS stop_times.timepoint"
  timepoint: Int
  "GTFS stop_times.continuous_drop_off"
  continuous_drop_off: Int
  "GTFS stop_times.continuous_pickup"
  continuous_pickup: Int
  "GTFS stop_times.shape_dist_traveled"
  shape_dist_traveled: Float
  "Set if this arrival/departure time was interpolated during import"
  interpolated: Int
  "Stop associated with this stop time"
  stop: Stop!
  "Trip associated with this stop time"
  trip: Trip!
  "Detailed arrival information, including GTFS-RT updates and estimates"
  arrival: StopTimeEvent!
  "Detailed departure information, including GTFS-RT updates and estimates"
  departure: StopTimeEvent!
  "If part of an arrival/departure query, the GTFS service date for this scheduled stop time"
  service_date: Date
  "If part of an arrival/departure query, the calendar date for this scheduled stop time"
  date: Date
  "GTFS-RT SceduleRelationship; set to STATIC if no associated GTFS-RT data"
  schedule_relationship: ScheduleRelationship
}

"""
Record from a static GTFS [feed_info.txt](https://gtfs.org/schedule/reference/#feed_infotxt) file.
"""
type FeedInfo {
  "Internal integer ID"
  id: Int!
  "GTFS feed_info.feed_publisher_name"
  feed_publisher_name: String!
  "GTFS feed_info.feed_publisher_url"
  feed_publisher_url: String!
  "GTFS feed_info.feed_lang"
  feed_lang: String!
  "GTFS feed_info.default_lang"
  default_lang: String
  "GTFS feed_info.feed_version"
  feed_version: String!
  "GTFS feed_info.feed_start_date"
  feed_start_date: Date
  "GTFS feed_info.feed_end_date"
  feed_end_date: Date
  "GTFS feed_info.feed_contact_email"
  feed_contact_email: String
  "GTFS feed_info.feed_contact_url"
  feed_contact_url: String
}

# Archived observed stop-times

type StopObservation {
  schedule_relationship: String
  trip_start_date: Date
  trip_start_time: Seconds
  from_stop_id: String
  to_stop_id: String
  agency_id: String
  route_id: String
  trip_id: String
  stop_sequence: Int
  source: String
  scheduled_arrival_time: Seconds
  scheduled_departure_time: Seconds
  observed_arrival_time: Seconds
  observed_departure_time: Seconds
}

# GTFS Support Entities

type StopExternalReference {
  id: Int!
  target_feed_onestop_id: String
  target_stop_id: String
  inactive: Boolean
  target_active_stop: Stop
}

"""Place associated with a stop"""
type StopPlace {
  """Best-matched state or province name"""
  adm1_name: String
  """Best-matched state or province ISO code"""
  adm1_iso: String
  """Best-matched country name"""
  adm0_name: String
  """Best-mached country ISO code"""
  adm0_iso: String
}

"""Place associated with an agency"""
type AgencyPlace {
  """Best-matched city name"""
  city_name: String
  """Best-matched state or province name"""
  adm1_name: String
  """Best-matched state or province ISO code"""
  adm1_iso: String
  """Best-matched country name"""
  adm0_name: String
  """Best-mached country ISO code"""
  adm0_iso: String
  """Relative weight of this place association"""
  rank: Float
}

"""Place name and associated operators"""
type Place {
  "Country name"
  adm0_name: String
  "State or province name"
  adm1_name: String
  "City name"
  city_name: String
  "Number of associated operators"
  count: Int!
  "Operators associated with this place"
  operators: [Operator!]
}

"""RelativeDate specifies a calendar date relative to the current local time"""
enum RelativeDate {
  TODAY
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
  NEXT_MONDAY
  NEXT_TUESDAY
  NEXT_WEDNESDAY
  NEXT_THURSDAY
  NEXT_FRIDAY
  NEXT_SATURDAY
  NEXT_SUNDAY
}

"""PlaceAggregationLevel controls the level of aggregation in a places query"""
enum PlaceAggregationLevel {
  ADM0
  ADM0_ADM1
  ADM0_ADM1_CITY
  ADM0_CITY
  ADM1_CITY
  CITY
}


"""
RouteStops describe associations between stops, routes, and agencies.
"""
type RouteStop {
  "Internal integer ID"
  id: Int!
  "Internal integer ID for this associated stop"
  stop_id: Int!
  "Internal integer ID for this associated route"
  route_id: Int!
  "Internal integer ID for this associated agency"
  agency_id: Int!
  "Associated route"
  route: Route!
  "Associated stop"
  stop: Stop!
  "Associated agency"
  agency: Agency!
}

"""
RouteStopPattern describes a unique pattern of stops for a route
"""
type RouteStopPattern {
  "An identifier for this stop pattern; an integer scoped to this particular feed version"
  stop_pattern_id: Int!
  "Direction ID of the trip"
  direction_id: Int!
  "Count of trips for this stop pattern"
  count: Int!
  "Trips for this stop pattern"
  trips(limit: Int): [Trip!]
}

"""
Representative route geometries
"""
type RouteGeometry {
  "If true, the source GTFS feed provides no shapes. This route geometry is based on straight lines between stop points."
  generated: Boolean!
  "A single LineString of this most common shape"
  geometry: LineString
  "MultiLineString ensemble of the most common shapes for each direction"
  combined_geometry: Geometry
  "Length (in meters) of the simple geometry"
  length: Float
  "Maximum point-to-point distance in the geometry"
  max_segment_length: Float
  "First point max distance"
  first_point_max_distance: Float
}

type RouteHeadway {
  stop: Stop!
  dow_category: Int
  direction_id: Int
  headway_secs: Int
  service_date: Date
  stop_trip_count: Int
  departures: [Seconds!]
}

type SegmentPattern {
  id: Int!
  route: Route!
  stop_pattern_id: Int!
  segment: Segment!
}

type Segment {
  id: Int!
  way_id: Int!
  geometry: LineString! 
  segment_patterns: [SegmentPattern!]
}

"""
MTC GTFS+ Extension: route_attributes.txt
"""
type RouteAttribute {
  category: Int
  subcategory: Int
  running_way: Int
}

# Census entities

type CensusGeography {
  id: Int!
  layer_name: String!
  geoid: String
  name: String
  aland: Float
  awater: Float
  geometry: Polygon
  values(table_names: [String!]!, limit: Int): [CensusValue]!
}

type CensusValue {
  table: CensusTable!
  values: Map!
}

type CensusTable {
  id: Int!
  table_name: String!
  table_title: String!
  table_group: String!
}

# Realtime updates

enum ScheduleRelationship {
  SCHEDULED
  ADDED
  UNSCHEDULED
  CANCELED
  STATIC
  SKIPPED
  NO_DATA
  REPLACEMENT
  DUPLICATED
  DELETED
}

type StopTimeEvent {
  """Local time for stop"""
  stop_timezone: String!
  """Estimated schedule times; can be based on propagated delay"""
  estimated_utc: Time
  estimated_unix: Int
  estimated_local: Time
  estimated_delay: Int
  estimated: Seconds
  """Static schedule times"""
  scheduled_utc: Time
  scheduled_unix: Int
  scheduled_local: Time
  scheduled: Seconds
  """Raw RT values"""
  time_utc: Time
  time_unix: Int
  delay: Int
  uncertainty: Int
}

"""
[Vehicle Position](https://gtfs.org/reference/realtime/v2/#message-vehicleposition) message provided by a source GTFS Realtime feed.
"""
type VehiclePosition {
  vehicle: RTVehicleDescriptor
  position: Point
  current_stop_sequence: Int
  stop_id: Stop
  current_status: String
  timestamp: Time
  congestion_level: String
}

"""
[Alert](https://gtfs.org/reference/realtime/v2/#message-alert) message, also called a service alert, provided by a source GTFS Realtime feed.
"""
type Alert {
  active_period: [RTTimeRange!]
  cause: String
  effect: String
  header_text: [RTTranslation!]!
  description_text: [RTTranslation!]!
  tts_header_text: [RTTranslation!]
  tts_description_text: [RTTranslation!]
  url: [RTTranslation!]
  severity_level: String
}

"""
See https://gtfs.org/reference/realtime/v2/#message-timerange
"""
type RTTimeRange {
  start: Int
  end: Int
}

"""
See https://gtfs.org/reference/realtime/v2/#message-vehicledescriptor
"""
type RTVehicleDescriptor {
  id: String
  label: String
  license_plate: String
}

"""
See https://gtfs.org/reference/realtime/v2/#message-tripdescriptor
"""
type RTTripDescriptor {
  trip_id: String
  route_id: String
  direction_id: Int
  start_time: Seconds
  start_date: Date
  schedule_relationship: String
}

"""
See https://gtfs.org/reference/realtime/v2/#message-translatedstring
"""
type RTTranslation {
  text: String!
  language: String
}


# Analysis tools

type RouteStopBuffer {
  stop_points: Geometry
  stop_buffer: Geometry
  stop_convexhull: Polygon
}

# Validation tools

type ValidationReport {
  # Validation output
  id: Int!
  reported_at: Time
  reported_at_local: Time
  reported_at_local_timezone: String
  success: Boolean!
  failure_reason: String
  includes_static: Boolean
  includes_rt: Boolean
  validator: String
  validator_version: String
  errors(limit: Int): [ValidationReportErrorGroup!]! @goField(forceResolver: true)
  warnings(limit: Int): [ValidationReportErrorGroup!]! @goField(forceResolver: true)
  details: ValidationReportDetails @goField(forceResolver: true)
}

type ValidationReportDetails {
  sha1: String!
  earliest_calendar_date: Date
  latest_calendar_date: Date
  files: [FeedVersionFileInfo!]!
  service_levels(limit: Int, route_id: String): [FeedVersionServiceLevel!]!
  agencies(limit: Int): [Agency!]!
  routes(limit: Int): [Route!]!
  stops(limit: Int): [Stop!]!
  feed_infos(limit: Int): [FeedInfo!]!
  realtime: [ValidationRealtimeResult!]
}

type ValidationRealtimeResult {
  url: String!
  json: Map!
}

type ValidationReportErrorGroup {
  filename: String!
  error_type: String!
  error_code: String!
  group_key: String!
  field: String!
  count: Int!
  errors(limit: Int): [ValidationReportError!]! @goField(forceResolver: true)
}

type ValidationReportError {
  filename: String!
  error_type: String!
  error_code: String!
  group_key: String!
  entity_id: String!
  field: String!
  line: Int!
  value: String!
  message: String!
  geometry: Geometry
  entity_json: Map!
}

type FeedVersionFetchResult {
  feed_version: FeedVersion
  fetch_error: String
  found_sha1: Boolean!
  found_dir_sha1: Boolean!
}

type FeedVersionImportResult {
  success: Boolean!
}

type FeedVersionUnimportResult {
  success: Boolean!
}

type FeedVersionDeleteResult {
  success: Boolean!
}


# Update inputs

input FeedVersionSetInput {
  id: Int
  name: String
  description: String
}

# Query filters

input OperatorFilter {
  merged: Boolean
  onestop_id: String
  feed_onestop_id: String
  agency_id: String
  search: String
  tags: Tags
  city_name: String
  adm0_name: String
  adm1_name: String
  adm0_iso: String
  adm1_iso: String
  license: LicenseFilter
  bbox: BoundingBox
  within: Polygon
  near: PointRadius
}

input ValidationReportFilter {
  report_ids: [Int!]
  success: Boolean
  validator: String
  validator_version: String
  includes_rt: Boolean
  includes_static: Boolean
}

input FeedVersionFilter {
  import_status: ImportStatus
  feed_onestop_id: String
  sha1: String
  file: String
  feed_ids: [Int!]
  covers: ServiceCoversFilter
  bbox: BoundingBox
  within: Polygon
  near: PointRadius
}

enum ImportStatus {
  SUCCESS
  ERROR
  IN_PROGRESS
}

enum LicenseValue {
  YES
  NO
  EXCLUDE_NO
  UNKNOWN
}

input FeedFilter {
  "Search for feed with a specific Onestop ID"
  onestop_id: String
  "Search for feeds of certain data types"
  spec: [FeedSpecTypes!]
  "Search for feeds with or without a fetch error"
  fetch_error: Boolean
  "Search for feeds by their import status"
  import_status: ImportStatus
  "Full text search"
  search: String
  "Search for feeds with a tag"
  tags: Tags,
  "Search for feeds by their source URLs"
  source_url: FeedSourceUrl
  license: LicenseFilter
  bbox: BoundingBox
  within: Polygon
  near: PointRadius
}

input FeedFetchFilter {
  success: Boolean
}

input FeedSourceUrl {
  url: String
  type: FeedSourceUrlTypes
  case_sensitive: Boolean
}

enum FeedSourceUrlTypes {
  static_current
  static_historic
  static_planned
  static_hypothetical
  realtime_vehicle_positions
  realtime_trip_updates
  realtime_alerts
  gbfs_auto_discovery
  mds_provider
}

"""
Type of data contained in a source feed
"""
enum FeedSpecTypes {
  GTFS
  GTFS_RT
  GBFS
  MDS
}

input AgencyFilter {
  onestop_id: String
  feed_version_sha1: String
  feed_onestop_id: String
  agency_id: String
  "Search for records with this GTFS agency_name"
  agency_name: String
  bbox: BoundingBox
  within: Polygon
  "Search for agencies within a radius"
  near: PointRadius
  "Full text search"
  search: String
  "Search by city name (provided by Natural Earth)"
  city_name: String
  "Search by country name (provided by Natural Earth)"
  adm0_name: String
  "Search by state/province/division name (provided by Natural Earth)"
  adm1_name: String
  "Search by country 2 letter ISO 3166 code (provided by Natural Earth)"
  adm0_iso: String
  "Search by state/province/division ISO 3166-2 code (provided by Natural Earth)"
  adm1_iso: String
  license: LicenseFilter
}

input RouteFilter {
  onestop_id: String
  onestop_ids: [String!]
  allow_previous_onestop_ids: Boolean
  feed_version_sha1: String
  feed_onestop_id: String
  route_id: String
  route_type: Int
  serviced: Boolean
  bbox: BoundingBox
  within: Polygon
  near: PointRadius
  search: String
  operator_onestop_id: String
  license: LicenseFilter
  agency_ids: [Int!] # keep?
}

input StopFilter {
  onestop_id: String
  onestop_ids: [String!]
  allow_previous_onestop_ids: Boolean
  feed_version_sha1: String
  feed_onestop_id: String
  stop_id: String
  stop_code: String
  location_type: Int
  serviced: Boolean
  bbox: BoundingBox
  within: Polygon
  near: PointRadius
  search: String
  license: LicenseFilter
  served_by_onestop_ids: [String!]
  served_by_route_type: Int
  agency_ids: [Int!] # keep?
}

input StopTimeFilter {
  date: Date
  relative_date: RelativeDate
  service_date: Date
  use_service_window: Boolean
  start_time: Int
  end_time: Int
  start: Seconds
  end: Seconds
  next: Int
  route_onestop_ids: [String!] # keep?
  allow_previous_route_onestop_ids: Boolean
  exclude_first: Boolean
  exclude_last: Boolean
}

input TripStopTimeFilter {
  start: Seconds
  end: Seconds
}

input StopObservationFilter {
  source: String!
  feed_version_id: Int!
  trip_start_date: Date!
}

input PathwayFilter {
  pathway_mode: Int
}

input TripFilter {
  service_date: Date
  relative_date: RelativeDate
  use_service_window: Boolean
  trip_id: String
  stop_pattern_id: Int
  license: LicenseFilter
  route_ids: [Int!] # keep?
  route_onestop_ids: [String!] # keep?
  feed_version_sha1: String
  feed_onestop_id: String
}

input SegmentFilter {
  layer: String
}

input SegmentPatternFilter {
  layer: String
}

input LicenseFilter {
  share_alike_optional: LicenseValue
  create_derived_product: LicenseValue
  commercial_use_allowed: LicenseValue
  use_without_attribution: LicenseValue
  redistribution_allowed: LicenseValue
}

input FeedVersionServiceLevelFilter {
  start_date: Date
  end_date: Date
}

input ServiceCoversFilter {
  fetched_after: Time
  fetched_before: Time
  "Search using only feed_info.txt values"
  feed_start_date: Date
  "Search using only feed_info.txt values"
  feed_end_date: Date
  "Search using feed_info.txt values or calendar maximum service extent"
  start_date: Date
  "Search using feed_info.txt values or calendar maximum service extent"
  end_date: Date
  "Search using calendar maximum service extent"
  earliest_calendar_date: Date
  "Search using calendar maximum service extent"
  latest_calendar_date: Date
}

input AgencyPlaceFilter {
  min_rank: Float
}

input PlaceFilter {
  min_rank: Float
  adm0_name: String
  adm1_name: String
  city_name: String
}

input CalendarDateFilter {
  date: Date
  exception_type: Int
}

input PointRadius {
  lat: Float!
  lon: Float!
  radius: Float!
}

input BoundingBox {
  min_lon: Float!
  min_lat: Float!
  max_lon: Float!
  max_lat: Float!
}

# entity mutations

input FeedVersionInput {
  id: Int
}

input StopSetInput {
  id: Int
  feed_version: FeedVersionInput
  location_type: Int
  stop_code: String
  stop_desc: String
  stop_id: String
  stop_name: String
  stop_timezone: String
  stop_url: String
  wheelchair_boarding: Int
  zone_id: String
  platform_code: String
  tts_stop_name: String
  geometry: Point
  parent: StopSetInput
  level: LevelSetInput
}

input LevelSetInput {
  id: Int
  feed_version: FeedVersionInput
  level_id: String
  level_name: String
  level_index: Float
  geometry: Polygon
  parent: StopSetInput
}

input PathwaySetInput {
  id: Int
  feed_version: FeedVersionInput
  pathway_id: String
  pathway_mode: Int
  is_bidirectional: Int
  length: Float
  traversal_time: Int
  stair_count: Int
  max_slope: Float
  min_width: Float
  signposted_as: String
  reverse_signposted_as: String
  from_stop: StopSetInput
  to_stop: StopSetInput
}
